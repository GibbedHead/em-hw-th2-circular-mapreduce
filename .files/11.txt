Файл: /model/src/main/resources/customsql/ItemQueries.hbm.xml
<sql-query name="loadImagesForItem">
<load-collection alias="img" role="Item.images"/>
select
ITEM_ID, FILENAME, WIDTH, HEIGHT
from
ITEM_IMAGES
where
ITEM_ID = ?
</sql-query>
Запрос должен иметь единственный (позиционный или именованный) пара-
метр. Hibernate подставит вместо него значение идентификатора сущности, влаНастройка
операций CRUD  513
деющей коллекцией. При каждой инициализации коллекции Item#images Hibernate
будет выполнять ваш запрос SQL.
Но иногда переопределять весь запрос SQL для загрузки коллекции не тре-
буется, например если нужно всего лишь добавить ограничение в сгенерирован-
ное выражение SQL. Предположим, что сущность Category содержит коллекцию
объектов Item, и каждый объект Item имеет признак активности. Если свойство
Item#active имеет значение false, при обходе коллекции Category#items такой объ-
ект загружать не нужно. Такое ограничение можно добавить в запрос SQL с по-
мощью Hibernate-аннотации @Where, поместив ее перед отображением коллекции:
Файл: /model/src/main/java/org/jpwh/model/customsql/Category.java
@Entity
public class Category {
@OneToMany(mappedBy = "category")
@org.hibernate.annotations.Where(clause = "ACTIVE = 'true'")
protected Set<Item> items = new HashSet<Item>();
// ...
}
Как показано далее, также можно писать собственные запросы SQL для вставки
и удаления элементов коллекции.
Листинг 17.5  Произвольные выражения CUD для модификации коллекции
Файл: /model/src/main/java/org/jpwh/model/customsql/Item.java
@Entity
public class Item {
@ElementCollection
@org.hibernate.annotations.SQLInsert(
sql = "insert into ITEM_IMAGES " +
"(ITEM_ID, FILENAME, HEIGHT, WIDTH) " +
"values (?, ?, ?, ?)"
)
@org.hibernate.annotations.SQLDelete(
sql = "delete from ITEM_IMAGES " +
"where ITEM_ID = ? and FILENAME = ? and HEIGHT = ? and WIDTH = ?"
)
@org.hibernate.annotations.SQLDeleteAll(
sql = "delete from ITEM_IMAGES where ITEM_ID = ?"
)
protected Set<Image> images = new HashSet<Image>();
// ...
}
Чтобы определить правильный порядок параметров, включите уровень жур-
налирования DEBUG для категории org.hibernate.persister.collection и найдите
514  Настройка SQL-запросов
в журнале сгенерированные для этой коллекции выражения SQL; это нужно сде-
лать перед тем, как добавлять аннотации SQL с собственными запросами. Ниже
показана новая аннотация @SQLDeleteAll, которая может использоваться только
для коллекций простых или встраиваемых типов. Hibernate выполнит это вы-
ражение SQL, когда потребуется удалить коллекцию из базы данных целиком:
например, при вызове someItem .getImages().clear() или someItem.setImages(new
HashSet()).
Для этой коллекции не нужно использовать аннотацию @SQLUpdate, поскольку
Hibernate не изменяет элементов коллекции встраиваемых типов. Когда меняется
значение свойства изображения Image, для Hibernate это будет новый объект Imageв
коллекции (не забывайте, что изображения сравниваются «по значению», то есть
сравниваются все их поля). Поэтому Hibernate выполнит операцию удаления DELETE
для старого элемента и операцию вставки INSERT для нового.
Вместо отложенной загрузки элементов коллекции их можно загружать немед-
ленно, вместе с сущностью-владельцом. Также можно заменить этот запрос соб-
ственным выражением SQL.
17.3.4. Немедленное извлечение в собственном загрузчике
Рассмотрим коллекцию ставок Item#bids и порядок ее загрузки. По умолчанию
Hibernate использует отложенную загрузку, поскольку коллекция отображается
аннотацией @OneToMany, и, следовательно, запрос для загрузки элементов выпол-
нится, лишь когда начнется обход коллекции. Таким образом, во время загрузки
экземпляра Item не придется загружать никаких элементов коллекции.
Если, напротив, потребуется загрузить коллекцию Item#bids немедленно, вместе
с экземпляром Item, сначала нужно поместить аннотацию загрузчика с запро-
сом перед определением класса Item:
Файл: /model/src/main/java/org/jpwh/model/customsql/Item.java
@org.hibernate.annotations.Loader(
namedQuery = "findItemByIdFetchBids"
)
@Entity
public class Item {
@OneToMany(mappedBy = "item")
protected Set<Bid> bids = new HashSet<>();
// ...
}
Как и в предыдущих примерах, необходимо определить именованный запрос
в XML-файле метаданных Hibernate, поскольку не существует аннотаций для
загрузки коллекций с помощью именованных запросов. Ниже показан код SQL,
загружающий экземпляр Item вместе с коллекцией bids с помощью внешнего со-
единения (OUTER JOIN):
Настройка операций CRUD  515
Файл: /model/src/main/resources/customsql/ItemQueries.hbm.xml
<sql-query name="findItemByIdFetchBids">
<return alias="i" class="Item"/>
<return-join alias="b" property="i.bids"/>
select
{i.*}, {b.*}
from
ITEM i
left outer join BID b
on i.ID = b.ITEM_ID
where
i.ID = ?
</sql-query>
Вы уже видели этот запрос с отображением результатов в коде Java выше в этой
главе, в разделе «Немедленное извлечение коллекций». Здесь добавлено ограни-
чение, допускающее возврат единственной записи из таблицы ITEM с заданным
первичным ключом.
Аналогично можно немедленно загружать связи с единственным значением,
такие как @ManyToOne, используя собственные запросы SQL. Предположим, что
требуется немедленно загрузить свойство bidder вместе с экземпляром Bid. Для
начала нужно определить загрузчик с именованным запросом:
Файл: /model/src/main/java/org/jpwh/model/customsql/Bid.java
@org.hibernate.annotations.Loader(
namedQuery = "findBidByIdFetchBidder"
)
@Entity
public class Bid {
@ManyToOne(optional = false, fetch = FetchType.LAZY)
protected User bidder;
// ...
}
В отличие от запросов, загружающих коллекции, свой именованный запрос
можно определить с помощью стандартных аннотаций (конечно, можно поместить
его в файл XML, используя синтаксис JPA или Hibernate):
Файл: /model/src/main/java/org/jpwh/model/customsql/Bid.java
@NamedNativeQueries({
@NamedNativeQuery(
name = "findBidByIdFetchBidder",
query =
"select " +
"b.ID as BID_ID, b.AMOUNT, b.ITEM_ID, b.BIDDER_ID, " +
"u.ID as USER_ID, u.USERNAME, u.ACTIVATED " +
516  Настройка SQL-запросов
"from BID b join USERS u on b.BIDDER_ID = u.ID " +
"where b.ID = ?",
resultSetMapping = "BidBidderResult"
)
})
@Entity
public class Bid {
// ...
}
Внутреннее соединение (INNER JOIN) вполне уместно в данном запросе SQL, по-
скольку свойство bidder экземпляра Bid не может быть пустым, а столбец внешне-
го ключа BIDDER_ID не может принимать значения NULL. Поскольку в запросе нужно
переименовывать повторяющиеся столбцы ID в BID_ID и USER_ID, понадобится соб-
ственное отображение результата запроса:
Файл: /model/src/main/java/org/jpwh/model/customsql/Bid.java
@SqlResultSetMappings({
@SqlResultSetMapping(
name = "BidBidderResult",
entities = {
@EntityResult(
entityClass = Bid.class,
fields = {
@FieldResult(name = "id", column = "BID_ID"),
@FieldResult(name = "amount", column = "AMOUNT"),
@FieldResult(name = "item", column = "ITEM_ID"),
@FieldResult(name = "bidder", column = "BIDDER_ID")
}
),
@EntityResult(
entityClass = User.class,
fields = {
@FieldResult(name = "id", column = "USER_ID"),
@FieldResult(name = "username", column = "USERNAME"),
@FieldResult(name = "activated", column = "ACTIVATED")
}
)
}
)
})
@Entity
public class Bid {
// ...
}
Hibernate выполнит этот запрос SQL и отобразит результаты во время загрузки
экземпляра Bid при вызове метода em.find(Bid.class, BID_ID) или при инициализа-
Вызов хранимых процедур  517
ции прокси-объекта Bid. Hibernate сразу же загрузит поле Bid#bidder, невзирая на
параметр FetchType.LAZY в параметрах связи.
Вот мы и настроили выполнение собственных запросов SQL для всех операций.
Далее мы рассмотрим хранимые процедуры и узнаем, как интегрировать их в при-
ложение Hibernate.
17.4. Вызов хранимых процедур
Хранимые процедуры часто используются при разработке приложений баз дан-
ных. Размещение кода ближе к данным, и его выполнение внутри базы данных
дает определенные преимущества. Это позволяет избежать дублирования функ-
циональности и логики во всех программах, работающих с этими данными. Также
принято считать, что общая бизнес-логика тоже не должна дублироваться всеми
приложениями. К такой логике относятся процедуры, обеспечивающие целост-
ность данных, проверяющие ограничения, которые слишком сложно описывать
декларативно. Вы часто будете встречать в базах данных триггеры, проверяющие
правила целостности.
Хранимые процедуры показывают свое преимущество при обработке больших
объемов данных для создания отчетов или статистического анализа. Вы должны
стараться избегать передачи больших объемов данных между базой и сервером
приложения, поэтому при обработке больших объемов следует в первую очередь
использовать хранимые процедуры.
Конечно, существуют системы (часто унаследованные), которые даже базовые
операции CRUD реализуют с помощью хранимых процедур. Стоит упомянуть
и о системах, не позволяющих напрямую выполнять SQL-выражения INSERT, UPDATE
или DELETE, а допускающих только вызовы хранимых процедур; когда-то та-
кие системы применялись очень широко (и даже сейчас иногда применяются).
Некоторые СУБД позволяют объявлять пользовательские функции вместо
или вместе с хранимыми процедурами. В табл. 17.1 перечислены некоторые раз-
личия между процедурами и функциями.
Таблица 17.1. Сравнение процедур и функций, определяемых в базе данных
Хранимая процедура Функция
Может иметь входные и/или выходные
параметры
Может иметь входные параметры
Возвращет ноль, одно или несколько
значений
Должна возвращать значение (хотя оно
не обязательно будет скаляром или даже NULL)
Может вызываться только с помощью
JDBC-объекта CallableStatement
Может вызываться прямо в предложениях SELECT,
WHERE и т. д.
Трудно обобщать и сравнивать процедуры и функции вне этих очевидных раз-
личий. Разные СУБД по-разному их поддерживают: некоторые не поддерживают
хранимых процедур или функций, определяемых пользователем, тогда как дру-
гие не делают между ними различий (так, например, в PostgreSQL есть только
518  Настройка SQL-запросов
пользовательские функции). Языки программирования для описания хранимых
процедур обычно имеют специфические особенности для каждой СУБД. Некото-
рые базы данных даже поддерживают хранимые процедуры, написанные на языке
Java. Стандартизация хранимых процедур на Java проводилась в рамках стандарта
SQLJ, который, к сожалению, не возымел успеха.
В этом разделе мы покажем, как интегрировать хранимые процедуры MySQL
и пользовательские функции PostgreSQL с Hibernate. Сначала мы рассмотрим объ-
явления и вызовы хранимых процедур с помощью стандартного Java Persistence
API и оригинального Hibernate API. Затем настроим и заменим CRUD-операции
Hibernate вызовами хранимых процедур. Важно, чтобы вы прочитали предыдущий
раздел перед этим, поскольку интеграция хранимых процедур основана на тех же
способах отображения, что и остальные модификации выражений SQL в Hibernate.
Как и ранее в этой главе, хранимые процедуры SQL в примерах довольно просты,
чтобы вы могли сосредоточиться на более важных аспектах: вызове процедур
и использовании API в своем приложении.
Вызывая хранимую процедуру, вы обычно передаете входные аргументы и по-
лучаете возвращаемое значение. Процедуры можно разделить на следующие ка-
тегории:
 возвращают результат запроса;
 возвращают несколько результатов запросов;
 изменяют данные и возвращают количество измененных строк;
 принимают входные и/или выходные аргументы;
 возвращают курсор, ссылающийся на результат в базе данных.
Рассмотрим простейший случай: хранимую процедуру без параметров, которая
возвращает только результат запроса.
17.4.1. Возврат результата запроса
В MySQL можно создать следующую процедуру. Она возвращает результат запро-
са, содержащий все строки таблицы ITEM:
Файл: /model/src/main/resources/querying/StoredProcedures.hbm.xml
create procedure FIND_ITEMS()
begin
select * from ITEM;
end
Чтобы вызвать ее, с помощью объекта EntityManager нужно создать экземпляр
запроса StoredProcedureQuery и выполнить его:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
StoredProcedureQuery query = em.createStoredProcedureQuery(
"FIND_ITEMS",
Item.class Или имя отображения результатов запроса
);
Вызов хранимых процедур  519
List<Item> result = query.getResultList();
for (Item item : result) {
// ...
}
Как вы уже видели ранее в этой главе, Hibernate автоматически отобразит
столбцы возвращаемого результата в свойства класса Item. Экземпляры Item, воз-
вращаемые этим запросом, будут находиться в управляемом хранимом состоянии.
Вместо параметра Item.class методу можно передать имя отображения.
Особенности Hibernate
Используя оригинальный интерфейс Session фреймворка Hibernate, можно полу-
чить результат вызова хранимой процедуры с помощью объекта Procedure.
Файл: /example/src/test/java/org/jpwh/test/querying/sql
org.hibernate.procedure.ProcedureCall call =
session.createStoredProcedureCall("FIND_ITEMS", Item.class);
org.hibernate.result.ResultSetOutput resultSetOutput =
(org.hibernate.result.ResultSetOutput) call.getOutputs().getCurrent();
List<Item> result = resultSetOutput.getResultList();
Метод getCurrent() как бы намекает, что процедура может возвращать более
одного объекта ResultSet. Процедура может вернуть не только несколько резуль-
татов, но также количество произведенных изменений, если она изменяла какие-
то данные.
17.4.2. Возврат нескольких результатов и количества
изменений
Следующая процедура MySQL возвращает все записи из таблицы ITEM, которые
не были одобрены, меняя их статус APPROVED, а также все записи, которые были
одобрены:
Файл: /model/src/main/resources/querying/StoredProcedures.hbm.xml
create procedure APPROVE_ITEMS()
begin
select * from ITEM where APPROVED = 0;
select * from ITEM where APPROVED = 1;
update ITEM set APPROVED = 1 where APPROVED = 0;
end
Приложение в этом случае получит два результата запроса и количество про-
изведенных изменений: доступ к результатам вызова процедуры и их обработка
выглядят не так просто, но поскольку JPA тесно связан с JDBC, то, если вы уже
работали с хранимыми процедурами, следующий код будет вам знаком:
520  Настройка SQL-запросов
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
StoredProcedureQuery query = em.createStoredProcedureQuery(
"APPROVE_ITEMS",
Item.class Или имя отображения результатов запроса
);
boolean isCurrentReturnResultSet = query.execute();  Вызов метода execute()
while (true) {  Обработка результатов вызова
if (isCurrentReturnResultSet) {  Обработка результатов запроса
List<Item> result = query.getResultList();
// ...
} else {
int updateCount = query.getUpdateCount(); Счетчики изменений закончились:
if (updateCount > -1) { выход из цикла
// ...
} else {
break;  Обработка счетчиков изменений
}
}
isCurrentReturnResultSet = query.hasMoreResults();  Переход к следующему результату
}
 Вызов хранимой процедуры методом execute(). Он вернет true, если хранимая процеду-
ра вернула результат запроса, и false, если результатом является счетчик изменений.
 Обработка всех результатов в цикле. Когда результатов не останется, происходит выход
из цикла: в этом случае метод hasMoreResults() вернет false, а метод getUpdateCount()
вернет –1.
 Если процедура вернула результат запроса, обработать его. Hibernate отобразит столбцы
каждого результата в управляемые экземпляры класса Item. Также можно использовать
собственное отображение результатов, применимое для всех результатов, возвращаемых
процедурой.
 Если текущее возвращаемое значение является счетчиком изменений, метод getUpdate-
Count() вернет значение больше –1.
 Метод hasMoreResults() выполнит переход к следующему результату и укажет его тип.
Особенности Hibernate
Вызов хранимых процедур с помощью Hibernate может показаться более простым.
Фреймворк скрывает сложности, связанные с проверкой типа каждого результата
и наличия оставшихся выходных значений процедуры:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
org.hibernate.procedure.ProcedureCall call =
session.createStoredProcedureCall("APPROVE_ITEMS", Item.class);
org.hibernate.procedure.ProcedureOutputs callOutputs = call.getOutputs();
Вызов хранимых процедур  521
org.hibernate.result.Output output; Проверяет наличие
while ((output = callOutputs.getCurrent()) != null) {  выходных значений
if (output.isResultSet()) {  Выходное значение – результат запроса?
List<Item> result =
((org.hibernate.result.ResultSetOutput) output)
.getResultList();
// ...
} else {
int updateCount =  Выходное значение является счетчиком обновлений
((org.hibernate.result.UpdateCountOutput) output)
.getUpdateCount();
// ...
}
if (!callOutputs.goToNext())  Продолжить
break;
}
 Пока метод getCurrent() не вернул null, имеются выходные значения для обработки.
 Выходное значение может быть результатом запроса: проверить это и выполнить при-
ведение типа.
 Если выходное значение не является результатом запроса, это счетчик обновлений.
 Если остались еще выходные значения, продолжить обработку.
Далее мы рассмотрим хранимые процедуры с входными и выходными параметрами.
17.4.3. Передача входных и выходных аргументов
Следующая хранимая процедура MySQL вернет запись из таблицы ITEM с задан-
ным идентификатором, а также количество записей в таблице:
Файл: /model/src/main/resources/querying/StoredProcedures.hbm.xml
create procedure FIND_ITEM_TOTAL(in PARAM_ITEM_ID bigint,
out PARAM_TOTAL bigint)
begin
select count(*) into PARAM_TOTAL from ITEM;
select * from ITEM where ID = PARAM_ITEM_ID;
end
Следующая процедура вернет результат запроса с данными из записи ITEM. До-
полнительно ей передается выходной параметр PARAM_TOTAL. Для вызова хранимой
процедуры с помощью JPA сначала нужно описать все параметры.
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
StoredProcedureQuery query = em.createStoredProcedureQuery(
"FIND_ITEM_TOTAL",
Item.class
522  Настройка SQL-запросов
);
query.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN);
query.registerStoredProcedureParameter(2, Long.class, ParameterMode.OUT);
query.setParameter(1, ITEM_ID);  Связывание значений параметров
List<Item> result = query.getResultList();  Получение результатов
for (Item item : result) {
// ...
}
Long totalNumberOfItems = (Long) query.getOutputParameterValue(2);
 Описание параметров и их типов с их порядковыми номерами (начиная с 1).
 Фактические значения связываются с входными параметрами.
 Извлекается результат запроса, возвращаемый хранимой процедурой.
 После извлечения результата можно прочитать значения выходных параметров.
Также можно описывать и использовать именованные параметры, но позицион-
ные и именованные параметры нельзя смешивать в одном вызове. Обратите еще
внимание, что имена параметров в коде Java не обязательно должны совпадать
с именами параметров хранимой процедуры. Проще говоря, вы должны описать
параметры в том же порядке, как и в определении хранимой процедуры.
Особенности Hibernate
Оригинальный интерфейс Hibernate упрощает описание и использование пара-
метров:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
org.hibernate.procedure.ProcedureCall call =
session.createStoredProcedureCall("FIND_ITEM_TOTAL", Item.class);
call.registerParameter(1, Long.class, ParameterMode.IN)  Описание параметров
.bindValue(ITEM_ID);
ParameterRegistration<Long> totalParameter =  Получение объекта описания параметра
call.registerParameter(2, Long.class, ParameterMode.OUT);
org.hibernate.procedure.ProcedureOutputs callOutputs = call.getOutputs();
org.hibernate.result.Output output;  Обработка результатов запроса
while ((output = callOutputs.getCurrent()) != null) {
if (output.isResultSet()) {
org.hibernate.result.ResultSetOutput resultSetOutput =
(org.hibernate.result.ResultSetOutput) output;
List<Item> result = resultSetOutput.getResultList();
for (Item item : result) {
// ...
}
 Описание параметров
 Получение значений
выходных параметров
Вызов хранимых процедур  523
}
if (!callOutputs.goToNext())
break;
}
Long totalNumberOfItems =
callOutputs.getOutputParameterValue(totalParameter);
 Описание всех параметров; можно сразу же выполнить связывание значений.
 Описание выходных параметров можно повторно использовать при получении их зна-
чений.
 Перед получением значений выходных параметров нужно обработать все возвращаемые
результаты.
 Получение значения выходного параметра с использованием его описания.
Следующая процедура MySQL использует входные параметры для изменения
названия товара в записи, в таблице ITEM:
Файл: /model/src/main/resources/querying/StoredProcedures.hbm.xml
create procedure UPDATE_ITEM(in PARAM_ITEM_ID bigint,
in PARAM_NAME varchar(255))
begin
update ITEM set NAME = PARAM_NAME where ID = PARAM_ITEM_ID;
end
Эта процедура не возвращает результатов запроса – только счетчик изменений,
поэтому вызвать ее довольно просто:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
StoredProcedureQuery query = em.createStoredProcedureQuery(
"UPDATE_ITEM"
);
query.registerStoredProcedureParameter("itemId", Long.class,
ParameterMode.IN);
query.registerStoredProcedureParameter("name", String.class,
ParameterMode.IN);
query.setParameter("itemId", ITEM_ID);
query.setParameter("name", "New Item Name");
assertEquals(query.executeUpdate(), 1); Счетчик изменений равен 1
// Альтернативный вариант:
// assertFalse(query.execute()); Первое возвращаемое значение– НЕ результат запроса
// assertEquals(query.getUpdateCount(), 1);
В этом примере также можно видеть, как работать с именованными параметра-
ми и что имена в коде Java не обязаны совпадать с именами из объявления хра-
нимой процедуры. Но порядок описания параметров по-прежнему важен: PARAM_
ITEM_ID должен следовать первым, PARAM_ITEM_NAME – вторым.
 Получение значений
выходых параметров
524  Настройка SQL-запросов
Особенности Hibernate
Если вызываемая процедура не возвращает результатов, а лишь изменяет данные,
ее вызов можно упростить, использовав метод executeUpdate(), который возвра-
щает только счетчик изменений. Также можно последовательно вызвать методы
execute() и getUpdateCount().
Ниже показан вызов той же процедуры с помощью Hibernate:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
org.hibernate.procedure.ProcedureCall call =
session.createStoredProcedureCall("UPDATE_ITEM");
call.registerParameter(1, Long.class, ParameterMode.IN)
.bindValue(ITEM_ID);
call.registerParameter(2, String.class, ParameterMode.IN)
.bindValue("New Item Name");
org.hibernate.result.UpdateCountOutput updateCountOutput =
(org.hibernate.result.UpdateCountOutput) call.getOutputs().getCurrent();
assertEquals(updateCountOutput.getUpdateCount(), 1);
Поскольку известно, что процедура не возвращает результатов, можно сразу
выполнить приведение первого (текущего) выходного значения к типу Update-
CountOutput.
Далее мы рассмотрим случай, когда вместо результата запроса процедура воз-
вращает ссылку на курсор.
17.4.4. Возвращение курсора
В MySQL хранимая процедура не может вернуть курсор. Следующий пример бу-
дет работать только с PostgreSQL. Следующая хранимая процедура (или поль-
зовательская функция, поскольку в PostgreSQL – это одно и то же) возвращает
курсор для обхода всех записей в таблице ITEM:
Файл: /model/src/main/resources/querying/StoredProcedures.hbm.xml
create function FIND_ITEMS() returns refcursor as $$
declare someCursor refcursor;
begin
open someCursor for select * from ITEM;
return someCursor;
end;
$$ language plpgsql;
В JPA курсоры описываются как параметры с помощью специального значения
ParameterMode.REF_CURSOR:
Вызов хранимых процедур  525
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
StoredProcedureQuery query = em.createStoredProcedureQuery(
"FIND_ITEMS",
Item.class
);
query.registerStoredProcedureParameter(
1,
void.class,
ParameterMode.REF_CURSOR
);
List<Item> result = query.getResultList();
for (Item item : result) {
// ...
}
Параметр имеет тип void, поскольку его единственная цель состоит в подготов-
ке вызова для дальнейшего чтения данных с помощью курсора. Когда будет вы-
зван метод getResultList(), Hibernate сможет вернуть необходимый результат.
Особенности Hibernate
Hibernate также поддерживает автоматическую работу с курсорами:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
CallStoredProcedures.java
org.hibernate.procedure.ProcedureCall call =
session.createStoredProcedureCall("FIND_ITEMS", Item.class);
call.registerParameter(1, void.class, ParameterMode.REF_CURSOR);
org.hibernate.result.ResultSetOutput resultSetOutput =
(org.hibernate.result.ResultSetOutput) call.getOutputs().getCurrent();
List<Item> result = resultSetOutput.getResultList();
for (Item item : result) {
// ...
}
Обход результатов запроса с помощью курсора
В разделе 14.3.3 мы обсуждали использование курсоров базы данных для обхода
потенциально объемных результатов запроса. К сожалению, на момент создания
этой книги данная функциональность не поддерживалась ни в JPA, ни в Hibernate.
Hibernate будет всегда извлекать в память целиком все результаты запроса, на ко-
торые ссылается курсор.
526  Настройка SQL-запросов
Поддерживать работу с курсорами в различных диалектах СУБД довольно
сложно, поэтому Hibernate имеет некоторые ограничения. Например, в PostgreSQL
параметр, указывающий на курсор, всегда должен объявляться первым,
и (поскольку речь идет о функции) получить из базы данных можно только один
курсор. При работе с курсорами в диалекте PostgreSQL Hibernate не поддержи-
вает именованных параметров: вместо них следует использовать позиционные.
За более подробной информацией обращайтесь к описанию SQL-диалекта своей
базы данных в Hibernate: обратите внимание на такие методы, как Dialect#getResultSet(
CallableStatement) и т. д.
На этом мы заканчиваем рассмотрение API для вызова хранимых процедур.
Далее мы воспользуемся хранимыми процедурами для переопределения сгенери-
рованных выражений, которые Hibernate выполняет для загрузки и сохранения
данных.
Особенности Hibernate
17.5. Применение хранимых процедур
для операций CRUD
Первой операцией CRUD, которую мы настроим, будет загрузка экземпляров
сущностей класса User. Ранее в этой главе вы использовали для этого обычный
запрос SQL и загрузчик. Если для загрузки экземпляра User требуется вызвать
хранимую процедуру, сделать это так же просто.
17.5.1. Загрузчик, вызывающий процедуру
Прежде всего нужно создать именованный запрос, вызывающий хранимую про-
цедуру, например с помощью аннотации перед классом User:
Файл: /model/src/main/java/org/jpwh/model/customsql/procedures/User.java
@NamedNativeQueries({
@NamedNativeQuery(
name = "findUserById",
query = "{call FIND_USER_BY_ID(?)}",
resultClass = User.class
)
})
@org.hibernate.annotations.Loader(
namedQuery = "findUserById"
)
@Entity
@Table(name = "USERS")
public class User {
// ...
}
Применение хранимых процедур для операций CRUD  527
Сравните его с предыдущей версией в разделе 17.3.1: объявление загрузчика
осталось прежним, и ему нужен лишь именованный запрос на любом поддержи-
ваемом языке. Изменился только сам запрос, который также можно поместить
в XML-файл метаданных для еще большего разделения функциональности.
JPA не накладывает ограничений на содержимое аннотации @NamedNativeQuery:
вы можете написать любое выражение SQL. Используя синтаксис экранирования
JDBC с фигурными скобками, вы как бы говорите: «Пусть драйвер JDBC сам ре-
шает, что с этим делать». Если ваш драйвер JDBC и СУБД умеют работать с хра-
нимыми процедурами, процедуру можно вызвать с помощью конструкции {call
PROCEDURE}. Hibernate ожидает, что процедура вернет результат запроса, а первая
запись в нем будет содержать все столбцы, необходимые для создания экземпляра
User. Все эти столбцы и свойства были перечислены в разделе 17.3.1. Не забывай-
те, что всегда можно использовать собственное отображение результатов запроса,
если столбцы (их имена), возвращаемые процедурой, не вполне вас устраивают,
или когда невозможно изменить код процедуры.
Хранимая процедура должна иметь сигнатуру, позволяющую сделать вызов
с единственным аргументом. Hibernate будет использовать этот аргумент как
идентификатор при загрузке экземпляра User. Ниже показана хранимая процеду-
ра в MySQL, обладающая такой сигнатурой:
Файл: /model/src/main/resources/customsql/CRUDProcedures.hbm.xml
create procedure FIND_USER_BY_ID(in PARAM_USER_ID bigint)
begin
select * from USERS where ID = PARAM_USER_ID;
end
Далее мы воспользуемся хранимыми процедурами для создания, изменения
и удаления объекта User.
17.5.2. Использование процедур в операциях CUD
Для настройки запросов, которые Hibernate использует с целью создания, измене-
ния и удаления экземпляров сущности из базы данных, используются аннотации
@SQLInsert, @SQLUpdate, and @SQLDelete. Вместо обычных выражений SQL для этих
операций также можно вызывать хранимые процедуры:
Файл: /model/src/main/java/org/jpwh/model/customsql/procedures/User.java
@org.hibernate.annotations.SQLInsert(
sql = "{call INSERT_USER(?, ?, ?)}",
callable = true
)
@org.hibernate.annotations.SQLUpdate(
sql = "{call UPDATE_USER(?, ?, ?)}",
callable = true,
check = ResultCheckStyle.NONE
528  Настройка SQL-запросов
)
@org.hibernate.annotations.SQLDelete(
sql = "{call DELETE_USER(?)}",
callable = true
)
@Entity
@Table(name = "USERS")
public class User {
// ...
}
Чтобы Hibernate использовал объект JDBC, представляющий вызов процедуры
– CallableStatement вместо PreparedStatement, – нужно указать параметр
callable=true.
Как объяснялось в разделе 17.3.2, для связывания аргументов в вызове процеду-
ры можно использовать только позиционные параметры, и объявлены они должны
быть в том порядке, в каком Hibernate ожидает их увидеть. Хранимые процедуры
должны иметь соответствующую сигнатуру. Ниже показано несколько процедур
MySQL, которые вставляют, изменяют и удаляют записи из таблицы USERS:
Файл: /model/src/main/resources/customsql/CRUDProcedures.hbm.xml
create procedure INSERT_USER(in PARAM_ACTIVATED bit,
in PARAM_USERNAME varchar(255),
in PARAM_ID bigint)
begin
insert into USERS (ACTIVATED, USERNAME, ID)
values (PARAM_ACTIVATED, PARAM_USERNAME, PARAM_ID);
end
Файл: /model/src/main/resources/customsql/CRUDProcedures.hbm.xml
create procedure UPDATE_USER(in PARAM_ACTIVATED bit,
in PARAM_USERNAME varchar(255),
in PARAM_ID bigint)
begin
update USERS set
ACTIVATED = PARAM_ACTIVATED,
USERNAME = PARAM_USERNAME
where ID = PARAM_ID;
end
Файл: /model/src/main/resources/customsql/CRUDProcedures.hbm.xml
create procedure DELETE_USER(in PARAM_ID bigint)
begin
delete from USERS where ID = PARAM_ID;
end
После того как хранимая процедура вставит, удалит или изменит экземпляр
User, Hibernate должен узнать результат ее выполнения. В динамически генери-
Резюме  529
руемых SQL-запросах Hibernate проверяет количество измененных строк после
операции. Если включено версионирование (см. раздел 11.2.2) и выполняемая
операция не смогла обновить ни одной записи, произойдет отказ оптимистиче-
ской блокировки. Вызывая собственный код SQL, можно это поведение настро-
ить. Хранимая процедура будет сама решать, требуется ли сравнивать текущую
версию с версией из базы данных для операций изменения или удаления. Исполь-
зуя параметр аннотации check, вы сообщаете Hibernate, как процедура должна реализовать
это требование.
По умолчанию используется значение ResultCheckStyle.NONE, но также доступ-
ны следующие варианты:
 NONE – процедура возбудит исключение, если операция завершится неуда-
чей. Hibernate не будет выполнять никаких проверок и полностью положит-
ся в этом на процедуру. Если включено версионирование, ваша процедура
должна сравнить/увеличить номер версии, а при обнаружении отличий –
возбудить исключение;
 COUNT – процедура увеличит номер версии, проверит и вернет число изме-
ненных записей. Для получения счетчика изменений Hibernate вызовет Cal
lableStatement#getUpdateCount();
 PARAM – процедура выполнит увеличение номера версии и проверку, а за-
тем вернет количество измененных записей в первом выходном параметре.
В этом случае нужно добавить дополнительный знак вопроса в сигнатуру
хранимой процедуры и возвращать число изменившихся записей в этом
(первом) выходном параметре. Hibernate автоматически зарегистрирует
этот параметр и прочитает его значение после вызова процедуры.
Поддержка параметров ResultCheckStyle
На момент написания книги Hibernate поддерживал только параметр ResultCheck-
Style.NONE.
И наконец, не забывайте, что Hibernate не всегда может взаимодействовать
с хранимыми процедурами и функциями. В таких случаях следует использовать
обычный JDBC. Иногда вызов унаследованной хранимой процедуры можно обер-
нуть вызовом новой хранимой процедуры, интерфейс которой будет соответство-
вать требованиям Hibernate.
17.6. Резюме
 Вы узнали, как можно использовать знакомый JDBC API. Даже при исполь-
зовании произвольных SQL-запросов Hibernate может взять всю тяжелую ра-
боту на себя и преобразовать коллекцию результатов ResultSet в экземпляры
классов модели предметной области, предоставляя гибкие настройки, вклю-
чая возможность применения собственного отображения результатов запроса.
Для упрощения настроек запросы можно определять во внешних файлах.
530  Настройка SQL-запросов
 Мы рассмотрели возможности переопределения SQL-выражений для стан-
дартных операций создания, чтения, изменения и удаления (CRUD), а также
для операций над коллекциями.
 Вы можете определять собственные загрузчики и использовать в них немед-
ленное извлечение.
 Вы узнали, как вызывать процедуры, хранимые в базе данных, и интегрировать
их с Hibernate. Вы узнали, как обрабатывать один или несколько результатов
запроса, а также счетчик изменений. Вы узнали, как передаются параметры
в хранимые процедуры (входные и выходные) и как они возвращают курсоры
базы данных. Также вы узнали, как можно использовать хранимые процедуры
для операций CRUD.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
ADDRESS
ID << PK >> << FK >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
ID << PK >>
CC_OWNER
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table CREDITCARD
owner : String
BillingDetails
id : Long
cardNumber : String
expMonth : String
expYear : String
CreditCard
id : Long
account : String
bankname : String
swift : String
BankAccount
Часть V
СОЗДАНИЕ
ПРИЛОЖЕНИЙ
В пятой и последней части в этой книге мы обсудим проектирование и реализа-
цию многоуровневых Java-приложений баз данных, поддерживающих диалоговые
взаимодействия. Обсудим наиболее распространенные шаблоны проектирования,
используемые с Hibernate, такие как объект доступа к данным (Data Access Object,
DAO). Вы увидите, как можно легко протестировать приложение, использующее
Hibernate, и какие примы лучше использовать при работе с программным обеспе-
чением для объектно-реляционного отображения (ORM) в веб-приложениях или
клиент-серверных приложениях в целом.
Глава 18 целиком посвящена созданию клиент-серверных приложений. Вы по-
знакомитесь с шаблонами клиент-серверной архитектуры, создадите и протести-
руете уровень хранения, а затем интегрируете экземпляры EJB с JPA. В главе 19 вы
изучите создание веб-приложений и способы интеграции JPA с CDI и JSF. Научи-
тесь просматривать данные в таблицах, осуществлять продолжительные диалого-
вые взаимодействия и настраивать сериализацию сущностей. Наконец, в главе 20
мы покажем возможности масштабирования Hibernate с применением массовых
операций и разделяемого кэша.
После прочтения этой части вы получите все необходимые знания по архитек-
туре, которые позволят вам не только создавать приложения, но и успешно их мас-
штабировать.
Глава 18
Проектирование
клиент-серверных
приложений
В этой главе:
 шаблоны клиент-серверной архитектуры;
 создание и тестирование уровня хранения;
 интеграция EJB и JPA.
Большинство разработчиков JPA-приложений создает клиент-серверные прило-
жения, основанные на сервере приложений Java с уровнем доступа к базе данных,
использующим Hibernate. Зная особенности работы объекта EntityManager и си-
стемных транзакций, вы наверняка сможете разработать собственную серверную
архитектуру. Вы должны будете решить, когда инициализировать объекты Entity-
Manager, когда их уничтожать и как определять границы транзакций.
Вас, наверное, интересует, как соотносятся запросы и ответы клиента и сервера
с контекстом хранения и транзакциями, протекающими внутри сервера. Должен
ли каждый запрос обрабатываться отдельной системной транзакцией? Могут ли
несколько последовательных запросов оставлять контекст хранения открытым?
Какая роль отводится отсоединенному состоянию сущности? Нужно ли выпол-
нять сериализацию сущности при передаче между клиентом и сервером? Как все
эти решения повлияют на проектирование клиента?
Прежде чем ответить на все эти вопросы, мы хотели бы отметить, что в данной
главе не будет говориться о других фреймворках приложений, кроме JPA и EJB.
Существует несколько причин, из-за которых мы будем использовать JPA вместе
EJB во всех примерах:
 наша цель – сосредоточиться на шаблонах проектирования клиент-сервер-
ной архитектуры с использованием JPA. Большая часть сквозной функциональности
(cross-cutting concerns), такой как сериализация данных при
передаче между клиентом и сервером, стандартизована в EJB, поэтому нам
Разработка уровня хранения  533
не придется сразу же заниматься решением этой задачи. Мы понимаем, что,
скорее всего, вы не станете создавать клиентского приложения с примене-
нием EJB. Но благодаря клиентскому коду из этой главы, работающему
с EJB, у вас будет основа для принятия решений при выборе и применении
другого фреймворка. В следующей главе мы рассмотрим настройку сериа-
лизации и покажем, как обмениваться данными в JPA-приложениях с лю-
быми клиентами;
 невозможно охватить все комбинации фреймворков клиентов и серверов из
мира Java. Обратите внимание, что мы не ограничились одними веб-приложениями.
Конечно, веб-приложения играют важную роль, поэтому мы
посвятим следующую главу взаимодействию JPA с JSF и JAX-RS. В этой
главе мы рассмотрим клиент-серверное взаимодействие с применением
JPA, а также такие абстракции, как объект доступа к данным (Data Access
Object, DAO), которые будут вам полезны независимо от используемого
фреймворка;
 технология EJB очень эффективна, даже при использовании только на сто-
роне сервера. Она позволяет управлять транзакциями и привязывать кон-
текст хранения к сеансовым компонентам с сохранением состояния (stateful
session beans). Мы обсудим и эти подробности, так что, если архитектура
вашего приложения будет вызывать компоненты EJB на стороне сервера,
вы сможете их создать.
В течение этой главы мы реализуем два сценария использования с простой по-
следовательностью действий: редактирование информации о товаре и размеще-
ние ставок за товар. Давайте сначала разберемся с уровнем хранения, заключив
все операции JPA в один компонент с возможностью его повторного использова-
ния: в частности, используя шаблон объекта доступа к данным. В результате мы
получим прочный фундамент для разработки оставшейся части приложения.
Затем мы реализуем сценарии использования в виде диалоговых взаимодей-
ствий, представляющих для пользователей приложения законченные единицы
работы. Вы увидите код серверных компонентов с поддержкой состояния (stateful)
и без поддержки состояния (stateless), а также поймете, как их применение
влияет на проектирование клиентского кода и архитектуру приложения в целом.
Выбор компонентов влияет не только на поведение приложения, но и на масшта-
бируемость и устойчивость. Мы реализуем каждый пример с обеими стратегиями,
чтобы показать различия между ними.
Итак, приступим к реализации уровня хранения с применением шаблона DAO.
18.1. Разработка уровня хранения
В разделе 3.1.1 мы рассмотрели прием организации отдельного слоя кода, обеспе-
чивающего хранение данных в СУБД. Несмотря на то что JPA поддерживает не-
который уровень абстракции, существует ряд причин, по которым стоит скрывать
вызовы JPA за отдельным фасадом:
534  Проектирование клиент-серверных приложений
 собственный уровень хранения может дать более высокий уровень абстрак-
ции для операций доступа к данным. Вместо обычных операций CRUD
и запросов, выполняемых с помощью объекта EntityManager, можно реали-
зовать более высокоуровневые операции, такие как getMaximumBid(Item i)
(получение самой большой ставки) и findItems(User soldBy) (получение всех
товаров пользователя). Эта абстракция является главной причиной созда-
ния уровня хранения в больших приложениях – она поддерживает повтор-
ное использование операций доступа к данным;
 уровень хранения может обладать обобщенным интерфейсом, не раскры-
вающим подробностей реализации. Другими словами, вы можете скрыть
от клиента уровня хранения факт использования Hibernate (или Java Persistence)
для доступа к данным. Но мы считаем, что переносимость уров-
ня хранения не является важной характеристикой, поскольку механизмы
полного объектно-реляционного отображения, такие как Hibernate, редко
обеспечивают переносимость между базами данных. Маловероятно, что-
бы вы в будущем захотели переписать ваш уровень хранения, используя
другое программное обеспечение, не изменяя при этом клиентского кода.
Более того, программный интерфейс Java Persistence является стандарт-
ным и полностью переносимым API; ничего страшного, если вы случайно
откроете
его для клиентов вашего уровня хранения.
Уровень хранения может объединить операции доступа к данным. Эта функциональность
связана с переносимостью, но в несколько ином ключе. Представьте,
что вам приходится иметь дело с кодом доступа к данным, в котором перемешаны
вызовы JPA и JDBC. Создав единый фасад, которым смогут пользоваться клиен-
ты, вы тем самым скроете детали реализации от клиентов. Если вам приходится
работать с разными хранилищами данных, это уже хороший повод для создания
собственного уровня хранения.
Если вы рассматриваете переносимость и наличие единого интерфейса как
побочный эффект создания уровня хранения, вашей главной мотивацией будут
предоставление более высокого уровня абстракции и облегчение поддержки и по-
вторного использования кода доступа к данным. Все это достойные причины,
поэтому мы рекомендуем создавать уровень хранения с обобщенным фасадом
во всех приложениях, кроме самых простых. Но всегда сначала рассматривайте
возможность использования JPA без дополнительных уровней. Старайтесь, чтобы
код был как можно более простым, добавляя тонкий уровень хранения поверх JPA,
только если понимаете, что дублируете некоторые запросы и операции.
Существует множество инструментов, заявляющих, что могут упростить раз-
работку уровня хранения с JPA и Hibernate. Мы советуем сначала работать без по-
добных инструментов, применяя их, только когда требуется определенная функ-
циональность. Особенно осторожно обращайтесь с генераторами кода и запросов:
то, что часто позиционируется как единое решение всех проблем, в долгосрочной
перспективе приводит к значительным ограничениям и проблемам сопровожде-
ния. Это также может сильно сказаться на продуктивности, если процесс разра-
Обобщенный шаблон «объект доступа к данным»  535
ботки будет зависеть от работы инструментов генерирования кода. Это касается
и собственного инструментария Hibernate – например, если генерировать исход-
ный код класса сущности на основе схемы SQL при каждом внесении изменений.
Уровень хранения является важной частью приложения, и, внося дополнительные
зависимости, вы должны осознавать последствия. В этой и следующей главах вы
увидите, как избежать повторения кода, связанного с компонентами уровня хра-
нения, без использования дополнительных инструментов.
Фасад уровня хранения можно спроектировать несколькими способами – в не-
которых маленьких приложениях есть лишь единственный класс для доступа
к данным, DataAccess; в других операции доступа к данным распределены по клас-
сам предметной области, как в шаблоне «активная запись» (Active Record), кото-
рый не приводится в книге, но мы предпочитаем шаблон DAO.
18.1.1. Обобщенный шаблон «объект доступа
к данным»
Шаблон DAO зародился в проекте Java Blueprints компании Sun более 15 лет на-
зад и имеет длинную историю. Класс DAO определяет интерфейс для выполнения
операций с конкретной сущностью; согласно этому шаблону весь код, касающий-
ся одной хранимой сущности, должен размещаться в одном месте. Благодаря со-
лидному возрасту накопилось множество вариантов шаблона DAO. Базовая реко-
мендуемая структура показана на рис. 18.1.
getCount() : Long
makePersistent(T entity) : T
makeTransient(T entity)
checkVersion(T entity, boolean forceUpdate);
GenericDAO<T, ID>
ItemDAO<Item, Long>
BidDAO<Bid, Long>
GenericDAOImpl
ItemDAOImpl
BidDAOImpl
findAll() : List<T>
findReferenceById(ID id) : T
findById(ID id, LockModeType lock) : T
findById(ID id) : T
findAll(boolean withBids) : List<Item>
findByName(String n, boolean substring) : List<Item>
findItemBidSummaries() : List<ItemBidSummary>
Рис. 18.1  Обобщенные интерфейсы DAO
поддерживают различные реализации
Мы спроектировали уровень хранения с двумя параллельными иерархиями:
с одной стороны, интерфейсы, а с другой – их реализации. Базовые операции
536  Проектирование клиент-серверных приложений
сохранения и извлечения объединены в суперинтерфейсе общего назначения
и суперклассе, реализующем эти операции, используя конкретное решение (ко-
нечно же Hibernate). Интерфейс общего назначения расширяется реализациями
для конкретных сущностей, которые требуют дополнительных операций доступа
к данным, связанным с бизнес-логикой. Также может иметься несколько реализа-
ций интерфейса DAO для одной сущности.
Давайте взглянем на некоторые интерфейсы и методы, показанные на рис. 18.1.
Можно заметить целый набор методов поиска с префиксом find. Они, как прави-
ло, возвращают управляемые сущности (находящиеся в хранимом состоянии),
но также могут возвращать произвольные объекты передачи данных, такие как
ItemBidSummary. Методы поиска создают самую большую проблему дублирова-
ния кода; если не проявить осторожности, в программе могут появиться десятки
похожих методов. В качестве первого шага следует сделать методы поиска как
можно более обобщенными, поместив их в самом верху иерархии (в идеале –
в корневом интерфейсе). Возьмем для примера метод findByName() в интерфейсе
ItemDAO: возможно, скоро вам понадобится добавить в него больше параметров
поиска, либо сортировать результаты на уровне базы данных, либо реализовать
некое подобие постраничной выборки. Мы вернемся к этому позже в разделе
19.2 и покажем, как разработать общее решение для упорядочения и постранич-
ной выборки.
Методы в DAO API ясно указывают, что относятся к уровню хранения, управ-
ляющему состоянием сущностей. Такие методы, как makePersistent() и makeTransient(),
изменяют состояние экземпляра сущности (или сразу нескольких
сущностей, при использовании каскадной передачи состояния). Клиент вправе
ожидать, что изменения будут выполняться механизмом хранения автоматиче-
ски при изменении состояния сущности (поэтому метод performUpdate() отсут-
ствует). Если бы интерфейс DAO полагался на SQL-выражения, он бы выглядел
совершенно иначе – например, если бы вместо Hibernate использовался обычный
JDBC.
Фасад уровня хранения, который мы вам покажем, не открывает клиентам до-
ступа к интерфейсам Hibernate или Java Persistence, поэтому гипотетически мож-
но реализовать его, используя любое программное обеспечение, не оказывая влияния
на клиентский код. Возможно, переносимость уровня хранения, о котором мы
говорили ранее, для вас не очень важна. В таком случае можно открыть доступ
к интерфейсам Hibernate и Java Persistence – например, можно предоставить кли-
ентам доступ к JPA-интерфейсу CriteriaBuilder и благодаря этому создать метод
общего назначения findBy(CriteriaQuery). Выбор остается за вами; возможно, вы
решите, что открыть доступ к интерфейсам Java Persistence безопаснее, чем к ин-
терфейсам Hibernate. Но не стоит забывать, что если еще существует возможность
изменения реализации уровня хранения, в зависимости от реализации JPA, то из-
менить уровень хранения, ориентированный на чистый JDBC, практически не-
возможно.
Далее мы должны реализовать интерфейсы DAO.
Обобщенный шаблон «объект доступа к данным»  537
18.1.2. Реализация обобщенных интерфейсов
Рассмотрим возможную реализацию интерфейса GenericDAO:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/GenericDAOImpl.java
public abstract class GenericDAOImpl<T, ID extends Serializable>
implements GenericDAO<T, ID> {
@PersistenceContext
protected EntityManager em;
protected final Class<T> entityClass;
protected GenericDAOImpl(Class<T> entityClass) {
this.entityClass = entityClass;
}
public void setEntityManager(EntityManager em) {
this.em = em;
}
// ...
}
Для работы обобщенной реализации нужны лишь объект EntityManager и класс
сущности. Подклассы должны передавать класс сущности через аргумент кон-
структора. Объект EntityManager, напротив, должен предоставляться контейнером
среды выполнения, который понимает аннотацию внедрения зависимостей @PersistenceContext
(например, стандартным контейнером Java EE), или устанавли-
ваться методом setEntityManager().
Далее рассмотрим реализацию методов поиска:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/GenericDAOImpl.java
public abstract class GenericDAOImpl<T, ID extends Serializable>
implements GenericDAO<T, ID> {
// ...
public T findById(ID id) {
return findById(id, LockModeType.NONE);
}
public T findById(ID id, LockModeType lockModeType) {
return em.find(entityClass, id, lockModeType);
}
public T findReferenceById(ID id) {
return em.getReference(entityClass, id);
}
public List<T> findAll() {
CriteriaQuery<T> c =
em.getCriteriaBuilder().createQuery(entityClass);
538  Проектирование клиент-серверных приложений
c.select(c.from(entityClass));
return em.createQuery(c).getResultList();
}
public Long getCount() {
CriteriaQuery<Long> c =
em.getCriteriaBuilder().createQuery(Long.class);
c.select(em.getCriteriaBuilder().count(c.from(entityClass)));
return em.createQuery(c).getSingleResult();
}
// ...
}
В коде ясно видно, как класс сущности используется в запросах. Здесь приведе-
ны простые запросы на основе критериев, но вы также можете использовать JPQL
или SQL.
Наконец, рассмотрим операции для управления состоянием:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/GenericDAOImpl.java
public abstract class GenericDAOImpl<T, ID extends Serializable>
implements GenericDAO<T, ID> {
// ...
public T makePersistent(T instance) {
// merge() handles transient AND detached instances
return em.merge(instance);
}
public void makeTransient(T instance) {
em.remove(instance);
}
public void checkVersion(T entity, boolean forceUpdate) {
em.lock(
entity,
forceUpdate
? LockModeType.OPTIMISTIC_FORCE_INCREMENT
: LockModeType.OPTIMISTIC
);
}
}
Крайне важно, как реализуется метод makePersistent(). Здесь мы решили при-
менить метод EntityManager#merge() из-за его универсальности. Если передать ему
временный экземпляр сущности, он вернет хранимый экземпляр. При передаче
отсоединенного экземпляра сущности сначала будет выполнено слияние, а затем
так же возвращен хранимый экземпляр. Это дает клиентам возможность исполь-
зовать согласованный API, не заботясь о состоянии экземпляра сущности перед
вызовом makePersistent(). Но при этом клиент должен знать, что объект, возвра-
Обобщенный шаблон «объект доступа к данным»  539
щаемый методом makePersistent(), всегда является текущим экземпляром и что
аргумент больше не актуален (см. раздел 10.3.4).
На этом завершается создание базового механизма уровня хранения и обобщен-
ного интерфейса, который он предоставляет вышележащим уровням системы. На
следующем шаге нужно создать DAO-интерфейсы для каждой сущности, а также
их реализацию, путем наследования базового интерфейса и его реализации.
18.1.3. Реализация интерфейсов DAO
Все созданное до сих пор представляет собой абстрактные и обобщенные типы –
вы даже не можете создать экземпляра GenericDAOImpl. Пришла пора реализовать
интерфейс ItemDAO путем наследования GenericDAOImpl от конкретного класса.
Сначала решим, как клиенты будут вызывать наши интерфейсы DAO. Также не-
обходимо принять во внимание жизненный цикл экземпляра DAO. В данном про-
екте классы DAO не обладают никаким состоянием, кроме объекта EntityManager.
Вызывающие потоки могут совместно использовать один экземпляр DAO.
В многопоточном окружении Java EE, к примеру, автоматически внедряемый
объект EntityManager фактически является потокобезопасным, поскольку внутри
он реализован как прокси-объект, использующий контекст хранения, связанный
с потоком или транзакцией. Конечно, если вызвать метод setEntityManager() ин-
терфейса DAO, такой экземпляр уже нельзя будет совместно использовать в не-
скольких потоках, а только в одном (например, при интеграционном/модульном
тестировании).
Хорошим решением будет использование пула сеансовых компонентов EJB без
сохранения состояния; если отметить реализацию ItemDAOImpl как компонент EJB
без состояния, в него можно внедрить потокобезопасный контекст хранения:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/ItemDAOImpl.java
@Stateless
public class ItemDAOImpl extends GenericDAOImpl<Item, Long>
implements ItemDAO {
public ItemDAOImpl() {
super(Item.class);
}
// ...
}
Совсем скоро вы узнаете, как контейнер EJB выбирает «правильный» контекст
хранения для внедрения.
Потокобезопасность внедряемого экземпляра EntityManager
В спецификации Java EE потокобезопасноть экземпляра EntityManager, внедряемо-
го с помощью аннотации @PersistenceContext, четко не определяется. Спецификация
JPA говорит, что обращаться к экземпляру EntityManager можно «только из одного
потока». Отсюда следует, что один экземпляр не может внедряться в компоненты,
540  Проектирование клиент-серверных приложений
работающие в многопоточной среде, такие как EJB, объекты-одиночки и сервлеты
(servlets), поскольку они не работают в однопоточной модели SingleThreadModel. Но
зато в спецификации EJB говорится, что контейнер EJB должен вызывать каждый
сеансовый компонент (с состоянием или без) последовательно. Поэтому каждый
экземпляр EntityManager, внедряемый в EJB-компонент с состоянием или без, яв-
ляется потокобезопасным; контейнер реализует это поведение за счет внедрения
заглушек вместо объектов EntityManager. Помимо этого, ваш сервер приложений
может (но не обязан) поддерживать потокобезопасность доступа к экземпляру
EntityManager, внедренному в объект-одиночку или многопоточный сервлет. Если
у вас остались сомнения, можете внедрить потокобезопасный экземпляр Entity-
ManagerFactory, а затем создать собственные экземпляры EntityManager в методах
служб.
Ниже показаны методы поиска, определенные в интерфейсе ItemDAO:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/ItemDAOImpl.java
@Stateless
public class ItemDAOImpl extends GenericDAOImpl<Item, Long>
implements ItemDAO {
// ...
@Override
public List<Item> findAll(boolean withBids) {
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Item> criteria = cb.createQuery(Item.class);
// ...
return em.createQuery(criteria).getResultList();
}
@Override
public List<Item> findByName(String name, boolean substring) {
// ...
}
@Override
public List<ItemBidSummary> findItemBidSummaries() {
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<ItemBidSummary> criteria =
cb.createQuery(ItemBidSummary.class);
// ...
return em.createQuery(criteria).getResultList();
}
}
После прочтения предыдущих глав у вас не должно было возникнуть проблем
с этими запросами, поскольку они довольно простые: воспользуйтесь API запро-
сов на основе критериев или выполняйте именованные JPQL-запросы из внешних
файлов. Для работы с запросами на основе критериев следует воспользоваться
Обобщенный шаблон «объект доступа к данным»  541
статической метамоделью, как было показано в разделе «Использование статиче-
ской метамодели» в главе 3.
После завершения реализации ItemDAO можно браться за BidDAO:
Файл: /apps/app-model/src/main/java/org/jpwh/dao/BidDAOImpl.java
@Stateless
public class BidDAOImpl extends GenericDAOImpl<Bid, Long>
implements BidDAO {
public BidDAOImpl() {
super(Bid.class);
}
}
Легко видеть, что это «пустая» реализация DAO, которая лишь наследует роди-
тельские методы. В следующем разделе мы рассмотрим некоторые операции, ко-
торые можно было бы поместить в этот класс DAO. Мы также не приводим здесь
кода классов UserDAO и CategoryDAO, поскольку надеемся, что вы сможете реализо-
вать эти интерфейсы самостоятельно.
Наша следующая тема – тестирование уровня хранения: нужно ли это делать,
и если да, то как?
18.1.4. Тестирование уровня хранения
Большая часть примеров в этой книге взята прямо из настоящего тестового кода.
Мы продолжим эту традицию в следующих примерах, но должны спросить вас:
должны ли вы писать тесты для уровня хранения, чтобы проверить его функцио-
нальность?
Исходя из нашего опыта, в тестировании уровня хранения обычно нет смысла.
Вы можете создавать экземпляры DAO-классов, внедряя в них фиктивный объект
EntityManager. Ценность такого модульного теста невелика, а его разработка тру-
доемка. Вместо этого мы советуем писать интеграционные тесты, проверяющие
работу большой части приложения с привлечением базы данных. Все оставшиеся
примеры в этой главе взяты из таких интеграционных тестов; они имитируют кли-
ента, вызывающего серверное приложение с настоящим кодом для работы с ба-
зой данных. Следовательно, сразу проверяется все, что важно: корректная работа
служб, бизнес-логика предметной модели, на которую они опираются, и обраще-
ние к базе данных через интерфейсы DAO.
Единственная проблема состоит в подготовке такого интеграционного теста.
Тестирование должно выполняться в реальном окружении Java EE с настоящим
контейнером среды выполнения. Для этих целей мы будем использовать Arquillian
(http://arquillian.org), инструмент, умеющий взаимодействовать с TestNG. С по-
мощью Arquillian можно создавать в тестовом коде виртуальные архивы и затем
запускать на настоящем сервере приложений. Посмотрите на примеры, чтобы по-
нять, как это работает.
Более интересной является задача подготовки данных для интеграционных
тестов. Для большей пользы необходимо, чтобы в базе данных была хоть какая-
542  Проектирование клиент-серверных приложений
нибудь информация. Нужно загрузить тестовые данные в базу перед началом вы-
полнения тестов, и каждый тест должен работать с правильными, четко опреде-
ленными данными, чтобы можно было писать надежные утверждения.
Опираясь на наш опыт, выделим три наиболее распространенных способа за-
грузки тестовых данных:
 инфраструктура тестирования вызывает некоторый метод перед каждым
тестом для получения EntityManager. Затем вручную инициализируются
тестовые
сущности и сохраняются в базу данных с помощью EntityManager.
Главное преимущество данной стратегии в том, что заодно проверяется
большое количество отображений. Другим преимуществом является простота
программного доступа к тестовым данным. Например, если понадобит-
ся значение идентификатора тестового экземпляра Item, его можно сразу
же получить из метода загрузки данных. Недостатком является сложность
поддержки тестовых данных, поскольку их не очень удобно хранить в коде
на Java. Очищать тестовые данные в базе можно, удаляя и заново создавая
схему после каждого теста, используя механизм Hiberbate для загрузки схе-
мы. До сих пор во всех интеграционных тестах применялся такой подход;
вы можете обнаружить процедуры для загрузки данных рядом с каждым
тестом в коде примеров;
 Arquillian может импортировать наборы данных с помощью DbUnit (http://
dbunit.sourceforge.net) перед запуском каждого теста. DbUnit поддержи-
вает несколько форматов описания наборов данных, в том числе и рас-
пространенный «плоский» XML-синтаксис. Это не очень компактно, зато
удобно для чтения и сопровождения. Примеры в данной главе использу-
ют этот подход. Перед тестовыми классами можно обнаружить Arquillian-
аннотацию @UsingDataSet, определяющую путь к XML-файлу для загрузки.
Hibernate будет генерировать и удалять схему SQL, а Arquillian с помощью
DbUnit – выполнять загрузку данных в базу. Если вы предпочитаете хра-
нить тестовые данные отдельно от кода, это решение может вам пригодить-
ся. Если вы не используете Arquillian, не составит труда выполнить загрузку
наборов данных вручную, с помощью DbUnit, – посмотрите код SampleDataImporter
в примерах к этой главе. Мы разворачиваем этот класс на сервере
при запуске тестового приложения во время разработки, чтобы у нас были
одни и те же данные, как для автоматических тестов, так и для интерактив-
ного взаимодействия;
 в разделе 9.1.1 вы видели, как выполнять собственные сценарии SQL при
запуске Hibernate. Сценарий загрузки выполняется каждый раз после того,
как Hibernate сгенерирует схему; это отличный инструмент для загрузки
тестовых данных с помощью обычных SQL-выражений INSERT. Этот подход
используется в примерах следующей главы. Главным преимуществом яв-
ляется возможность копировать выражения INSERT прямо из консоли SQL,
Создание сервера без состояния  543
вставляя их в код тестов, и наоборот. Кроме того, если ваша база данных
поддерживает синтаксис SQL для описания конструкторов значений, вы
сможете создавать компактные инструкции вставки из нескольких строк,
как, например, insert into MY_TABLE (MY_COLUMN) values (1), (2), (3), ....
Выбор стратегии остается за вами. Часто выбор зависит от личных предпочте-
ний и объема тестовых данных. Обратите внимание, что мы говорим о тестовых
данных для интеграционного тестирования, но не для нагрузочного или проверки
масштабирования. Если понадобятся большие объемы тестовых данных (в основ-
ном случайных), обратите внимание на такие генераторы данных, как Benerator
(http://databene.org/databene-benerator.html).
На этом первый этап разработки уровня хранения завершен. Теперь вы може-
те получать экземпляры ItemDAO и обращаться к базе данных на более высоком
уровне абстракции. Давайте напишем клиентский код, который будет обращаться
к уровню хранения, и реализуем оставшуюся часть приложения.
18.2. Создание сервера без состояния
В качестве приложения мы создадим сервер без состояния, т. е. сервер, не сохраняющий
никаких данных между несколькими запросами клиента. Приложение
будет простым – мы реализуем только два варианта использования: редактирова-
ние данных о товаре и размещение ставки.
Работа с системой будет протекать в диалоговом режиме: с точки зрения поль-
зователя это будет одна единица работы. Разработчики не обязательно рассматривают
систему так же, как пользователи; как правило, единицей работы для раз-
работчиков является системная транзакция. Сейчас мы подробно рассмотрим это
различие и то, как ожидания пользователя влияют на проектирование серверного
и клиентского приложений. Начнем с реализации первого диалогового взаимо-
действия – редактирования информации о товаре.
18.2.1. Редактирование информации о товаре
Роль клиента будет играть простейшее консольное EJB-приложение. На рис. 18.2
показано диалоговое взаимодействие «редактирование информации о товаре»,
как оно выглядит при работе с этим клиентским приложением.
Клиентское приложение выводит список товаров; пользователь выбирает один
из них. Затем клиентское приложение запрашивает у пользователя название опе-
рации, которую тот хотел бы выполнить. Наконец, после ввода названия операции
клиентское приложение выводит запрос на подтверждение. Теперь система готова
для следующего диалогового взамодействия. Клиентское приложение снова вы-
водит список товаров.
Последовательность вызовов в данном диалоговом взаимодействии показана
на рис. 18.3. Этот рисунок станет вашим путеводителем по текущему разделу.
544  Проектирование клиент-серверных приложений
Рис. 18.2  С точки зрения пользователя
данное диалоговое взаимодействие является единицей работы
Рис. 18.3  Вызовы во время диалогового взаимодействия
«редактирование информации о товаре»
Давайте внимательнее рассмотрим код; чтобы не сбиваться с нити повество-
вания, обращайте внимание на номера на рисунке. Код, показанный ниже, взят
из тестового примера, который имитирует клиентское приложение; далее будет
показан серверный код, обрабатывающий клиентские запросы.
Клиентское приложение получает список экземпляров Item от сервера, чтобы
начать диалоговое взаимодействие ; значение true в параметре обеспечивает не-
медленную загрузку коллекции Item#bids каждого экземпляра. Поскольку сервер
Создание сервера без состояния  545
не хранит промежуточного состояния диалога, эту работу должно взять на себя
клиентское приложение:
Файл: /apps/app-stateless-server/src/test/java/org/jpwh/test/stateless/
AuctionServiceTest.java
List<Item> items; Состоянием приложения – списком товаров – должен управлять клиент
items = service.getItems(true); Получить все товары в отсоединенном состоянии
вместе со ставками
Серверный код обработает запрос при помощи DAO:
Файл: /apps/app-stateless-server/src/main/java/org/jpwh/stateless/
AuctionServiceImpl.java
@javax.ejb.Stateless
@javax.ejb.Local(AuctionService.class)
@javax.ejb.Remote(RemoteAuctionService.class)
public class AuctionServiceImpl implements AuctionService {
@Inject
protected ItemDAO itemDAO;
@Inject
protected BidDAO bidDAO;
@Override
@TransactionAttribute(TransactionAttributeType.REQUIRED) Значение по умолчанию
public List<Item> getItems(boolean withBids) {
return itemDAO.findAll(withBids);
}
// ...
}
(Не обращйте внимания на объявленные здесь интерфейсы; они необходимы
для удаленных вызовов и локального тестирования компонентов EJB.) Посколь-
ку при вызове getItems() ни одна транзакция не активна, будет запущена новая
транзакция. При выходе из метода она подтверждается автоматически. Аннотация
@TransactionAttribute в данном случае не обязательна; по умолчанию методы ком-
понентов EJB должны вызываться в транзакции.
Чтобы получить коллекцию List экземпляров Item, метод getItems() компо-
нента EJB обращается к ItemDAO . Контейнер Java EE автоматически выполнит
поиск и внедрение экземпляра ItemDAO, при этом объект EntityManager уже бу-
дет внедрен
в DAO. Поскольку с текущей транзакцией еще не связан никакой
экземпляр EntityManager или контекст хранения, будет открыт и присоединен
к транзакции новый контекст хранения. Выталкивание контекста и его закры-
тие произойдут при подтверждении транзакции. Это удобная особенность ком-
понентов EJB без состояния: для работы с JPA в транзакции не требуется осо-
бых усилий.
546  Проектирование клиент-серверных приложений
Коллекция List отсоединенных экземпляров Item (после закрытия контекста
хранения) возвращается клиенту . Сейчас вы не должны беспокоиться о сериа-
лизации; пока объекты List и Item, а также все достижимые типы наследуют ин-
терфейс Serializable, контейнер EJB сам позаботится об этом.
Затем клиент меняет имя выбранного экземпляра Item и просит сервер сохра-
нить изменение, послав измененный и отсоединенный объект Item :
Файл: /apps/app-stateless-server/src/test/java/org/jpwh/test/stateless/
AuctionServiceTest.java
detachedItem.setName("Pretty Baseball Glove");
detachedItem = service.storeItem(detachedItem);
Сервер примет отсоединенный экземпляр Item и попросит ItemDAO сохранить
изменения , выполнив слияние:
Файл: /apps/app-stateless-server/src/main/java/org/jpwh/stateless/
AuctionServiceImpl.java
public class AuctionServiceImpl implements AuctionService {
// ...
@Override
public Item storeItem(Item item) {
return itemDAO.makePersistent(item);
}
// ...
}
Обновленное в результате слияния состояние вернется клиенту.
Диалоговое взаимодействие завершено, и клиент может проигнорировать об-
новленный экземпляр Item. Но клиентскому приложению также известно, что воз-
вращаемое значение находится в актуальном состоянии, а все сохраненные до это-
го состояния, такие как коллекция List экземпляров Item, являются устаревшими
и от них желательно избавиться. Следующее диалоговое взаимодействие должно
начаться с новым состоянием, учитывающим последний полученный экезмпляр
Item, а для этого следует получить свежий список.
Теперь вы знаете, как реализовать одно диалоговое взаимодействие – единицу
работы с точки зрения пользователя, – используя две системные транзакции на
стороне сервера. Поскольку вы загрузили данные в первой системной транзакции,
отложив запись изменений до второй транзакции, диалоговое взаимодействие по-
лучилось атомарным: изменения не сохранятся, пока последний этап не завершит-
ся успехом. Рассмотрим это подробнее на примере второго варианта использова-
ния – размещения ставки.
18.2.2. Размещение ставки
Диалоговое взаимодействие по размещению ставки в консольном приложении
показано на рис. 18.4. Клиентское приложение выводит список товаров и просит
Вызов службы и сохранение изменений.
Вернется текущий экземпляр Item
Создание сервера без состояния  547
пользователя выбрать один из них. Пользователь может сделать ставку и полу-
чить подтверждение, если ставка была успешно сохранена. Последовательность
вызовов и ключевые пункты в коде показаны на рис. 18.5.
Рис. 18.4  Пользователь делает ставку:
единица работы с его точки зрения
Рис. 18.5  Вызовы при диалоговом взаимодействии
по размещению ставки
И вновь мы пройдемся по коду тестов клиента и сервера. Сначала  клиент
получает список экземпляров Item и немедленно извлекает коллекции Item#bids.
Вы видели код этого этапа в предыдущем разделе.
548  Проектирование клиент-серверных приложений
Затем, после получения значения ставки от пользователя , клиент создает
новый экземпляр Bid, связывая временный экземпляр Bid с выбранным отсоеди-
ненным экземпляром Item. Клиент должен сохранить новый экземпляр Bid и от-
править его на сервер. Если неправильно документировать API службы, то клиент
может попытаться отправить ему отсоединенный экземпляр Item:
Файл: /apps/app-stateless-server/src/test/java/org/jpwh/test/stateless/
AuctionServiceTest.java
item.getBids().add(newBid);
item = service.storeItem(item);
В данном случае клиент предположил, что серверу известно о новом объекте
Bid в коллекции Item#bids и что он должен быть сохранен. Ваш сервер может под-
держивать подобную функциональность, возможно, за счет включения каскадно-
го слияния в аннотации @OneToMany перед этой коллекцией. В таком случае метод
storeItem() вашей службы будет работать как в предыдущем разделе, посылая
экземпляр Item интерфейсу ItemDAO для сохранения его и его транзитивных за-
висимостей.
Но наше приложение реализовано иначе: служба предоставляет дополни-
тельный метод placeBid(). Перед сохранением ставки в базу данных нужно сде-
лать дополнительную проверку – например, убедиться, что ее значение боль-
ше самой большой текущей ставки. Вам также потребуется увеличить номер
версии экземпляра Item, чтобы избежать добавления конкурирующих ставок.
Следовательно, каскадное поведение нужно документировать в связях сущно-
стей предметной модели: коллекция Item#bids не является транзитивной, и но-
вые экземпляры Bid должны сохраняться только с помощью метода placeBid()
службы.
Реализация серверного метода placeBid() выполняет проверку содержимого
и версии:
Файл: /apps/app-stateless-server/src/main/java/org/jpwh/stateless/
AuctionServiceImpl.java
public class AuctionServiceImpl implements AuctionService {
// ...
@Override
public Item placeBid(Bid bid) throws InvalidBidException {
bid = bidDAO.makePersistent(bid);
if (!bid.getItem().isValidBid(bid)) Проверка соответствия бизнес-правилам
throw new InvalidBidException("Bid amount too low!");
itemDAO.checkVersion(bid.getItem(), true);
return bid.getItem();
}
}
«Возможно, эта служба выполняет касакдное сохранение
Item#bids, согласно настройкам в аннотации @OneToMany?»
После этого ничего не происходит – ставка не сохранилась
Создание сервера без состояния  549
Здесь можно заметить две интересные особенности. Во-первых, транзакция ак-
тивна в течение всего вызова placeBid(). Метод вложенного компонента EJB вы-
зывает ItemDAO и BidDAO в той же транзакции. То же самое верно и в отношении кон-
текста хранения: его область действия совпадает с областью действия транзакции
. Оба класса DAO объявляют о необходимости внедрения текущего экземпляра
@PersistenceContext; контейнер среды выполнения предоставит нужный контекст
хранения, связанный с текущей транзакцией. Транзакция и создание контекста
хранения, а также их связывание с компонентами EJB без состояния реализуются
довольно прямолинейно – они всегда привязываются к вызову.
Во-вторых, бизнес-логика проверки нового экземпляра Bid находится в классах
предметной модели. Служба вызывает Item#isValid(Bid), передавая ответствен-
ность за проверку классу предметной модели Item. Вот как она реализована в клас-
се Item:
Файл: /apps/app-model/src/main/java/org/jpwh/model/Item.java
@Entity
public class Item implements Serializable {
// ...
public boolean isValidBid(Bid newBid) {
Bid highestBid = getHighestBid();
if (newBid == null)
return false;
if (newBid.getAmount().compareTo(new BigDecimal("0")) != 1)
return false;
if (highestBid == null)
return true;
if (newBid.getAmount().compareTo(highestBid.getAmount()) == 1)
return true;
return false;
}
public Bid getHighestBid() {
return getBids().size() > 0
? getBidsHighestFirst().get(0) : null;
}
public List<Bid> getBidsHighestFirst() {
List<Bid> list = new ArrayList<>(getBids());
Collections.sort(list);
return list;
}
// ...
}
Метод isValid() выполняет несколько проверок, чтобы выяснить, превосходит
ли значение текущего объекта Bid последнюю ставку. Если однажды понадобится
реализовать в аукционной системе стратегию «побеждает наименьшая ставка»,
550  Проектирование клиент-серверных приложений
вам достаточно будет поменять реализацию класса Item в предметной модели;
для служб и интерфейсов DAO, использующих класс, никакой разницы не будет.
(Очевидно, вам понадобится вывести другое сообщение для исключения Invalid-
BidException.)
Сомнения вызывает лишь эффективность метода getHighestBid(). Он загружа-
ет всю коллекцию bids в память, сортирует ее, а затем выбирает один экземпляр
Bid. Улучшенный вариант мог бы выглядеть так:
Файл: /apps/app-model/src/main/java/org/jpwh/model/Item.java
@Entity
public class Item implements Serializable {
// ...
public boolean isValidBid(Bid newBid,
Bid currentHighestBid,
Bid currentLowestBid) {
// ...
}
}
Служба (или, если угодно, контроллер) по-прежнему ничего не знает о бизнес-
логике; ей не нужно знать, должна ли новая ставка быть больше или меньше пре-
дыдущей. Реализация службы должна передать значения наибольшей и наимень-
шей ставок, currentHighestBid и currentLowestBid, при вызове Item#isValid(). Как
раз на это мы и намекали ранее, когда говорили, что может понадобиться добавить
операции в класс BidDAO. Чтобы получить эти ставки самым эффективным спосо-
бом, без загрузки всей коллекции в память и последующей сортировки, можно
использовать запросы.
Теперь приложение готово. Оно реализует два запланированных варианта ис-
пользования. Давайте сделаем шаг назад и проанализируем результаты.
18.2.3. Анализ приложения без состояния
Мы реализовали диалоговые взаимодействия, каждое из которых с точки зрения
пользователя представляет единицу работы. Пользователь ожидает выполнить
ряд шагов, изменения в которых будут временными лишь до тех пор, пока не про-
изойдет их подтверждение на этапе, завершающем диалоговое взаимодействие.
Обычно последний шаг – это завершающий запрос, посылаемый клиентом серве-
ру. Это очень похоже на описание транзакции, но вам, возможно, придется создать
несколько системных транзакций на сервере для завершения конкретного диало-
гового взаимодействия. Проблема заключается в том, как добиться атомарности
для нескольких запросов и системных транзакций.
Диалоговые взаимодействия могут иметь любую продолжительность и слож-
ность. В процессе диалогового взаимодействия отсоединенные данные могут быть
загружены более чем одним клиентским запросом. Поскольку отсоединенные сущ-
ности на стороне клиента находятся под вашим контролем, вы легко можете сде-
Создание сервера без состояния  551
лать диалоговое взаимодействие атомарным, если не будете выполнять слияния,
сохранения или удаления на сервере, пока не получите завершающего запроса. Вам
решать, как накапливать список изменений и где хранить отсоединенные данные,
пока пользователь принимает решение. Просто не вызывайте со стороны клиента
никаких служебных операций, сохраняющих изменения на сервере, пока не будете
уверены, что готовы «подтвердить» (commit) диалоговое взаимодействие.
Одним из важных вопросов, требующих внимания, является сравнение отсо-
единенных экземпляров: например, если понадобится загрузить несколько экзем-
пляров Item и поместить их во множество Set или использовать в качестве ключей
словаря Map. Поскольку экземпляры будут сравниваться вне области гарантиро-
ванной идентичности объектов – контекста хранения, – необходимо переопреде-
лить методы equals() и hashCode() класса сущности Item, как было показано в раз-
деле 10.3.1. В простейшем диалоговом взаимодействии, где использовался только
список отсоединенных экземпляров Item, это было не нужно. Мы не сравнивали
экземпляров во множестве Set, не использовали в качестве ключей в словаре Hash-
Map, не проверяли их явно на равенство.
Вы должны использовать версионирование сущности Item для работы в много-
пользовательском приложении, как объяснялось в разделе «Включаем версиони-
рование» в главе 11. При слиянии изменений в методе AuctionService#storeItem()
Hibernate автоматически увеличит версию экземпляра Item (только если экзем-
пляр Item был изменен). Следовательно, если несколько пользователей одновре-
менно изменят название товара Item, Hibernate возбудит исключение во время
подтверждения системной транзакции и выталкивания контекста хранения. При
выборе оптимистичной стратегии побеждает пользователь, который первым под-
твердит изменения, сделанные в ходе диалогового взаимодействия. Второй поль-
зователь должен увидеть обычное сообщение: «Извините, кто-то уже изменил эти
данные; пожалуйста, начните сначала».
Мы только что реализовали систему с толстым клиентом (rich client); толстый
клиент – это не просто терминал ввода/вывода, а приложение со своим внутрен-
ним состоянием, независимым от сервера (вспомните, что сервер не хранит ника-
кого состояния). Одним из преимуществ такого сервера без состояния является
возможность обработки запроса пользователя любым сервером. Если на сервере
произойдет сбой, можно перенаправить запрос на другой сервер, и диалоговое
взаимодействие
продолжится. У серверов в кластере нет ничего общего; вы можете
с легкостью масштабировать систему горизонтально, подключая больше серве-
ров. Очевидно, что все серверы приложений обращаются к общей базе данных, но
вам придется побеспокоиться о масштабировании только одного уровня серверов.
Сохранение изменений после выхода из состояния гонки
Во время приемочного тестирования может обнаружиться, что пользователям не
нравится начинать диалоговое взаимодействие заново, когда обнаруживается со-
стояние гонки (race condition). Они могут потребовать пессимистической блоки-
ровки: чтобы во время редактирования данных товара пользователем A пользова-
552  Проектирование клиент-серверных приложений
тель B не мог увидеть этого товара в диалоге редактирования. Главная проблема не
в оптимистической проверке версий по окончании диалогового взаимодействия;
проблема в том, что все изменения будут потеряны при запуске нового диалогово-
го взаимодействия.
Вместо простого вывода сообщения об ошибке при попытке одновременного из-
менения данных можно создать диалог, позволяющий пользователю сохранить
ставшие недействительными изменения, вручную выполнить слияние с изменениями,
сделанными другим пользователем, а затем сохранить итоговый результат.
Но предупреждаем, что реализация такой функциональности может потребовать
большого количества времени и Hibernate не сильно вам в этом поможет.
Недостатком такого подхода является необходимость разработки толстого кли-
ента, решения проблем сетевого взаимодействия и сериализации данных. Слож-
ность реализации переносится со стороны сервера на клиента, и вы должны опти-
мизировать связь клиента с сервером.
Если вместо EJB-клиента вы разрабатываете клиента на JavaScript, который
должен работать в нескольких браузерах или использоваться как обычное при-
ложение в различных (мобильных) операционных системах, сделать это может
быть очень трудно. Мы советуем использовать такую архитектуру, когда толстый
клиент работает в популярных браузерах, где пользователи будут загружать са-
мую последнюю версию клиентского приложения каждый раз, когда они заходят
на сайт. Развертывание обычных приложений на нескольких платформах, их со-
провождение и обновление могут быть серьезным бременем даже в корпоратив-
ных сетях среднего размера, где есть возможность управлять пользовательским
окружением.
Работая вне среды EJB, вы должны будете реализовать сериализацию и пере-
дачу отсоединенных сущностей между клиентом и сервером. Можете ли вы на-
строить сериализацию и десериализацию экземпляра Item? Что произойдет, если
клиент будет написан не на Java? Мы рассмотрим этот вопрос в разделе 19.4.
Далее мы повторно реализуем тот же сценарий, но с применением совершенно
иной стратегии. Теперь сервер будет хранить состояние диалога с приложением,
а клиентом будет простое устройство ввода/вывода. Это – архитектура с тонким
клиентом и сервером, хранящим состояние (stateful server).
18.3. Разработка сервера с сохранением
состояния
Следующее наше приложение останется таким же простым. Оно будет поддержи-
вать те же варианты использования, что и прежде: редактирование товара и разме-
щение ставки. Пользователи приложения не заметят разницы; консольный EJB-
клиент будет по-прежнему выглядеть, как на рис. 18.2 и 18.4.
Сервер будет отвечать за преобразование данных для отображения в формат,
понятный тонкому клиенту, например в страницу HTML, отображаемую браузе-
Разработка сервера с сохранением состояния  553
ром. Клиент будет передавать данные пользовательского ввода напрямую серверу,
например при отправке формы HTML. Сервер должен расшифровать и преобра-
зовать полученные данные в формат, более пригодный для использования в высо-
коуровневых операциях предметной модели. Однако мы упростим эту часть и ис-
пользуем удаленные вызовы методов в EJB-клиенте.
Сервер также будет запоминать состояние диалогового взаимодействия, сохра-
няя его в объекте сеанса, связанном с конкретным клиентом. Обратите внимание,
что сеанс существует дольше одного диалогового взаимодействия; пользователь
может участвовать в нескольких диалоговых взаимодействиях в течение сеанса.
Но если пользователь закроет клиентское приложение, не завершив диалогового
взаимодействия, данные этого диалога должны быть в какой-то момент очище-
ны. Для решения этой проблемы сервер обычно использует время ожидания; на-
пример, сервер может удалить пользовательский сеанс со всеми данными после
определенного периода бездействия. Эта работа как раз подходит для сеансовых
компонентов EJB с сохранением состояния – они идеально подходят для реализа-
ции данной архитектуры.
Запомнив все эти фундаментальные особенности, реализуем первый вариант
использования: редактирование товара.
18.3.1. Редактирование информации о товаре
Новый клиент все так же выводит список товаров, а пользователь выбирает один
из них. Это простейшая часть приложения, и серверу не нужно хранить ника-
ких данных о состоянии диалога. Взгляните на последовательность вызовов на
рис. 18.6.
Рис. 18.6  Клиент получает данные, готовые для отображения
Поскольку клиент очень простой, он не должен знать ничего о классе сущности
Item. Он загружает  список List объектов передачи данных ItemBidSummary:
554  Проектирование клиент-серверных приложений
Файл: /apps/app-stateful-server/src/test/java/org/jpwh/test/stateful/
AuctionServiceTest.java
List<ItemBidSummary> itemBidSummaries = auctionService.getSummaries();
Сервер реализует эту функциональность с помощью компонента без состояния,
поскольку пока нет необходимости сохранять состояние диалога:
Файл: /apps/app-stateful-server/src/main/java/org/jpwh/stateful/
AuctionServiceImpl.java
@javax.ejb.Stateless
@javax.ejb.Local(AuctionService.class)
@javax.ejb.Remote(RemoteAuctionService.class)
public class AuctionServiceImpl implements AuctionService {
@Inject
protected ItemDAO itemDAO;
@Override
public List<ItemBidSummary> getSummaries() {
return itemDAO.findItemBidSummaries();
}
}
Даже в серверной архитектуре с сохранением состояния всегда будет проис-
ходить множество коротких диалоговых взаимодействий с приложением, не тре-
бующим сохранения состояния на сервере. Это нормально, и важно понимать, что
хранение состояния на сервере стоит ресурсов. Если реализовать операцию get-
Summaries(), используя сеансовый компонент с сохранением состояния, вы лишь
впустую потратите ресурсы. Компонент с сохранением состояния понадобится
только для единственной операции, после чего он будет занимать память, пока
контейнер не избавится от него. Архитектура сервера с состоянием не обязывает
применять одни лишь компоненты с состоянием.
Далее клиентское приложение выводит список объектов ItemBidSummary, содер-
жащий только идентификатор, описание и максимальную ставку каждого товара.
Это именно то, что пользователь видит на экране, как показано на рис. 18.2. После
чего пользователь введет идентификатор товара и начнет диалоговое взаимодей-
ствие. Схема этого диалогового взаимодействия приводится на рис. 18.7.
Клиент сообщает серверу, что тот должен начать диалоговое взаимодействие,
посылая ему значение идентификатора :
Файл: /apps/app-stateful-server/src/test/java/org/jpwh/test/stateful/
AuctionServiceTest.java
itemService.startConversation(itemId);
Здесь уже не вызывается служба AuctionService без состояния из предыдущего
раздела. Новая служба ItemService – это компонент с сохранением состояния; сер-
вер будет создавать его экземпляры и назначать их отдельно для каждого клиента.
Эта служба реализуется с использованием сеансового компонента с состоянием:
Разработка сервера с сохранением состояния  555
Рис. 18.7  Клиентское приложение
задает границы диалогового взаимодействия на сервере
Файл: /apps/app-stateful-server/src/main/java/org/jpwh/stateful/
ItemServiceImpl.java
@javax.ejb.Stateful(passivationCapable = false)
@javax.ejb.StatefulTimeout(10) Минуты
@javax.ejb.Local(ItemService.class)
@javax.ejb.Remote(RemoteItemService.class)
public class ItemServiceImpl implements ItemService {
@PersistenceContext(type = EXTENDED, synchronization = UNSYNCHRONIZED)
protected EntityManager em;
@Inject
protected ItemDAO itemDAO;
@Inject
protected BidDAO bidDAO;
// Состояние диалогового взаимодействия на сервере
protected Item item;
// ...
@Override
public void startConversation(Long itemId) {
item = itemDAO.findById(itemId);
if (item == null)
throw new EntityNotFoundException(
"No Item found with identifier: " + itemId
);
}
// ...
}
556  Проектирование клиент-серверных приложений
Этот класс имеет множество аннотаций, определяющих взаимодействие кон-
тейнера с компонентом. Поскольку для компонента задано время ожидания 10 ми-
нут, сервер удалит и уничтожит его, если он не будет вызываться в течение этого
времени. Это позволяет избавиться от диалоговых взаимодействий с длительным
периодом бездействия, когда, например, пользователь долго не использует кли-
ентского приложения.
Также для компонента EJB отключено пассивирование (passivation): контейнер
EJB может сериализовать и сохранить компонент с состоянием на диск для эко-
номии памяти или передачи его другому узлу кластера для восстановления сеанса
в случае ошибки. Пассивирование не затронет лишь одного поля – EntityManager.
Контекст хранения присоединяется к этому компоненту благодаря параметру EXTENDED;
также класс EntityManager не реализует интерфейс java.io.Serializable.
ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ:
Почему нельзя сериализовать EntityManager?
Нет никаких технических ограничений, почему контекст хранения и объект Entity-
Manager не могут быть сериализованы. Конечно, после десериализации объект EntityManager
должен быть присоединен к правильному экземпляру EntityManagerFactory
на целевой машине, но это уже особенности реализации. Пассивирование
контекста хранения до сих пор было вне поля зрения спецификаций JPA и Java EE.
Тем не менее большинство реализаций позволяет сериализовать и корректно де-
сериализовать контекст хранения. EntityManager в Hibernate может быть сериализо-
ван и десериализован и правильно присоединен к нужной единице хранения после
десериализации.
Используя Hibernate с сервером Wildfly, вы могли бы использовать пассивирова-
ние в предыдущем примере, получая возможность восстановления сеанса в слу-
чае ошибки, а также бесперебойную работу сервера с состоянием и расширенные
контексты хранения. Тем не менее эта функциональность не стандартизована; как
мы увидим далее, такая стратегия препятствует масштабированию.
Были времена, кода даже в Hibernate не было возможности сериализовать EntityManager.
Вы можете столкнуться с устаревшими фреймворками, пытавшимися
обойти это ограничение, такими как Seam, который использует ManagedEntityInterceptor.
Вам следует избегать этого и находить более простые решения, такие
как перенаправление запросов на один узел кластера (sticky session), архитектуру
сервера с состоянием или внедрение зависимостей (CDI) при диалоговом взаимо-
действии на стороне сервера, которое мы обсудим в следующей главе на примере
контекста хранения, связанного с запросом.
Аннотация @PersistenceContext объявляет, что этот компонент с состоянием
нуждается в экземпляре EntityManager и контейнер должен расширять время
жизни контекста хранения до границ жизненного цикла компонента. Режим
расширения доступен только для EJB-компонентов с состоянием. Без этого
контейнер будет создавать и закрывать контекст хранения при подтверждении
каждой транзакции. Но здесь требуется, чтобы контекст хранения оставался
Разработка сервера с сохранением состояния  557
открытым за границами транзакции и был привязан к экземпляру сеансового
компонента с состоянием.
Более того, нужно предотвратить автоматическое выталкивание контекста во
время подтверждения транзакции, поэтому используется параметр UNSYNCHRONIZED.
Hibernate вытолкнет контекст хранения после его подключения к транзак-
ции вручную. Теперь Hibernate не будет автоматически записывать изменения
в хранимых экземплярах сущностей в базу данных; вместо этого он будет накапливать
изменения, пока вы не решите записать все разом.
В начале диалогового взаимодействия сервер загрузит экземпляр Item, пред-
ставляющий состояние диалога, и сохранит его в поле класса  (рис. 18.7). Объ-
екту ItemDAO также необходим экземпляр EntityManager; вспомните, что он отме-
чен аннотацией @PersistenceContext без дополнительных параметров. Правила
передачи контекста хранения в EJB такие же, как и раньше: Hibernate передает
контекст хранения вместе с контекстом транзакции. Контекст хранения будет пе-
редан в ItemDAO вместе с транзакцией, запущенной вызовом метода startConversation().
После выхода из метода startConversation() транзакция подтверждается,
но контекст хранения не выталкивается и не закрывается. Экземпляр ItemServiceImpl
ожидает следующего обращения клиента.
Следующий вызов от клиента просит сервер изменить название товара :
Файл: /apps/app-stateful-server/src/test/java/org/jpwh/test/stateful/
AuctionServiceTest.java
itemService.setItemName("Pretty Baseball Glove");
На стороне сервера транзакция запустится вызовом метода setItemName(). Но
поскольку никакие ресурсы транзакции не используются (ни вызовы DAO, ни вы-
зовы EntityManager), изменится только объект Item, представляющий диалоговое
состояние:
Файл: /apps/app-stateful-server/src/main/java/org/jpwh/stateful/
ItemServiceImpl.java
public class ItemServiceImpl implements ItemService {
// ...
@Override
public void setItemName(String newName) {
item.setName(newName);
} После подтверждения транзакции контекст хранения не выталкивается,
// ...
поскольку он рассинхронизирован
}
Обратите внимание, что экземпляр Item по-прежнему находится в хранимом со-
стоянии, потому что контекст хранения еще открыт! Но из-за рассинхронизации
он не обнаружит изменений в экземпляре Item, поскольку не будет выталкиваться
при подтверждении транзакции.
558  Проектирование клиент-серверных приложений
Наконец, клиентское приложение завершает диалоговое взаимодействие, пред-
лагая серверу сохранить изменения (рис. 18.7):
Файл: /apps/app-stateful-server/src/test/java/org/jpwh/test/stateful/
AuctionServiceTest.java
itemService.commitConversation();
Теперь на сервере можно записать изменения в базу данных и очистить диа-
логовое состояние:
Файл: /apps/app-stateful-server/src/main/java/org/jpwh/stateful/
ItemServiceImpl.java
public class ItemServiceImpl implements ItemService {
@Override
@javax.ejb.Remove Компонент удаляется после завершения этого метода
public void commitConversation() {
em.joinTransaction();
}
}
На этом реализация первого варианта использования закончена. Мы опускаем
реализацию второго варианта (размещение ставки) и отсылаем вас к коду приме-
ра за подробностями. Код второго варианта очень похож на код первого, поэтому
у вас не должно возникнуть проблем с его пониманием. Важно, чтобы вы понима-
ли, как работают контекст хранения и как действуют транзакции в EJB.
ПРИМЕЧАНИЕ В EJB существуют дополнительные правила передачи контек-
ста хранения между различными типами компонентов. Они довольно сложны,
и мы никогда не видели хороших вариантов для их применения. К примеру, вряд
ли вы станете вызывать компонент EJB с состоянием из компонента EJB без со-
стояния. Еще одну трудность представляют методы EJB с отключенными или
необязательными транзакциями, которые также влияют на передачу контекста
хранения через вызовы компонентов. Мы рассказывали об этих правилах в пре-
дыдущем издании этой книги. Советуем придерживаться только тех стратегий,
что были показаны в этой главе, ничего не усложняя.
Давайте обсудим некоторые различия между архитектурами с состоянием и без
состояния.
18.3.2. Анализ приложений с сохранением состояния
Так же, как при анализе приложения без состояния, рассмотрим сначала реали-
зацию единицы работы с точки зрения пользователя. В частности, нужно понять,
как в диалоговом взаимодействии реализована атомарность и как представить по-
следовательность действий в виде одной единицы работы.
В какой-то момент – обычно во время последнего запроса в рамках диалогового
взаимодействия – происходят подтверждение и запись изменений в базу данных.
Контекст хранения соединяется с текущей транзакцией
и выталкивается после выхода из метода, сохраняя изменения
Разработка сервера с сохранением состояния  559
Диалоговое взаимодействие будет атомарным, если не присоединять расширен-
ного экземпляра EntityManager с транзакцией до последнего диалогового события.
Если читать данные в рассинхронизированном режиме, состояние объектов про-
веряться не будет, так же как не будет выталкиваться контекст хранения.
Пока контекст открыт, можно выполнять отложенную загрузку данных, обра-
щаясь к прокси-объектам и незагруженным коллекциям, что, очевидно, довольно
удобно. Загруженный объект Item, как и прочие данные, устаревает, если пользо-
вателю требуется длительное время для выполнения следующего запроса. Во вре-
мя диалогового взаимодействия вам, возможно, придется выполнять операцию
refresh() для некоторых управляемых экземпляров сущностей, чтобы получать
обновления из базы данных, как объяснялось в разделе 10.2.6. С другой стороны,
вы можете выполнять обновления для отката изменений, сделанных в ходе диа-
логового взаимодействия. Например, если пользователь поменяет поле Item#name,
а затем решит отменить изменение, вы можете обновить хранимый экземпляр Item
вызовом метода refresh(), который извлечет из базы данных старое название то-
вара. Эта приятная особенность расширенного контекста хранения позволяет эк-
земпляру Item всегда находиться в управляемом состоянии.
Точки сохранения в диалоговых взаимодействиях
Вам могут быть знакомы точки сохранения (savepoints) в транзакциях JDBC: после
изменения некоторых данных в рамках транзакции создается точка сохранения;
позже вы можете откатить транзакцию до этой точки, отказываясь лишь от части
сделанных изменений, но сохраняя все, что было сделано до создания точки вос-
становления. К сожалению, Hibernate не поддерживает ничего, похожего на точки
восстановления, для контекста хранения. Экземпляр сущности можно откатить
только до состояния в базе данных, используя метод refresh(). В Hibernate можно
использовать обычные точки сохранения в транзакциях JDBC (для этого потребу-
ется экземпляр Connection; см. раздел 17.1), но они не помогут сделать откат в диа-
логовом взаимодействии.
Серверная архитектура с сохранением состояния труднее поддается горизон-
тальному масштабированию. Если на сервере произойдет сбой, текущее состояние
диалогового взаимодействия, как и сеанс, целиком будет потеряно. Репликация
сеанса на несколько серверов – это дорогостоящая операция, поскольку каждое
изменение в сеансе на одном сервере вызывает сетевое взаимодействие с другими
(потенциально всеми) серверами.
Сериализация расширенного контекста хранения невозможна при работе с ком-
понентами EJB и расширенными экземплярами EntityManager. При использова-
нии компонентов EJB с состоянием и расширенного контекста хранения в класте-
ре можно рассмотреть вариант применения прикрепленного сеанса (sticky session),
когда запросы конкретного клиента всегда направляются на один физический сер-
вер. Это позволит справиться с растущей нагрузкой путем добавления серверов,
но пользователь должен быть готов к потере данных в случае сбоя на сервере.
560  Проектирование клиент-серверных приложений
С другой стороны, сервер с состоянием может выступать в качестве первой
линии кэширования со своими расширенными контекстами хранения в сеансах
пользователей. Как только экземпляр Item будет загружен во время диалогового
взаимодействия с конкретным пользователем, он не будет загружаться снова из
базы данных в рамках этого взаимодействия. Это может стать отличным инстру-
ментом для снижения нагрузки на сервер базы данных (самый дорогой слой с точ-
ки зрения масштабирования).
Стратегия применения расширенного контекста хранения требует от сервера
больше памяти, чем хранение только отсоединенных экземпляров, потому что
контекст хранения в Hibernate содержит копии всех управляемых экземпляров.
Вам может потребоваться вручную отсоединять управляемые экземпляры мето-
дом detach() для управления тем, что хранится в контексте, или отключать про-
верку состояния объектов и хранение копий (сохраняя при этом возможность от-
ложенной загрузки), как объяснялось в разделе 10.2.8.
Конечно, существуют альтернативные реализации тонких клиентов и серверов
с состоянием. Можно использовать контекст хранения, связанный с запросом,
управляя отсоединенными (нехранимыми) экземплярами сущностей на сервере
вручную. Очевидно, это можно сделать путем отсоединения и слияния, но потре-
бует больших затрат на реализацию. Одно из главных преимуществ расширен-
ного контекста хранения – прозрачная отложенная загрузка (даже между запро-
сами) – больше не будет доступна. В следующей главе мы покажем реализацию
такого сервера с состоянием, контекст хранения которого в CDI и JSF привязан
к запросу, и вы сможете сравнить это с функциональностью расширенного контек-
ста хранения EJB, которую мы показали в этой главе.
Системы с тонким клиентом, как правило, создают большую нагрузку на сервер,
чем толстые клиенты. Каждый раз, когда пользователь взаимодействует с прило-
жением, любое клиентское событие будет отправлять запрос по сети. Это может
происходить при каждом нажатии на кнопку мыши в веб-приложении. Только
сервер знает о состоянии диалогового взаимодействия, и он должен подготовить
и отобразить информацию, которую увидит пользователь. Толстый клиент, напро-
тив, может загрузить необработанные данные в одном запросе, преобразовать их
и уже на месте привязать их к пользовательскому интерфейсу. Диалог в толстом
клиенте может накапливать изменения на стороне клиента и отправлять запрос
по сети только в конце взаимодействия, когда нужно сохранить изменения в базу
данных.
Другая проблема с тонким клиентом заключается в параллельных диалоговых
взаимодействиях одного пользователя: что произойдет, если пользователь изме-
нит два элемента одновременно, например в двух вкладках браузера? Это будет
означать, что пользователь запустит два диалоговых взаимодействия на сервере.
Сервер должен будет разделить данные в сеансе пользователя, в зависимости от
диалогового взаимодействия. Следовательно, клиентские запросы должны будут
содержать некоторое подобие идентификатора диалогового взаимодействия, что-
бы можно было извлекать корректное состояние диалога из сеанса пользовате-
Резюме  561
ля при каждом запросе. При работе с клиентами и серверами, основанными на
EJB, это происходит автоматически, но вряд ли эта функциональность встроена
в ваш любимый фреймворк веб-приложений (если только это не JSF и CDI, как
вы узнаете
в следующей главе).
Одним из самых больших преимуществ сервера с состоянием является слабая
зависимость от клиентской платформы; если клиентом является простой терми-
нал ввода/вывода, будет меньше шансов, что что-то пойдет не так. Единственное
место проверки данных и безопасности будет на сервере. Не будет никаких проблем
с развертыванием; вы сможете обновлять приложение на сервере, не затраги-
вая клиентов.
Сегодня у тонкого клиента немного преимуществ, и количество установок сер-
веров с состоянием снижается. Это особенно заметно на рынке веб-приложений,
где легкость масштабирования является решающим фактором.
18.4. Резюме
 В этой главе мы реализовали простые диалоговые взаимодействия – единицы
работы с точки зрения пользователей приложения.
 Рассмотрели проекты клиента и сервера с состоянием и без состояния и узна-
ли, как Hibernate вписывается в каждую из них.
 Вы можете работать либо с отсоединенными экземплярами сущностей, либо
с расширенным контекстом хранения, распространяющимся на все диалого-
вое взаимодействие.
Глава 19
Создание
веб-приложений
В этой главе:
 интеграция JPA с CDI и JSF;
 просмотр таблиц баз данных;
 реализация длительных диалоговых взаимодействий;
 настройка сериализации сущностей.
В этой главе вы узнаете, как применять Hibernate в типичном веб-приложении.
Существуют десятки фреймворков для разработки веб-приложений на Java, по-
этому мы заранее приносим извинения, если пройдем мимо вашего любимого
фреймворка. Мы рассмотрим применение JPA в стандартном окружении Java Enterprise
Edition, в частности в сочетании со следующими стандартами: внедрение
контекста и зависимостей (CDI), Java Server Faces (JSF) и Java API для веб-служб
на основе REST (JAX-RS). Мы, как всегда, продемонстрируем шаблоны, которые
можно применять также в нестандартных окружениях.
Сначала мы еще раз обратимся к уровню хранения и продемонстрируем приме-
нение CDI в классах DAO. После чего расширим эти классы, реализовав обобщен-
ное решение для сортировки и постраничного вывода данных. Это решение можно
использовать, когда потребуется отобразить табличные данные независимо от вы-
бранного фреймворка.
Далее, опираясь на уровень хранения, мы напишем полностью работающее
JSF-приложение и познакомимся с областью видимости диалога в Java EE (conversation
scope), в которой CDI, взамодействуя с JSF, поддерживает простую мо-
дель серверных компонентов с состоянием. Если вам не приглянулись показан-
ные в прошлой главе EJB-компоненты с состоянием и расширенным контекстом
хранения, диалоговые взаимодействия с отсоединенным состоянием сущности на
сервере, вероятно, вам понравятся больше.
И наконец, если вам нравится создавать веб-приложения с толстыми клиен-
тами, серверами без состояния и такими фреймворками, как JAX-RS, GWT или
AngularJS, мы научим вас сериализовать экземпляры сущностей JPA в форматы
XML и JSON. А начнем мы с переноса реализации уровня хранения с EJB на CDI.
Интеграция JPA и CDI  563
19.1. Интеграция JPA и CDI
Стандарт CDI определяет механизм типизированного внедрения зависимостей,
а также систему управления жизненным циклом компонентов в среде выполнения
Java EE. В предыдущей главе вы уже использовали аннотацию @Inject для связы-
вания компонентов ItemDAO и BidDAO с классами служб EJB.
JPA-аннотация @PersistenceContext, которую мы помещали внутрь классов
DAO, представляет еще один, особый случай внедрения зависимостей: вы просите
контейнер среды выполнения внедрить экземпляр EntityManager и автоматически
управлять им. Этот экземпляр, EntityManager, будет управляться контейнером. Но
есть еще подводные камни, такие как передача контекста хранения и правила рас-
пространения транзакций, которые мы обсудили в предыдущей главе. Такие прави-
ла удобны, когда все классы служб и DAO являются компонентами EJB; но если вы
не используете EJB, вам, возможно, не захочется следовать этим правилам. С по-
мощью управляемого приложением экземпляра EntityManager можно определить
собственные правила управления контекстом хранения, его передачи и внедрения.
Сейчас мы перепишем классы DAO, как обычные управляемые компоненты
CDI, которые очень похожи на EJB: простые Java-классы с дополнительными ан-
нотациями. Нужно лишь с помощью аннотации @Inject внедрить экземпляр EntityManager,
избавившись от @PersistenceContext, и получить тем самым полный
контроль над контекстом хранения. Но прежде, чем внедрить собственный экзем-
пляр EntityManager, его нужно создать.
19.1.1. Создание экземпляра EntityManager
Продюсер (producer) в терминологии CDI – это фабрика, управляющая созданием
экземпляра, которую контейнер среды выполнения будет вызывать, когда прило-
жению понадобится экземпляр в заданной области видимости. К примеру, кон-
тейнер создаст экземпляр в области видимости приложения только один раз за
весь жизненный цикл приложения. Экземпляр в области видимости запроса (request-
scoped) будет создаваться контейнером при получении запроса от клиента,
а экземпляр в области видимости сеанса (session-scoped) – отдельно для каждого
сеанса пользователя.
Спецификация CDI задает отображение между абстрактными понятиями за-
проса и сеанса и реальными объектами запроса и сеанса в сервлете. Не забывайте,
что JSF и JAX-RS построены на основе сервлетов, поэтому CDI отлично подходит
для этих фреймворков. Другими словами, не беспокойтесь об этом: в окружении
Java EE вся работа по интеграции уже сделана за вас.
Давайте напишем продюсера для экземпляров EntityManager в области видимо-
сти запроса:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/
EntityManagerProducer.java
@javax.enterprise.context.ApplicationScoped  Нужен только 1 продюсер
public class EntityManagerProducer {
564  Создание веб-приложений
@PersistenceUnit  Получение единицы хранения
private EntityManagerFactory entityManagerFactory;
@javax.enterprise.inject.Produces  Получение экземпляра EntityManager
@javax.enterprise.context.RequestScoped
public EntityManager create() {
return entityManagerFactory.createEntityManager();
}
public void dispose(
@javax.enterprise.inject.Disposes  Закрытие контекста хранения
EntityManager entityManager) {
if (entityManager.isOpen())
entityManager.close();
}
}
 Эта аннотация CDI объявляет, что во всем приложении должен иметься только один
продюсер: будет существовать единственный экземпляр EntityManagerProducer.
 Среда выполнения Java EE предоставит единицу хранения, определенную в файле persistence.
xml, которая также является компонентом области видимости приложения.
(Если CDI используется вне окружения Java EE, можно вызвать статический фабрич-
ный метод Persistence.createEntityManagerFactory()).
 Как только приложению потребуется экземпляр EntityManager, будет вызван метод create().
Контейнер повторно использует один экземпляр EntityManager в течение всего
запроса, обрабатываемого сервером. (Если забыть поместить аннотацию @RequestScoped
перед методом, экземпляр EntityManager будет иметь область видимости приложения,
как и класс продюсера!)
 После завершения обработки запроса, при удалении его контекста, контейнер CDI вы-
зовет этот метод, чтобы избавиться от экземпляра EntityManager. Поскольку вы сами
создали этот управляемый приложением контекст хранения (см. раздел 10.1.2), вы и от-
вечаете за его закрытие.
Частой ошибкой при работе с классами, использующими аннотации CDI, яв-
ляется неправильный импорт аннотаций. В Java EE 7 существуют две аннотации
с именем @Produces; вторая находится в пакете javax.ws.rs (спецификация JAX-RS).
Ее семантика отличается от аннотации продюсера CDI, и вы можете часами ис-
кать ошибку, если импортировали не ту аннотацию. Другой такой же аннотаци-
ей является @RequestScoped из пакета javax.faces.bean (специфиакация JSF). Как
и большинство устаревших аннотаций JSF для управления компонентами из па-
кета javax.faces.bean, ее не стоит использовать, если доступна более современная
альтернатива из CDI. Мы надеемся, что будущие спецификации Java EE устранят
эту двусмысленность.
Теперь у нас есть фабрика для создания экземпляров EntityManager, управляе-
мых приложением, и контекста хранения с областью видимости запроса. Теперь
нужно придумать, как сообщать экземпляру EntityManager о системных транзак-
циях.
Интеграция JPA и CDI  565
19.1.2. Присоединение экземпляра EntityManager
к транзакциям
Когда серверу потребуется обработать запрос сервлета, контейнер автоматически
создаст экземпляр EntityManager при первой необходимости его внедрения. Помни-
те, что созданный вручную экземпляр EntityManager автоматически присоединится
к системной транзакции, только если та уже началась. В противном случае он будет
рассинхронизирован: вы будете читать данные в режиме автоматического подтверж-
дения (auto-commit), и Hibernate не будет выталкивать контекста хранения.
Не всегда очевидно, в какой момент контейнер вызовет продюсера EntityManager
или когда точно во время обработки запроса произойдет внедрение Entity-
Manager. При обработке запроса вне системной транзакции получаемый объект EntityManager
всегда будет рассинхронизирован. Следовательно, мы должны сделать
так, чтобы экземпляр EntityManager узнал о системной транзакции.
Для этой цели в суперинтерфейсе уровня хранения имеется следующий метод:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/GenericDAO.java
public interface GenericDAO<T, ID extends Serializable>
extends Serializable {
void joinTransaction();
// ...
}
Мы должны вызвать этот метод в каждом классе DAO перед сохранением дан-
ных, когда точно известно, что он будет вызван в рамках транзакции. Напомним,
что при попытке записи данных Hibernate возбудит исключение TransactionRequiredException,
напоминая, что экземпляр EntityManager был создан перед на-
чалом транзакции и не знает о ней. Если вы хотите потренировать свои навыки
в CDI, можете попробовать реализовать эту функциональность с помощью деко-
раторов или перехватчиков CDI.
Давайте реализуем новый метод интерфейса GenericDAO, связав экземпляр EntityManager
с классами DAO.
19.1.3. Внедрение экземпляра EntityManager
Старая реализация GenericDAOImpl полагалась на аннотацию @PersistenceContext
для внедрения объекта EntityManager в поле класса или на вызов setEntityManager()
перед использованием класса DAO. С помощью CDI можно использовать
более безопасную технику внедрения в конструктор:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/GenericDAOImpl.java
public abstract class GenericDAOImpl<T, ID extends Serializable>
implements GenericDAO<T, ID> {
protected final EntityManager em;
protected final Class<T> entityClass;
566  Создание веб-приложений
protected GenericDAOImpl(EntityManager em, Class<T> entityClass) {
this.em = em;
this.entityClass = entityClass;
}
public EntityManager getEntityManager() {
return em;
}
@Override
public void joinTransaction() {
if (!em.isJoinedToTransaction())
em.joinTransaction();
}
// ...
}
Каждый, кто захочет создать экземпляр класса DAO, должен будет передать ему
объект EntityManager. Такое определение инварианта класса дает более весомые
гарантии; следовательно, несмотря на то что в наших примерах мы часто исполь-
зуем внедрение в поля классов, вы должны в первую очередь рассматривать воз-
можность внедрения в конструкторы. (Мы не делаем этого в некоторых примерах,
поскольку от этого они стали бы только длиннее, а книга уже и так не маленькая).
В конкретных подклассах (DAO сущностей) следует объявить требуемое внедрение
в конструктор:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/ItemDAOImpl.java
public class ItemDAOImpl
extends GenericDAOImpl<Item, Long>
implements ItemDAO {
@Inject
public ItemDAOImpl(EntityManager em) {
super(em, Item.class);
}
// ...
}
Когда приложению потребуется объект ItemDAO, среда выполнения CDI обра-
тится к продюсеру EntityManagerProducer, а затем вызовет конструктор ItemDAOImpl.
В рамках одного запроса контейнер повторно использует один и тот же объ-
ект EntityManager для внедрения в каждый экземпляр DAO.
ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ:
Как в CDI работать с несколькими единицами хранения?
При работе с несколькими базами данных – разными единицами хранения – можно
использовать квалификаторы CDI, чтобы различать их. Квалификатор – это произ-
Сортировка и постраничная выборка данных  567
вольная аннотация. Вы создаете аннотацию вроде @BillingDatabase и отмечаете ее
как квалификатор. Затем помещаете ее рядом с аннотацией @Produces перед мето-
дом, создающим экземпляр EntityManager для этой конкретной единицы хранения.
Теперь, когда понадобится этот экземпляр EntityManager, вы должны будете доба-
вить аннотацию @BillingDatabase рядом с @Inject.
В какой области видимости находится ItemDAO? Поскольку область видимости
классов реализации не задана, это зависит от конкретной ситуации. Экземпляр
ItemDAO создается, когда он кому-либо нужен, поэтому экземпляр ItemDAO будет
находиться в той же области видимости, что и вызывающий код, и будет принад-
лежать вызывающему объекту. Это хорошее решение для реализации интерфейса
уровня хранения, поскольку перекладывает решение о выборе области видимости
на верхний уровень, состоящий из служб, обращающихся к уровню хранения.
Теперь с помощью аннотации @Inject можно внедрить экземпляр ItemDAO в поле
класса службы. Но, прежде чем воспользоваться уровнем хранения на основе CDI,
давайте реализуем еще поддержку сортировки и постраничной выборки данных.
19.2. Сортировка и постраничная выборка данных
Очень распростаненным требованием являются загрузка данных из базы и их
отображение
на веб-странице в табличном виде. Но часто также требуется реали-
зовать динамическую постраничную выборку и сортировку данных:
 поскольку запрос возвращает больше данных, чем можно отобразить на од-
ной странице, вы должны показывать только часть из них. Вы отображаете
определенное количество записей, давая пользователю возможность пере-
хода к следующему, предыдущему, первому или последнему набору записей.
Пользователь также ожидает сохранения порядка сортировки при переклю-
чении между страницами;
 пользователь должен иметь возможность, щелкнув мышкой на заголовке ко-
лонки, отсортировать строки в таблице по значениям в этой колонке. Обыч-
но сортировать можно либо по возрастанию, либо по убыванию; направление
можно менять последовательными щелчками на заголовке колонки.
Сейчас мы реализуем обобщенное решение для постраничной выборки, осно-
ванное на метамодели хранимых классов, предоставляемой JPA.
Постраничную выборку можно реализовать двумя способами: с помощью при-
ема смещения (offset) или поиска (seek). Давайте рассмотрим их отличия и опре-
делимся с реализацией.
19.2.1. Реализация постраничной выборки
с помощью смещения или поиска
На рис. 19.1 показан пример пользовательского интерфейса с постраничным
отображением
на основе смещений. У нас имеется довольно много аукционных
товаров, но на одной странице можно отобразить только три записи. Сейчас мы
568  Создание веб-приложений
находимся на первой странице; приложение также динамически отображает ссыл-
ки на другие страницы. Результаты отсортированы по возрастанию наименова-
ния товара. Вы можете щелкнуть на заголовке колонки, чтобы отсортировать по
убыванию (или возрастанию) наименования, даты окончания аукциона или наи-
большему значению ставки. Щелчок на наименовании товара в таблице откроет
диалог просмотра данных о товаре, в котором вы сможете сделать ставку. Как раз
этот вариант использования мы и реализуем в этой главе.
Рис. 19.1  Отображение страниц каталога
с использованием приема смещений
Для создания этой страницы применялись запросы к базе данных с заданными
смещением и количеством извлекаемых записей. Для этого вызывались методы
Java Persistence API: Query#setFirstResult() и Query#setMaxResults(), обсуждав-
шиеся в разделе 14.2.4. Сначала пишется запрос, а затем фреймворку Hibernate
предоставляется возможность добавить в него ограничения на смещение и коли-
чество извлекаемых записей, в зависимости от используемого диалекта SQL.
Теперь пришло время рассмотреть альтернативный подход с применением по-
иска, как показано на рис. 19.2. Здесь у пользователя нет возможности перейти на
произвольную страницу с заданным смещением; он может листать только вперед,
переходя на следующую страницу. Это может выглядеть как ограничение, но вы,
вероятно, видели или даже использовали такой способ постраничной выборки,
когда требовалась бесконечная прокрутка. Можно, например, автоматически под-
грузить и отобразить следующую страницу с данными, когда пользователь дойдет
до конца таблицы/экрана.
Метод поиска основан на особом ограничении в запросе, извлекающем данные.
Когда придет время загрузить следующую страницу, выполнится поиск всех то-
варов с названиями «больше, чем [Coffee Machine]». Движение вперед будет осу-
ществляться не за счет установки смещения в результатах методом setFirstResult(),
а за счет ограничения результатов на основе отсортированных значений
какого-либо ключа. Если вы незнакомы с постраничной выборкой на основе поис-
ка, иногда называемой ключевой (keyset paging), мы уверены, что она не покажется
вам сложной после тех запросов, которые вы увидите далее в этой главе.
Сортировка и постраничная выборка данных  569
Рис. 19.2  Отображение страниц каталога
с использованием приема поиска следующей страницы
Давайте обсудим недостатки и преимущества обоих подходов. Конечно, можно
реализовать бесконечную прокрутку, используя постраничную выборку на основе
смещения, или переход к конкретной странице, используя метод поиска; но у каж-
дой из них есть свои сильные и слабые стороны:
 метод смещения удобен, если пользователю нужно перейти непосредствен-
но к конкретной странице. К примеру, большинство поисковых движков
поддерживает переход прямо к странице 42 в результатах запроса или сразу
к последней странице. Поскольку мы с легкостью можем рассчитать смеще-
ние и количество извлекаемых записей в зависимости от требуемого номе-
ра страницы, мы без труда сможем это реализовать. Реализовать подобный
пользовательский интерфейс с помощью метода поиска гораздо сложнее;
необходимо заранее знать искомое значение. Поскольку неизвестно, какой
товар предшествует странице 42, мы не сможем выбрать все товары с наименованием
«больше, чем X». Метод поиска подходит только для пользо-
вательских интерфейсов, где пользователи переходят в прямом или обрат-
ном направлении от страницы к странице в списке или таблице с данными
и где известно последнее (или первое) значение, показанное пользователю;
 отличный вариант использования для постраничной выборки на основе по-
иска основан на ключевых значениях, которые не нужно запоминать. На-
пример, все пользователи с именами, начинающимися на C, могут отображаться
на одной странице, а пользователи с именами, начинающимися на
D, – на следующей. Также каждая страница может отображать только това-
ры, преодолевшие пороговое значение максимальной ставки;
 метод смещений работает гораздо хуже для страниц, находящихся в конце.
При переходе к странице 5000 база данных должна подсчитать все строки
и подготовить 5000 страниц данных, прежде чем сможет пропустить пре-
дыдущие 4999. Типичное решение этой проблемы заключается в ограниче-
нии количества страниц, на которые пользователь может непосредствен-
но перейти:
например, разрешить пользователю переход только на первые
100 страниц, заставляя его уточнить ограничения запроса для получения
меньшего количества результатов. Метод поиска обычно работает быстрее
570  Создание веб-приложений
метода смещений даже для самых первых страниц. Оптимизатор запросов
базы данных может сразу перейти к началу требуемой страницы и эффек-
тивно ограничить сканируемую область индекса. Записи, показанные на
предыдущих страницах, никак не учитываются и не подсчитываются;
 иногда метод смещений может показывать некорректные результаты. Хотя
результат будет соответствовать состоянию базы данных, пользователям он
может казаться некорректным. Когда приложение вставляет или удаляет
записи
во время просмотра данных пользователем, могут возникать анома-
лии. Представьте пользователя, который смотрит на страницу 1, в то вре-
мя как другой добавляет данные, которые должны появиться на странице 1.
Если теперь пользователь перейдет к странице 2, некоторые записи, которые
он мог видеть на странице 1, перейдут на страницу 2. Если запись со стра-
ницы 1 была удалена, пользователь может не увидеть некоторых записей со
страницы 2, поскольку они перейдут на страницу 1. В методе поиска таких
аномалий не возникает; записи мистически не появляются и не исчезают.
Сейчас мы покажем, как реализовать оба метода постраничной выборки путем
расширения уровня хранения. Начнем с простой модели, хранящей номер теку-
щей страницы и настройки сортировки табличных данных.
19.2.2. Реализация постраничной выборки в уровне хранения
Для координации запросов и отображения страниц с данными нужно хранить ин-
формацию о размере страницы и знать, какая страница сейчас отображается. Ниже
показан простейший класс для хранения этой информации; это абстрактный су-
перкласс, который подойдет как для метода смещений, так и для метода поиска:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/Page.java
public abstract class Page {
public static enum SortDirection {
ASC,
DESC
}
protected int size = -1;  Вывод всех записей
protected long totalRecords;  Подсчет количества записей
protected SingularAttribute sortAttribute;  Сортировка записей
protected SortDirection sortDirection;
protected SingularAttribute[] allowedAttributes;  Список допустимых
// ...
для сортировки атрибутов
abstract public <T> TypedQuery<T> createQuery(
EntityManager em,
CriteriaQuery<T> criteriaQuery,
Path attributePath
);
}
Сортировка и постраничная выборка данных  571
 Модель хранит размер каждой страницы и количество записей на странице. Значение –1
означает, что будут возвращены все записи без ограничений.
 Хранение количества всех записей необходимо для некоторых вычислений, например
чтобы понять, существует ли «следующая» страница.
 Постраничная выборка всегда требует строго определенного порядка следования запи-
сей. Как правило, сортировка осуществляется по конкретному атрибуту класса сущно-
сти в порядке возрастания или убывания. Поле javax.persistence.metamodel.SingularAttribute
в JPA ссылается на атрибут сущности или встраиваемого класса; оно не может
ссылаться на коллекцию (результаты запроса нельзя «упорядочить по коллекции»).
 Список allowedAttributes задается во время создания модели страницы. Он определяет
допустимые для сортировки атрибуты, которые можно использовать в запросах.
Мы опустили некоторые тривиальные методы класса Page – в основном это ме-
тоды чтения/записи. Однако подклассы должны реализовать абстрактный метод
createQuery(): он описывает применение настроек страницы к запросу Criteria-
Query перед выполнением.
Сначала нужно связать интерфейс Page с уровнем хранения. Интерфейс DAO
будет принимать экземпляр Page, когда потребуется осуществить постраничную
выборку данных:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/ItemDAO.java
public interface ItemDAO extends GenericDAO<Item, Long> {
List<ItemBidSummary> getItemBidSummaries(Page page);
// ...
}
Таблица данных для отображения будет показывать список List оъектов пере-
дачи данных ItemBidSummary. Результат запроса не так важен в этом примере; мы
могли также извлечь и список экземпляров Item. Ниже показана часть реализации
DAO:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/ItemDAOImpl.java
public class ItemDAOImpl
extends GenericDAOImpl<Item, Long>
implements ItemDAO {
// ...
@Override
public List<ItemBidSummary> getItemBidSummaries(Page page) {
CriteriaBuilder cb =  Запрос на основе критериев
getEntityManager().getCriteriaBuilder();
CriteriaQuery<ItemBidSummary> criteria =
cb.createQuery(ItemBidSummary.class);
Root<Item> i = criteria.from(Item.class);
// Некоторые параметры запроса...
572  Создание веб-приложений
// ...
TypedQuery<ItemBidSummary> query =  Окончательная подготовка запроса
page.createQuery(em, criteria, i);
return query.getResultList();
}
// ...
}
 Это самый обычный запрос на основе критериев, который вы видели много раз до этого.
 Окончательная подготовка запроса ложится на плечи полученного объекта Page.
Конкретная реализация интерфейса Page подготавливает запрос, устанавливая
необходимые смещение, количество извлекаемых записей и параметры поиска.
Реализация метода смещений
Ниже показана реализация стратегии постраничной выборки на основе смещений:
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/OffsetPage.java
public class OffsetPage extends Page {
protected int current = 1;  Текущая страница
// ...
@Override
public <T> TypedQuery<T> createQuery(EntityManager em,
CriteriaQuery<T> criteriaQuery,
Path attributePath) {
throwIfNotApplicableFor(attributePath);  Попытка поиска атрибута для сортировки
CriteriaBuilder cb = em.getCriteriaBuilder();
Path sortPath = attributePath.get(getSortAttribute());  Добавит предложение
criteriaQuery.orderBy( ORDER BY
isSortedAscending() ? cb.asc(sortPath) : cb.desc(sortPath)
);
TypedQuery<T> query = em.createQuery(criteriaQuery);
query.setFirstResult(getRangeStartInteger());  Установка смещения
if (getSize() != -1)  Установка количества результатов
query.setMaxResults(getSize());
return query;
}
}
 Для постраничной выборки на основе смещений требуется знать номер текущей страни-
цы. По умолчанию текущей является страница 1.
Сортировка и постраничная выборка данных  573
 Проверка возможности получения пути к атрибуту сортировки для данной страницы и,
следовательно, к используемой запросом модели. Этот метод возбудит исключение, если
атрибут сортировки недоступен в модели класса, на который ссылается запрос. Это –
механизм повышения надежности, который выдаст осмысленное сообщение об ошибке,
если попытаться связать неправильные настройки страницы с неправильным запросом.
 Добавление в запрос предложения ORDER BY.
 Установка смещения в запросе: первой выбираемой записи.
 Установка количества записей, выбираемых для данной страницы.
Мы показали реализацию не всех используемых методов. Например, здесь от-
сутствует такой метод, как getRangeStartInteger(), который вычисляет номер записи,
первой в данной странице, в зависимости от размера страницы. Этот и другие
вспомогательные методы вы найдете в исходном коде.
Обратите внимание, что порядок результатов может быть не определен: сорти-
ровка выполняется по наименованиям товаров в алфавитном порядке, и несколь-
ко товаров имеют одинаковое наименование, база данных вернет их в том порядке,
который создатели СУБД посчитали приемлемым. Вы должны сортировать либо
по уникальному ключевому атрибуту, либо добавить дополнительный критерий
упорядочения по ключевому атрибуту. Несмотря на то что большинство разра-
ботчиков просто игнорирует проблему неопределенности при сортировке в ме-
тоде смещений, предсказуемость порядка сортировки в методе поиска является
обязательной.
Реализация метода поиска
Для реализации постраничной выборки на основе поиска нужно добавить в за-
прос ограничения. Предположим, что предыдущая страница показывала товары,
отсортированные по наименованиям в алфавитном порядке, до значения «Coffee
Machine», как показано на рис. 19.2, и нужно отобразить следующую страницу
с помощью запроса SQL. Запомнив последнее значение на предыдущей страни-
це – запись с «Coffe Machine» – и идентификатор (допустим 5), можно написать
следующий код SQL:
select i.* from ITEM i
where
i.NAME >= 'Coffee Machine'
and (
i.NAME <> 'Coffee Machine'
or i.ID > 5
)
order by
i.NAME asc, i.ID asc
Первое ограничение гласит: «Верни все товары, наименование которых больше
либо равно [Coffee Machine]», что приведет к поиску вперед до конца предыдущей
страницы. База данных может эффективно реализовать данное ограничение с по-
мощью поиска по индексу. Затем накладывается дополнительное ограничение, ис-
574  Создание веб-приложений
ключающее товар «Coffee Machine», пропуская таким образом запись, показанную
на предыдущей странице.
Но в базе данных могут оказаться два товара с наименованием «Coffee Machine
». Чтобы данные не потерялись при переходе между страницами, нужно ис-
пользовать уникальный ключ. Вы должны упорядочить и ограничить результаты,
используя этот уникальный ключ. Здесь используется первичный ключ, который
гарантирует, что база данных вернет товары, наименование которых не «Coffee
Machine», или товары (пусть даже с наименованием «Coffee Machine»), значение
идентификатора которых больше показанного на предыдущей странице.
Конечно, если наименование товара (или значение другого столбца, по кото-
рому производится сортировка) уникально, дополнительный уникальный ключ
можно не использовать. Код примера с обобщенным решением предполагает, что
всегда будет применяться явный уникальный ключ. Также обратите внимание: тот
факт, что идентификаторы товаров представляют собой возрастающую числовую
последовательность, не играет никакой роли; самое главное, чтобы ключ гаранти-
ровал предсказуемый порядок сортировки.
Запрос можно переписать в более компактной форме, используя синтаксис кон-
структора строк значений:
select i.* from ITEM i
where
(i.NAME, i.ID) > ('Coffee Machine', 5)
order by
i.NAME asc, i.ID asc
Такое ограничение работает даже с JPQL в Hibernate. Однако в JPA эта возмож-
ность не стандартизована; ее нельзя использовать в запросах на основе критериев,
и она поддерживается не всеми базами данных. Мы предпочитаем более длинный
вариант, работающий везде. Чтобы выполнить сортировку по убыванию, оператор
больше, чем следует заменить на меньше, чем.
Следующий код реализации класса SeekPage добавляет данное ограничение
в запрос на основе критериев.
Файл: /apps/app-web/src/main/java/org/jpwh/web/dao/SeekPage.java
public class SeekPage extends Page {
Добавление
protected SingularAttribute uniqueAttribute;  уникального атрибута сортировки
protected Comparable lastValue;  Запоминает значения на предыдущей странице
protected Comparable lastUniqueValue;
// ...
@Override
public <T> TypedQuery<T> createQuery(EntityManager em,
CriteriaQuery<T> criteriaQuery,
Path attributePath) {
Сортировка и постраничная выборка данных  575
throwIfNotApplicableFor(attributePath);
CriteriaBuilder cb = em.getCriteriaBuilder();
Path sortPath = attributePath.get(getSortAttribute());  Сортировка результатов
Path uniqueSortPath = attributePath.get(getUniqueAttribute());
if (isSortedAscending()) {
criteriaQuery.orderBy(cb.asc(sortPath), cb.asc(uniqueSortPath));
} else {
criteriaQuery.orderBy(cb.desc(sortPath),
cb.desc(uniqueSortPath));
}
applySeekRestriction(em, criteriaQuery, attributePath);  Добавление
TypedQuery<T> query = em.createQuery(criteriaQuery);
ограничений
if (getSize() != -1)  Установка количества результатов
query.setMaxResults(getSize());
return query;
}
// ...
}
 В дополнение к обычному атрибуту сортировки методу поиска нужно передать атрибут,
представляющий уникальный ключ. Это может быть любой уникальный атрибут моде-
ли сущности, но обычно выбирается атрибут первичного ключа.
 Для обоих атрибутов – сортировки и уникального ключа – нужно запомнить их значе-
ния на «предыдущей» странице. После этого можно будет извлечь данные для следующей
страницы, выполнив поиск этих значений. Подойдет любой тип, реализующий ин-
терфейс Comparable, как того требуют запросы на основе критериев.
 Результаты всегда должны сортироваться по атрибуту сортировки и атрибуту уникаль-
ного ключа.
 Нужно добавить дополнительные ограничения (не показанные здесь) в предложение
WHERE, чтобы поиск начинался после последних сохраненных значений.
 Нужно отсечь лишние результаты, согласно размеру страницы.
Целиком метод applySeekRestriction() можно найти в коде примеров; это код
запроса на основе критериев, для которого здесь не нашлось места. Итоговый за-
прос эквивалентен версии SQL, показанной ранее.
Давайте протестируем новую функциональность уровня хранения для постра-
ничной выборки.
Поиск границ страницы в методе поиска
Ранее мы говорили, что будет непросто реализовать в методе поиска переход
к конкретной странице, поскольку для конкретной страницы неизвестны послед-
ние значения для поиска. Но эти значения можно найти с помощью выражения
SQL, как показано ниже:
576  Создание веб-приложений
select i.NAME, i.ID
from ITEM i
where
(select count(i2.*)
from ITEM i2
where (i2.NAME, i2.ID) <= (i.NAME, i.ID)
) % :pageSizeParameter = 0
order by i.NAME asc, i.ID asc
Этот запрос применяет оператор деления по модулю (%) для получения всех пар (NAME,
ID), находящихся на границах страниц: они являются последними значениями на каж-
дой странице. Аналогичный запрос на основе критериев показан в коде примеров.
19.2.3. Постраничная выборка
Теперь, вызывая метод ItemDAO#getItemBidSummaries(), вы должны передать экзем-
пляр Page. Служба или пользовательский интерфейс, находящиеся выше уровня
хранения, выполнят следующий код:
Файл: /apps/app-web/src/test/java/org/jpwh/test/service/PagingTest.java
OffsetPage page = new OffsetPage(
3, Размер страницы
itemDAO.getCount(), Количество всех записей
Item_.name, ASC, Атрибут сортировки и ее направление по умолчанию
Item_.name, Item_.auctionEnd, Item_.maxBidAmount
);
List<ItemBidSummary> result = itemDAO.getItemBidSummaries(page);
Перейти к следующей странице очень просто – нужно лишь указать ее номер:
page.setCurrent(2);
result = itemDAO.getItemBidSummaries(page);
Методу поиска потребуется больше информации. Сначала нужно создать эк-
земпляр SeekPage с дополнительным уникальным атрибутом:
Файл: /apps/app-web/src/test/java/org/jpwh/test/service/PagingTest.java
SeekPage page = new SeekPage(
3,
itemDAO.getCount(),
Item_.name, ASC,
Item_.id, Дополнительный уникальный атрибут для поиска и упорядочения
Item_.name, Item_.auctionEnd, Item_.maxBidAmount
);
List<ItemBidSummary> result = itemDAO.getItemBidSummaries(page);
Чтобы перейти к конкретной странице в методе смещений, нужно знать лишь
номер страницы. Для стратегии поиска необходимо запоминать показанные на
предыдущей странице значения:
Все доступные для сортировки атрибуты
для данной страницы
Создание JSF-приложений  577
ItemBidSummary lastShownOnPreviousPage = // ...
page.setLastValue(lastShownOnPreviousPage.getName());
page.setLastUniqueValue(lastShownOnPreviousPage.getItemId());
result = itemDAO.getItemBidSummaries(page);
Очевидно, это требует от клиента уровня хранения большего количества рабо-
ты. Вместо простого числа он должен запоминать последние значения атрибута
сортировки и уникального ключа.
Пользовательские интерфейсы, которые вы видели на снимках экрана, выпол-
нены с помощью JSF и CDI и содержат необходимый код для взаимодействия
с реализацией постраничной выборки. Пусть код примеров вдохновит вас на ин-
теграцию постраничной выборки с вашими службами и пользовательскими ин-
терфейсами.
Даже если не использовать JSF, все равно можно очень просто адаптировать
решение для сортировки и постраничной выборки к другим фреймворкам веб-
приложений. Если же вы намерены использовать JSF, следующий раздел как раз
для вас: мы рассмотрим сложные варианты использования, такие как размещение
ставки и редактирование информации о товаре, реализованные с помощью веб-
интерфейса JSF поверх уровня службы с состоянием.
19.3. Создание JSF-приложений
В предыдущем примере можно было щелкнуть на названии товара в каталоге. Это
действие открывает страницу с более детальной информацией о товаре, как по-
казано на рис. 19.3.
Рис. 19.3  Просмотр данных о товаре
и размещение ставки
578  Создание веб-приложений
В странице с описанием товара имеется форма, позволяющая сделать ставку.
Это будет первый вариант использования, который мы реализуем: размещение
ставки за товар. Для этого можно использовать простую службу с областью види-
мости запроса.
19.3.1. Службы с областью видимости запроса
Начнем с рассмотрения важного фрагмента шаблона XHTML для этой страницы:
Файл: /apps/app-web/src/main/webapp/auction.xhtml
<f:metadata>
<f:viewParam name="id" value="#{auctionService.id}"/>
</f:metadata>
Эту страницу можно добавить в закладки, т. е. она может и будет вызывать-
ся с параметром запроса – идентификатором товара Item. Благодаря метаданным
шаблон JSF свяжет значение параметра с полем id экземпляра AuctionService на
стороне сервера. Мы реализуем эту службу чуть ниже.
На странице нужно отобразить некоторую информацию о товаре, запросив ее
у службы AuctionService:
Файл: /apps/app-web/src/main/webapp/auction.xhtml
<h:outputText value="Auction End:"/>
<h:outputText value="#{auctionService.item.auctionEnd}">
<f:convertDateTime pattern="dd. MMM yyyy HH:mm"/>
</h:outputText>
<h:outputText value="Starting Price:"/>
<h:outputText value="#{auctionService.item.initialPrice}"/>
Отображение этих данных потребует повторного вызова метода AuctionService#
getItem(); не забудьте об этом во время реализации службы. Наконец, ниже
показана форма размещения ставки:
Файл: /apps/app-web/src/main/webapp/auction.xhtml
<h:form>
<h:inputHidden value="#{auctionService.id}"/>  Посылает идентификатор
<h:inputText value="#{auctionService.newBidAmount}"
size="6"/>  Задает значение ставки
<h:commandButton value="Place Bid"
action="#{auctionService.placeBid}"/> Размещает ставку
</h:form>
 Вместе с формой нужно также передать идентификатор товара. Служба на стороне сер-
вера действует в области видимости запроса, поэтому его экземпляр будет создаваться
для каждого запроса отдельно: этот код вызовет метод AuctionService#setId().
 Введенное значение ставки JSF установит с помощью метода AuctionService#setNewBidA
mount(), когда будут обработаны параметры POST-запроса с формой.
Создание JSF-приложений  579
 После связывания всех значений будет вызван метод AuctionService#placeBid(), указан-
ный в атрибуте action формы.
Теперь рассмотрим класс службы, который является обычным компонентом,
управляемым механизмом CDI:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/AuctionService.java
@Named
@RequestScoped  Не нужно хранить состояния
public class AuctionService {
@Inject
ItemDAO itemDAO;
@Inject
BidDAO bidDAO;
long id;  Определение состояния
Item item;
BigDecimal highestBidAmount;
BigDecimal newBidAmount;
// ...
}
 В данном варианте использования не потребуется сохранять состояние между запро-
сами. Экземпляр службы будет создан после отображения страницы аукциона GET-
запросом, а JSF свяжет параметр запроса, вызвав метод setId(). Экземпляр службы бу-
дет уничтожен по окончании отображения. В промежутке между запросами сервер не
будет хранить никаких данных. После отправки формы и начала обработки POST-запроса
JSF вызовет setId(), чтобы связать скрытое поле формы, и вы сможете заново инициа-
лизировать состояние службы.
 Состояние, сохраняемое между запросами, – это значение идентификатора экземпляра
Item, с которым работает пользователь, сам экземпляр Item после загрузки, текущая мак-
симальная ставка за этот товар и новая ставка, введенная пользователем.
Не забывайте, что в JSF любой метод доступа к свойству, указанный в шаблоне
XHTML, может вызываться несколько раз. В службе AuctionService данные бу-
дут загружаться при вызове методов доступа, поэтому вы должны предотвратить
многократное обращение к базе данных по неосторожности:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/AuctionService.java
public class AuctionService {
public void setId(long id) {
this.id = id;
if (item == null) {
item = itemDAO.findById(id);
if (item == null)
throw new EntityNotFoundException();
580  Создание веб-приложений
highestBidAmount = itemDAO.getMaxBidAmount(item);
}
}
// Прочие методы чтения/записи...
}
Когда JSF вызовет setId() в первый раз, вы загрузите экземпляр Item с данным
идентификатором только один раз. Если экземпляр сущности не найден, завер-
шайте работу с ошибкой. Для полной инициализации состояния службы перед
отображением данных дополнительно загружается максимальная ставка или вы-
зывается метод действия.
Обратите внимание, что метод выполняется вне транзакции! В отличие от ме-
тодов EJB, простому компоненту CDI транзакция не требуется. Объект EntityManager
и контекст хранения, используемый в DAO, рассинхронизированы, и данные
читаются из базы в режиме автоматического подтверждения (auto-commit). Даже
если позднее, продолжая обрабатывать тот же запрос, вызвать транзакционный
метод, будет использован тот же самый рассинхронизированный EntityManager
в области видимости запроса.
Таким транзакционным методом является placeBid():
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/AuctionService.java
public class AuctionService {
// ...
@Transactional  Поместит этот метод в контекст транзакции
public String placeBid() {
itemDAO.joinTransaction();  Сохранение ставки
if (!getItem().isValidBidAmount(  Сравнение с максимальной ставкой
getHighestBidAmount(),
getNewBidAmount()
)) {
ValidationMessages.addFacesMessage("Auction.bid.TooLow");
return null;
}
itemDAO.checkVersion(getItem(), true);  Принудительное увеличение номера версии
bidDAO.makePersistent(new Bid(getNewBidAmount(), getItem()));
return "auction?id=" + getId() + "&faces-redirect=true";  Перенаправление
}
}
 Аннотация @Transactional появилась в Java EE 7 (в версии JTA 1.2) и выполняет ту же
функцию, что и аннотация @TransactionAttribute в компонентах EJB. Определяемый ею
перехватчик поместит метод в контекст системной транзакции, по аналогии с методами
EJB.
Создание JSF-приложений  581
 Выполнение действий в рамках транзакции и сохранение новой ставки в базу дан-
ных для предотвращения состояния гонки. Контекст хранения следует присоединить
к транзакции.
Не имеет значения, какой экземпляр DAO вызывается: они все использу-
ют общий экземпляр EntityManager в области видимости запроса.
 Если, пока пользователь раздумывает, глядя на страницу, будет подтверждена другая
транзакция, с более высокой ставкой, выполнение завершится с ошибкой, и страница
аукциона будет показана заново с сообщением об ошибке.
 Для предотвращения состояния гонки необходимо также принудительно увеличить но-
мер версии экземпляра Item перед выталкиванием контекста хранения. Если параллель-
но будет выполняться другая транзакция, которая загрузит из базы тот же экземпляр
Item с такой же версией и текущей максимальной ставкой в методе setId(), одна из них
завершится с ошибкой в методе placeBid().
 Это простое перенаправление после обработки POST-запроса в JSF, чтобы пользователи
могли безопасно загрузить страницу после сохранения ставки.
После выхода из метода placeBid() транзакция подтверждается, а присоеди-
ненный контекст хранения автоматически выталкивает изменения в базу данных.
В Java EE 7, наконец, стала доступна удобная возможность EJB: декларативное
описание границ транзакций, независимое от EJB.
Другой особенностью Java EE является область видимости диалога в CDI с воз-
можностью интеграции с JSF.
19.3.2. Службы с областью видимости диалога
В Java EE можно отмечать компоненты и создаваемые экземпляры аннотацией
@ConversationScoped, задавая область видимости диалога. Эта особая область ви-
димости управляется вручную с помощью стандартного интерфейса javax.enterprise.
context.Conversation. Чтобы понять, как работает область видимости диа-
лога, мы советуем поразмышлять над примерами из предыдущей главы.
Самым коротким диалоговым взаимодействием (единицей работы с точки зре-
ния пользователя приложения) является простой цикл запрос/ответ. Пользова-
тель отправляет запрос, а сервер создает контекст диалога для хранения данных
этого запроса. После отправки ответа это кратковременное диалоговое взаимодей-
ствие завершится и будет закрыто. То есть область видимости временного диало-
гового взаимодействия тождественна области видимости запроса; оба контекста
имеют одинаковый жизненный цикл. Именно так спецификация CDI связыва-
ет область видимости диалога с запросом сервлета и, следовательно, с запросами
в JSF и JAX-RS.
С помощью интерфейса Conversation можно продлить время жизни диалого-
вого взаимодействия на сервере, и оно уже не будет временным. Если диалоговое
взаимодействие продлить во время обработки запроса, во время следующего за-
проса можно будет задействовать тот же контекст диалогового взаимодействия
и использовать его для передачи данных между запросами. Обычно для этого при-
меняется контекст сеанса, но в этом случае приходится вручную разделять парал-
лельные диалоговые взаимодействия (например, когда пользователь открыл две
вкладки браузера). Как раз для преодоления этих сложностей был создан контекст
582  Создание веб-приложений
диалога, автоматически изолирующий данные в управляемом контексте, который
гораздо удобнее обычного контекста сеанса.
Контекст диалога реализован на стороне сервера с помощью сеанса и хранит
свои данные в пользовательском сеансе. Для изоляции и идентификации диа-
логовых взаимодействий внутри сеанса каждому из них присваивается иденти-
фикатор – его значение нужно отправлять с каждым запросом. Для этих целей
даже был стандартизован параметр cid. Каждое диалоговое взаимодействие имеет
также собственное время ожидания, чтобы сервер мог освободить ресурсы, если
пользователь перестанет присылать запросы. Это позволяет серверу автоматиче-
ски очищать устаревшие диалоги, не дожидаясь, пока истечет время жизни сеанса.
ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ:
А что насчет области видимости потока в JSF?
Область видимости потока (flow scope) была добавлена в последних версиях JSF
и напоминает область видимости диалога CDI. Она отвечает за группировку и об-
наружение шаблонов представления в рамках последовательности действий,
а также за автоматизацию правил навигации в этой последовательности. Ее так-
же можно использовать для передачи состояния между запросами. К сожалению,
время ожидания в рамках сеанса для контекста потока не определено; также от-
сутствует API для удаления или продления жизни контекста. Мы считаем контекст
потока непригодным к использованию в его текущей реализации, за исключением
простейших вариантов использования, в которых избыточное потребление ре-
сурсов на сервере не играет роли. Мы надеемся, что в будущих версиях Java EE
функциональность диалоговых взаимодействий CDI и контекстов потока JSF будет
согласована и объединит сильные стороны обеих.
Другой приятной особенностью контекста длительных (не временных) диало-
говых взаимодействий является автоматическая защита от параллельного доступа
на стороне сервера: если пользователь быстро нажмет кнопку несколько раз под-
ряд, где каждый запрос будет содержать значение идентификатора конкретного
диалогового взаимодействия, сервер прекратит обработку всех запросов, кроме
одного, возбудив исключение BusyConversationException.
Сейчас мы рассмотрим пример использования области видимости диалога
в JSF. Мы реализуем вариант использования с последовательностью действий,
требующей нескольких запросов для завершения: выставление товара на аукцион.
Последовательность действий «редактирование информации
о товаре»
Немного поразмыслив, можно заметить, что создание и редактирование ин-
формации о товаре – очень похожие задачи. Эти последовательности действий
являются диалоговыми взаимодействиями – единицами работы с точки зрения
пользователя приложения, поэтому пользователь ожидает, что и выглядеть они
будут похоже. Соответственно, мы постараемся не допустить дублирования кода;
Создание JSF-приложений  583
реализуем оба варианта использования с помощью одного пользовательского ин-
терфейса и одной службы на стороне сервера. Приложение должно направлять
пользователя через последовательность действий; на рис. 19.4 показана диаграмма
состояний этой последовательности.
Рис. 19.4  Последовательность действий
в диалоговом взаимодействии по редактированию товара
Расшифруем ее. Пользователь может начать диалоговое взаимодействие без
всяких данных, если товар отсутствует. С другой стороны, пользователь может
иметь идентификатор существующего товара, который, скорее всего, будет обыч-
ным числом. Не важно, как пользователь узнал этот идентификатор; возможно,
он выполнил поиск в предыдущем диалоговом взаимодействии. Это распростра-
ненный сценарий, и, как многие последовательности диалоговых взаимодействий,
он имеет несколько точек входа (закрашенные кружки на диаграмме состояний).
С точки зрения пользователя редактирование товара представляет собой мно-
гошаговый процесс: каждый прямоугольник с закругленными краями представля-
ет состояние приложения. В состоянии редактирования товара приложение пока-
зывает пользователю диалог или форму, где пользователь может менять описание
товара или начальную цену. Тем временем приложение будет ждать событий от
пользователя; мы называем это временем раздумий пользователя.
После того как от пользователя поступит событие «Далее», приложение обрабо-
тает его, а пользователь перейдет к следующему состоянию (ожидания) – редакти-
рованию изображений. По завершении редактирования изображений товара поль-
зователь завершает диалоговое взаимодействие, отправляя товар и его изображения
на сервер (обведенный закрашенный круг). Нажатие кнопки Cancel (Отмена) на
любой странице завершает взаимодействие. С точки зрения пользователя прило-
жения все диалоговое взаимодействие целиком является атомарной единицей: после
нажатия кнопки Submit (Отправить) все изменения будут сохранены. Никакой
другой переход между состояниями не должен сохранять изменений в базу данных.
Мы реализуем эту последовательность в стиле мастера редактирования, состоящего
из двух веб-страниц. На первой странице (рис. 19.5) пользователь будет вво-
дить или редактировать описание товара.
584  Создание веб-приложений
Рис. 19.5  Первая страница
мастера редактирования информации о товаре
Обратите внимание, что отображение этой страницы не создает контекста дли-
тельного диалогового взаимодействия на сервере. Это была бы напрасная трата
ресурсов, поскольку еще неизвестно, захочет ли пользователь изменить инфор-
мацию о товаре. Создание контекста длительного диалогового взаимодействия
и передача данных между запросами произойдут после первого нажатия кнопки
Next (Далее). Если проверка формы пройдет успешно, сервер сохранит данные
диалогового взаимодействия в сеансе пользователя и направит его на страницу
редактирования изображения (рис. 19.6).
Рис. 19.6  Вторая страница
мастера для редактирования изображений товара
Единица работы закончится, когда пользователь отправит данные о товаре после
выгрузки изображений. Пользователь может в любой момент нажать на кнопку
Cancel (Отмена) и завершить взаимодействие или отойти от терминала, из-за чего
диалоговое взаимодействие завершится после определенного времени ожидания.
Пользователь может работать в нескольких вкладках браузера параллельно, за-
пуская сразу несколько диалоговых взаимодействий; следовательно, в сеансе
пользователя на сервере они должны быть изолированы. Все данные диалогового
взаимодействия будут удалены, если время жизни сеанса пользователя превысит
время ожидания (или сервер кластера с привязанным сеансом отключится).
В шаблонах XHTML для этого мастера нет никакой специальной разметки, от-
носящейся к диалоговому взаимодействию; оно автоматизируется с помощью JSF
и CDI. Если во время отображения формы обнаружится контекст длительного
Создание JSF-приложений  585
диалогового взаимодействия, его идентификатор будет автоматически отправлен
вместе с данными формы JSF в виде значения скрытого поля. В JSF это работает
даже для перенаправлений; параметр cid будет автоматически добавляться к URL
назначения перенаправления.
Служба с областью видимости диалога связана с этими страницами на сторо-
не сервера; все действия происходят в службе EditItemService, как и управление
контекстом.
Контекст хранения в диалоговом взаимодействии
Служба EditItemService обеспечивает работу мастера и весь рабочий процесс на
стороне сервера:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/EditItemService.java
@Named
@ConversationScoped  Поведение соответствует области видимости запроса
public class EditItemService implements Serializable {  Должен быть сериализуемым
@Inject  Может быть сериализован
ItemDAO itemDAO;
@Inject
ImageDAO imageDAO;
// ...
@Inject  Вызов Conversation API
Conversation conversation;
Long itemId;  Состояние службы
Item item = new Item();
transient Part imageUploadPart;  Временное состояние службы
public void setItemId(Long itemId) {  Загрузка товара
this.itemId = itemId;
if (item.getId() == null && itemId != null) {
item = itemDAO.findById(itemId);  Извлечение товаров из базы данных
if (item == null)
throw new EntityNotFoundException();
}
}
// ...
}
 Экземпляр службы находится в области видимости диалога. Диалоговый контекст яв-
ляется по умолчанию временным, поэтому служба ведет себя, как если бы находилась
в области видимости запроса.
 В отличие от версии с областью видимости запроса, здесь служба должна реализовать
интерфейс Serializable. Экземпляр EditItemService может быть сохранен в сеансе HTTP,
а этот сеанс может быть сериализован и записан на диск или отправлен по сети кластера.
586  Создание веб-приложений
В главе 18 мы пошли по легкому пути, используя компонент EJB с состоянием, сказав:
«Пассивирование для данного компонента недоступно». Все, что находится в области
видимости диалогового взаимодействия CDI, должно иметь возможность пассивирова-
ния, а следовательно, поддерживать сериализацию.
 Внедренные экземпляры DAO обладают зависимой областью видимости и также яв-
ляются сериализуемыми. Может показаться, что это не так, поскольку каждый из них
имеет поле типа EntityManager, который нельзя сериализовать. Через мгновение мы раз-
беремся с этим нюансом.
 Реализация Conversation API будет предоставлена контейнером. Он необходим для управ-
ления контекстом диалога и понадобится нам, когда пользователь первый раз нажмет
кнопку Next (Далее) и временный контекст нужно будет сделать продолжительным.
 Это состояние службы: товар, редактируемый пользователем на страницах мастера. Ра-
бота начинается с нового экземпляра сущности Item во временном состоянии. Если эта
служба инициализируется значением идентификатора, экземпляр Item будет загружен
в методе setItemId().
 А это временное состояние службы. Оно нужно лишь ненадолго, когда пользователь
нажмет кнопку Upload (Выгрузить) на странице редактирования изображений товара.
Класс Part из спецификации Servlet API не сериализуется. В службах области видимо-
сти диалога часто можно увидеть временное состояние, но его следует инициализиро-
вать в каждом запросе, если оно необходимо.
 Метод setItemId() вызывается, только если в запросе передан идентификатор товара.
Следовательно, это диалоговое взаимодействие имеет две точки входа: с использовани-
ем идентификатора товара и без.
 Если пользователь редактирует информацию о товаре, нужно загрузить ее из базы дан-
ных. Нам по-прежнему приходится полагаться на контекст хранения из области видимо-
сти запроса, поэтому, как только обработка запроса закончится, экземпляр Item окажет-
ся в отсоединенном состоянии. Можно хранить отсоединенные экземпляры сущностей
в виде состояния службы области видимости диалога, выполняя слияние, когда потре-
буется сохранить изменения в базу данных (см. раздел 10.3.4).
В отличие от компонентов EJB с состоянием, в данном случае нельзя отклю-
чить пассивирование контекста диалога. Спецификация CDI требует, чтобы класс
и все зависимости компонента области видимости диалога, не являющиеся вре-
менными, поддерживали сериализацию. На самом деле вы получите ошибку раз-
вертывания, если нечаянно поместите в область видимости диалога объект, кото-
рый нельзя сериализовать.
Для обхода этой проверки мы сказали выше, что GenericDAO реализует java.
io.Serializable. Но поле EntityManager класса GenericDAOImpl не сериализуется!
Однако этот код работает, потому что CDI использует контекстные ссылки – «ум-
ные» объекты-заменители.
Во время выполнения поле типа EntityManager в классе DAO не является подлин-
ным экземпляром контекста хранения. Оно ссылается на некоторый объект EntityManager
– некоторый текущий контекст хранения. Не забывайте, что CDI создаст
и внедрит зависимость через конструктор. Но, поскольку она объявлена в области
видимости запроса, во время выполнения вместо нее будет внедрен специальный
прокси-объект, который выглядит как настоящий EntityManager. Прокси-объект
Создание JSF-приложений  587
будет перенаправлять все вызовы настоящему объекту EntityManager, который он
найдет в контексте текущего запроса. Прокси-объект является сериализуемым и не
сохраняет ссылку на экземпляр EntityManager после окончания обработки запроса.
Затем он может быть запросто сериализован; во время десериализации (возможно,
в другой виртуальной машине JVM) он продолжит выполнять свою работу и, когда
потребуется, найдет экземпляр EntityManager в контексте запроса. Следовательно,
контекст хранения не будет сериализован целиком, а только прокси-объект, кото-
рый сможет найти контекст хранения в текущем контексте запроса.
На первый взгляд, это может показаться странным, но так работает CDI: если
компонент в области видимости запроса будет внедрен в контекст диалога, сеанса
или приложения, он использует косвенную ссылку. Если попробовать обратиться
к прокси-объекту EntityManager через DAO, в отсутствие активного контекста за-
проса (например, в методе сервлета init()), возникнет исключение ContextNotActiveException,
поскольку прокси-объект не сможет получить текущего экземпля-
ра EntityManager. Спецификация CDI также говорит, что такие прокси-объекты
могут подвергаться пассивированию (сериализации), даже если представляемый
ими компонент не обладает подобной возможностью.
Предположим, что пользователь заполнил форму с данными о товаре на первой
странице мастера, а затем нажал кнопку Next (Далее). В этот момент важно не по-
терять временного контекста диалога, превратив его в длительный контекст.
Создание длительных диалоговых взаимодействий
Нажатие кнопки Next (Далее) на странице мастера отправит форму с данными
объекта Item на сервер, и пользователь увидит страницу редактирования изобра-
жений. Поскольку служба EditItemService находится во временном контексте диа-
логового взаимодействия, обработка запроса начнется в новом временном контек-
сте. Помните, что временный контекст диалогового взаимодействия – это аналог
контекста запроса.
При обработке запроса необходимо настроить текущий временный контекст
диалога с помощью Conversation API:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/EditItemService.java
public class EditItemService implements Serializable {
// ...
public String editImages() {
if (conversation.isTransient()) {
conversation.setTimeout(10 * 60 * 1000); 10 минут
conversation.begin();
}
return "editItemImages";
}
// ...
}
588  Создание веб-приложений
Метод действия будет вызван после сохранения экземпляра Item в поле EditItemService#
item механизмом JSF. Чтобы сделать временное диалоговое взаимо-
действие длительным, нужно установить для него время ожидания. Очевидно, это
время меньше либо равно времени жизни сеанса пользователя; большие значения
не имеют смысла. Сервер сохранит состояние службы в сеансе пользователя и ав-
томатически отобразит сгенерированный идентификатор диалогового взаимодей-
ствия в виде скрытого поля на странице редактирования изображений. Если по-
требуется, значение идентификатора взаимодействия можно получить с помощью
метода Conversation#getId(). Вы даже можете установить собственное значение
идентификатора с помощью метода Conversation#begin().
Теперь сервер будет ждать следующего запроса с идентификатором диалогового
взаимодействия, возможно отправленного со страницы редактирования изображений.
Если ожидание продлится слишком долго из-за того, что у длительного
диалогового взаимодействия или сеанса истекло время жизни, во время запроса
будет возбуждено исключение NonexistentConversationException.
Если пользователь захочет загрузить изображение товара, следующий запрос
вызовет соответствующий метод службы:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/EditItemService.java
public class EditItemService implements Serializable {
// ...
public void uploadImage() throws Exception {
if (imageUploadPart == null)
return;
Image image =  Создание экземпляра
imageDAO.hydrateImage(imageUploadPart.getInputStream());
image.setName(imageUploadPart.getSubmittedFileName());
image.setContentType(imageUploadPart.getContentType());
image.setItem(item);  Добавление временного объекта Image
item.getImages().add(image);
}
// ...
}
 Создание экземпляра сущности Image из составных данных формы.
 Нужно добавить временный экземпляр Image в коллекцию изображений временного или
отсоединенного экземпляра товара Item. Это диалоговое взаимодействие будет потреблять
все больше и больше памяти на сервере, по мере добавления выгружаемых изобра-
жений в состояние диалогового взаимодействия и, следовательно, в сеанс пользователя.
Наиболее важными аспектами построения серверной системы с сохранением
состояния являются количество потребляемой памяти и максимальное количество
одновременно обрабатываемых пользовательских сеансов. С данными диало-
Создание JSF-приложений  589
гового взаимодействия нужно обращаться осторожно. Всегда следует подумать,
стоит ли сохранять данные, полученные от пользователя или из базы данных, в те-
чение всего времени жизни диалогового взаимодействия.
Когда пользователь нажимает кнопку Submit (Отправить), диалоговое взаимо-
действие завершается, а все временные и отсоединенные экземпляры сущностей
должны быть сохранены.
Завершение длительных диалоговых взаимодействий
Последовательность действий в диалоговом взаимодействии закончится, ког-
да будет сохранен временный или отсоединенный экземпляр Item со всеми его
изображениями:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/EditItemService.java
public class EditItemService implements Serializable {
// ...
@Transactional  Обертывает вызов метода
public String submitItem() {
itemDAO.joinTransaction();  Присоединяет контекст хранения к транзакции
// ...
item = itemDAO.makePersistent(item);  Делает экземпляр Item хранимым
if (!conversation.isTransient())  Завершение диалогового взаимодействия
conversation.end();
return "auction?id=" + item.getId() + "&faces-redirect=true";
}
// ...
}
 Вызов метода будет обернут системным перехватчиком транзакций.
 Чтобы сохранить данные, нужно присоединить рассинхронизированный контекст хра-
нения из области видимости запроса к системной транзакции.
 Этот вызов DAO сохранит временный или отсоединенный экземпляр Item. Поскольку
в аннотации @OneToMany описано правило каскадной передачи состояния, также будет
сохранена коллекция временных или отсоединенных элементов Item#images. В соответ-
ствии с контрактом DAO в качестве текущего состояния следует использовать возвра-
щаемый экземпляр.
 Завершение продолжительного диалогового взаимодействия вручную. Фактически это
понижение статуса: продолжительное взаимодействие становится временным. После
окончания обработки запроса контекст взаимодействия будет разрушен вместе с экзем-
пляром службы. Состояние диалогового взаимодействия будет удалено из сеанса поль-
зователя.
 Пользователь будет перенаправлен на страницу с описанием товара после обработки
POST-запроса с помощью JSF; также будет отправлен идентификатор сохраненного эк-
земпляра Item.
 Перенаправление
590  Создание веб-приложений
Кроме того, пользователь может в любой момент нажать кнопку Cancel (От-
мена), чтобы закрыть мастера:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jsf/EditItemService.java
public class EditItemService implements Serializable {
// ...
public String cancel() {
if (!conversation.isTransient())
conversation.end();
return "catalog?faces-redirect=true";
}
// ...
}
На этом мы заканчиваем пример реализации службы с состоянием, использующей
JSF, CDI и уровень хранения на основе JPA. По нашему мнению, JSF и CDI
отлично сочетаются с JPA; вы получаете хорошо протестированную и стандар-
тизованную модель программирования, требующую небольших затрат ресурсов
и количества строк кода.
Далее мы продолжим использовать CDI, но вместо JSF будем работать с архи-
тектурой службы без состояния на основе JAX-RS и JPA, подходящей для любого
толстого клиента. Одной из трудностей этой архитектуры является сериализация
данных.
19.4. Сериализация данных предметной модели
Когда в разделе 3.2.3 мы впервые обсуждали создание классов с возможностью
длительного хранения, то вкратце упомянули, что они не обязаны реализовать ин-
терфейс java.io.Serializable. Этот интерфейс-маркер можно использовать, толь-
ко когда он действительно необходим.
Один из таких вариантов был показан в главе 18. Экземпляры предметной мо-
дели передавались между EJB-системами клиента и сервера, подвергаясь авто-
матической сериализации в некоторый формат передачи данных на одном конце
и десериализации на другом. Все это работало без сучка и задоринки, поскольку
и клиент, и сервер были виртуальными машинами Java, библиотеки Hibernate
были доступны в обеих системах. Клиент использовал удаленный вызов проце-
дур (Remote Method Invocation, RMI) и стандартный формат сериализации Java
(поток байтов, представляющий объекты Java).
Если ваш клиент не использует виртуальную машину Java, вам вряд ли захо-
чется получать поток байтов, представляющий объекты Java на сервере. Распро-
странен сценарий, где сервер без состояния обеспечивает работу толстого клиента,
такого как приложение JavaScript, работающее в веб-браузере, или мобильное при-
ложение. Обычно для такого сценария нужно реализовать на сервере интерфейс
Web API, использующий HTTP для передачи данных в формате XML или JSON,
Сериализация данных предметной модели  591
которые клиент должен будет анализировать. Клиент также будет посылать дан-
ные в формате XML или JSON, когда нужно будет сохранить данные на сервере,
поэтому сервер должен уметь производить и потреблять данные в этих форматах.
Проектирование REST-приложений на основе гипермедиа
Приложение, обменивающееся данными в формате XML или JSON, многие называют
системой в стиле REST. Но наиболее важным аспектом архитектуры с передачей со-
стояния представления (REST) является обмен гипермедиадокументами между кли-
ентом и сервером. Гипермедиадокументы содержат данные и возможные действия
с этими данными: отсюда происходит название «Гипермедиа как механизм передачи
состояния приложения» (Hypermedia As The Engine Of Application State, HATEOAS). По-
скольку эта книга о Hibernate, а не о проектировании Web API, то мы покажем лишь,
как создать простой интерфейс HTTP, обменивающийся обычными документами
XML, который не использует гипермедиа и не спроектирован в стиле REST.
При проектировании своего API обратите внимание на H-фактор выбранного фор-
мата данных (см. http://amundsen.com/hypermedia/hfactor/) и прочтите замечатель-
ную книгу RESTful Web APIs (Richardson, 2013) Леонарда Ричардсона (Leonard Richardson),
Майка Амундсена (Mike Amundsen) и Сэма Руби (Sam Ruby). Мы советуем
избегать формата JSON, поскольку для улучшения своего H-фактора он требует
использования нестандартных расширений.
Создание собственного гипермедиаформата на основе XML (возможно, путем
расширения примера, показанного в этой главе) – тоже не лучшее решение. Мы
предпочитаем обычный XHTML: у него отличный H-фактор, его легко писать и чи-
тать с помощью повсеместно доступных API. При сжатии он по своей эффектив-
ности может превзойти JSON; а во время разработки и тестирования с ним очень
приятно работать интерактивно. Джон Мур (Jon Moore) предоставил прекрасный
пример такого решения в статье «Building Hypermedia APIs with HTML» (www.infoq.
com/presentations/web-api-html).
Сейчас мы напишем HTTP-сервер на основе фреймворка JAX-RS, который бу-
дет производить и потреблять документы XML. Хотя в примерах используется
XML, они могут быть реализованы и с применением JSON, а фундаментальные
проблемы, которые мы обсудим, будут в обоих случаях одинаковыми.
19.4.1. Создание JAX-RS-службы
Приступим к созданию службы JAX-RS. Один из ее методов будет отправлять до-
кументы XML, представляющие экземпляры сущностей Item, когда пользователь
будет присылать HTTP-запрос GET. Другой метод будет принимать документ XML
для обновления экземпляра Item запросом PUT:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jaxrs/ItemService.java
@Path("/item")  Путь для запроса
public class ItemService {
@Inject
ItemDAO itemDAO;
592  Создание веб-приложений
@GET  Запрос GET
@Path("{id}")  Аргумент вызова
@Produces(APPLICATION_XML)  Сериализует данные в XML
public Item get(@PathParam("id") Long id) {
Item item = itemDAO.findById(id);
if (item == null)
throw new WebApplicationException(NOT_FOUND);
return item;
}
@PUT
@Path("{id}")
@Consumes(APPLICATION_XML)  Десериализация XML
@Transactional  Начало транзакции
public void put(@PathParam("id") Long id, Item item) {
itemDAO.joinTransaction();
itemDAO.makePersistent(item);
}
// ...
}
 Когда сервер получает запрос, путь в котором начинается с /item, он будет обработан ме-
тодом этой службы. По умолчанию экземпляр службы находится в области видимости
запроса, но вы можете использовать аннотации CDI, чтобы изменить это.
 HTTP-запрос GET обрабатывается этим методом.
 Контейнер передаст методу сегмент после /item, как, например, /item/123. Он отобража-
ется как параметр метода при помощи аннотации @PathParam.
 Этот метод возвращает данные в формате XML; следовательно, кто-то должен сериали-
зовать возвращаемое значение в XML. Будьте бдительны: эта аннотация не то же самое,
что аннотация продюсера в CDI. Она из другого пакета!
 Этот метод принимает данные в формате XML: следовательно, кто-то должен десериа-
лизовать XML-документ и преобразовать его в отсоединенный экземпляр Item.
 Поскольку этот метод сохраняет данные, нужно запустить системную транзакцию, при-
соединив к ней контекст хранения.
Стандарт JAX-RS описывает автоматическое преобразование (marshalling) для
большинства важных видов информации и целого набора типов Java. К приме-
ру, реализация JAX-RS должна уметь производить и потреблять XML-документы
для классов, созданных с применением Java-архитектуры для связывания с XML
(JAXB). Следовательно, класс сущности Item из модели предметной области дол-
жен стать классом JAXB.