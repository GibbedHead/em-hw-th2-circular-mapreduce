Подвох, которого нужно остерегаться, заключается в использовании встроен-
ного свойства, имеющего тип абстрактного суперкласса (такого как Measurement),
в классе сущности (таком как Item). Это никогда не будет работать; реализация JPA
не знает, как полиморфно сохранять и загружать экземпляры Measurement. У него
нет необходимой информации, чтобы решить, принадлежат ли экземпляры в базе
данных классу Dimension или Weight, поскольку селектор отсутствует. Это значит,
168  Отображение наследования
что хотя встраиваемый (@Embeddable) класс может наследовать хранимые поля от
класса с аннотацией @MappedSuperclass, ссылка на экземпляр не может быть поли-
морфной – в качестве ее типа должен выступать конкретный класс.
ID << PK >>
NAME
...
DIMENSIONS_NAME
DIMENSIONS_SYMBOL
DEPTH
HEIGHT
WIDTH
WEIGHT_NAME
WEIGHT_SYMBOL
WEIGHT
<< Table >>
ITEM
name : String
symbol : String
Measurement
depth : BigDecimal
height : BigDecimal
width : BigDecimal
Dimensions
value : BigDecimal
Weight
name : String
...
Item
Рис. 6.5  Отображение конкретных встраиваемых классов
с унаследованными полями
Сравните такой подход с альтернативной стратегией наследования для встраиваемых
классов, показанной в разделе «Преобразование значений полей компо-
нентов» в главе 5, которая поддерживает полиморфизм, но требует писать допол-
нительный код различения типов.
Далее мы дадим вам советы по выбору подходящей комбинации стратегий
отображения
для иерархий классов вашего приложения.
6.7. Выбор стратегии
Выбор правильной стратегии отображения наследования зависит от использова-
ния суперклассов иерархии сущностей. Вы должны учесть, как часто запраши-
ваются экземпляры суперклассов, а также наличие ассоциаций, направленных
к суперклассам. Другой важный аспект – атрибуты супертипов и подтипов: от-
личаются ли подклассы от супертипа наличием дополнительных атрибутов или
только поведением. Вот несколько практических рекомендаций.
 Если полиморфные ассоциации или запросы не требуются, выбирайте одну
таблицу для каждого конкретного класса. Другими словами: если вы редко
выполняете (или никогда не выполняете) запрос select bd from BillingDetails
bd и если у вас нет классов, ссылающихся на BillingDetails, отдавайте
предпочтение явному отображению на основе UNION со стратегией InheritanceType.
TABLE_PER_CLASS, поскольку при этом сохраняется возможность
последующего добавления (оптимизированных) полиморфных запросов
и ассоциаций.
 Если требуются полиморфные запросы или ассоциации (ассоциация с су-
перклассом, а следовательно, со всеми классами иерархии и с динамиче-
Выбор стратегии  169
ским определением конкретного класса во время выполнения), а подклас-
сы объявляют относительно мало новых полей (особенно если основная
разница между подклассами только в поведении), выбирайте стратегию
InheritanceType.SINGLE_TABLE. Ваша цель в том, чтобы сократить количе-
ство столбцов, которые могут содержать null, и убедить себя (и администратора
базы данных), что денормализованная схема не вызовет впослед-
ствии проблем.
 Если требуются полиморфные ассоциации или запросы, а подклассы объ-
являют много (обязательных к заполнению) полей (подклассы отличаются
в основном данными), выбирайте стратегию InheritanceType.JOINED. С дру-
гой стороны, в зависимости от ширины и глубины иерархии наследования
и возможной стоимости соединений по сравнению с объединениями вы
можете выбрать стратегию InheritanceType.TABLE_PER_CLASS. Такое решение
требует оценки планов выполнения запросов SQL на реальных данных.
Стратегию InheritanceType.SINGLE_TABLE следует выбирать только для решения
простых проблем. В сложных ситуациях или когда те, кто моделируют данные,
настаивают на важности ограничений NOT NULL, и над вами довлеет нормализация,
выбирайте стратегию InheritanceType.JOINED. В такие моменты спросите себя, не
лучше ли вовсе избавиться от наследования, заменив его делегированием. Слож-
ного наследования, как правило, следует избегать в силу разных причин, никак не
связанных с хранением данных или ORM. Hibernate выступает в роли прослойки
между предметной и реляционной моделями, но это не означает, что вы можете
полностью игнорировать вопросы хранения при проектировании классов.
Если вы подумываете о том, чтобы смешать несколько стратегий отображения
наследования, помните, что реализация неявного полиморфизма в Hibernate спо-
собна справиться с весьма экзотическими ситуациями. Также примите во внима-
ние, что невозможно применять аннотации наследования к интерфейсам; это не
предусмотрено в JPA.
Для примера рассмотрим дополнительный интерфейс в примере приложения:
ElectronicPaymentOption. Это бизнес-интерфейс, в котором аспект хранения полно-
стью отсутствует, за исключением того, что он может быть реализован хранимым
классом, таким как CreditCard. Независимо от того, как вы отобразите иерархию
класса BillingDetails, Hibernate правильно обработает следующий запрос: select
o from ElectronicPaymentOption o. Этот запрос будет работать для хранимых клас-
сов, реализующих данный интерфейс, даже если эти классы не являются частью
иерархии BillingDetails. Hibernate всегда знает, какие таблицы запрашивать, ка-
кие экземпляры создавать и как возвращать полиморфные результаты.
Вы можете применять все стратегии отображения к абстрактным классам. Hibernate
не станет пытаться создавать экземпляр абстрактного класса, даже если вы
будете выбирать его в запросе или загружать.
Мы уже несколько раз упомянули об отношении между классами User и Billing-
Details и его влиянии на выбор стратегии отображения наследования. В следую-
щем и последнем разделе этой главы мы подробно рассмотрим эту более сложную
170  Отображение наследования
тему полиморфных ассоциаций. Если в вашей модели такие отношения на данный
момент отсутствуют, вы можете прочитать этот материал позже, когда столкнетесь
с этой особенностью в своем приложении.
6.8. Полиморфные ассоциации
Полиморфизм является определяющей особенностью объектно-ориентирован-
ных языков программирования, таких как Java. Поддержка полиморфных ассоциаций
и полиморфных запросов является фундаментальной особенностью таких
реализаций ORM, как Hibernate. Удивительно, как далеко нам удалось забраться,
не углубляясь в обсуждение полиморфизма. К счастью, на эту тему особенно не-
чего сказать – полиморфизм так легко использовать в Hibernate, что объяснить
его будет нетрудно.
В качестве обзора мы сначала рассмотрим ассоциацию многие к одному (manyto-
one), направленную к классу, который может иметь много подклассов, а затем
отношение один ко многим (one-to-many). В обоих примерах классы модели пред-
метной области будут одинаковыми; см. рис. 6.6.
username : String
lastname : String
User
default
0..*
owner : String
BillingDetails
cardNumber : String
expMonth: String
expYear : String
CreditCard
account : String
bankname : String
swift : String
BankAccount
firstname : String
Рис. 6.6  В качестве платежных реквизитов по умолчанию
у пользователя выбрана кредитная карта или банковский счет
6.8.1. Полиморфная ассоциация многие к одному
(many-to-one)
Сначала рассмотрим поле defaultBilling класса User. Оно ссылается на единствен-
ный экземпляр BillingDetails, который во время выполнения может оказаться
любым конкретным экземпляром этого класса.
Отобразить эту однонаправленную ассоциацию с абстрактным классом Billing-
Details можно следующим образом:
Файл: /model/src/main/java/org/jpwh/model/inheritance/associations/
manytoone/ User.java
@Entity
@Table(name = "USERS")
public class User {
@ManyToOne(fetch = FetchType.LAZY)
Полиморфные ассоциации  171
protected BillingDetails defaultBilling;
// ...
}
Теперь в таблице USERS появится столбец внешнего ключа для соединения DEFAULTBILLING_
ID, представляющий данное отношение. В этом столбце может содер-
жаться значение null, поскольку пользователь (User) мог пока не выбрать способ
оплаты по умолчанию. Поскольку класс BillingDetails – абстрактный, ассоциа-
ция должна во время выполнения ссылаться на экземпляр одного из его подклас-
сов – CreditCard или BankAccount. Чтобы использовать полиморфные ассоциации
в Hibernate, не нужно делать ничего особенного; если целевой класс ассоциации
отображается с помощью аннотаций @Entity и @Inheritance, ассоциация автомати-
чески становится полиморфной.
Следующий код демонстрирует создание ассоциации с экземпляром подкласса
CreditCard:
Файл: /examples/src/test/java/org/jpwh/test/inheritance/
PolymorphicManyToOne.java
CreditCard cc = new CreditCard(
"John Doe", "1234123412341234", "06", "2015"
);
User johndoe = new User("johndoe");
johndoe.setDefaultBilling(cc);
em.persist(cc);
em.persist(johndoe);
Теперь, во время навигации по ассоциации во второй единице работы, Hibernate
автоматически будет извлекать экземпляры CreditCard:
Файл: /examples/src/test/java/org/jpwh/test/inheritance/
PolymorphicManyToOne.java
User user = em.find(User.class, USER_ID);
user.getDefaultBilling().pay(123); Вызовет метод pay() конкретного подкласса BillingDetails
Но имейте в виду, поскольку поле defaultBilling отображается с параметром
FetchType.LAZY, Hibernate завернет цель ассоциации в прокси-объект. В этом слу-
чае вы не сможете выполнить приведение типа к конкретному классу CreditCard,
и даже оператор instanceof будет вести себя странно:
Файл: /examples/src/test/java/org/jpwh/test/inheritance/
PolymorphicManyToOne.java
User user = em.find(User.class, USER_ID);
BillingDetails bd = user.getDefaultBilling();
assertFalse(bd instanceof CreditCard);
// CreditCard creditCard = (CreditCard) bd; Вызовет исключение ClassCastException!
172  Отображение наследования
Ссылка bd в данном случае не является экземпляром CreditCard – это специаль-
ный подкласс BillingDetails, сгенерированный во время выполнения, – прокси-
класс Hibernate. Когда вызывается метод прокси-объекта, Hibernate делегирует
его выполнение экземпляру CreditCard, загрузка которого отложена. Пока ини-
циализация этого экземпляра не произошла, Hibernate не знает его подтипа – это
потребовало бы обращения к базе данных, которого вы в первую очередь и пытае-
тесь избежать с помощью отложенной загрузки. Для безопасного преобразования
типов используйте em.getReference():
Файл: /examples/src/test/java/org/jpwh/test/inheritance/
PolymorphicManyToOne.java
User user = em.find(User.class, USER_ID);
BillingDetails bd = user.getDefaultBilling();
CreditCard creditCard =
em.getReference(CreditCard.class, bd.getId()); Никакого SELECT
assertTrue(bd != creditCard); Осторожно!
После вызова getReference() ссылки bd и creditCard будут ссылаться на два
разных прокси-объекта, каждый из которых делегирует работу одному и тому
же скрытому экземпляру CreditCard. Несмотря на это, у второго прокси-объекта
будет другой интерфейс, и вы сможете вызывать такие методы, как creditCard.
getExpMonth(), применимые только к этому интерфейсу (обратите внимание, что
bd.getId() вызовет SELECT, если отобразить свойство id с использованием страте-
гии прямого доступа к полям).
Этих проблем можно избежать, если отказаться от отложенной загрузки, как
показано в следующем примере, где применяется запрос с непосредственной за-
грузкой:
Файл: /examples/src/test/java/org/jpwh/test/inheritance/
PolymorphicManyToOne.java
User user = (User) em.createQuery(
"select u from User u " +
"left join fetch u.defaultBilling " +
"where u.id = :id")
.setParameter("id", USER_ID)
.getSingleResult();
CreditCard creditCard = (CreditCard) user.getDefaultBilling();
Настоящий объектно-ориентированный код не должен использовать оператора
instanceof или многочисленных преобразований типов. Если обнаружится, что вы
вляпались в проблемы с прокси-классами, критически оцените свой проект при-
ложения и поищите более полиморфный подход. Hibernate также поддерживает
возможность внедрения в байт-код для организации отложенной загрузки через
прокси; мы вернемся к стратегиям извлечения позже, в главе 12.
Прокси-объект не используется:
экземпляр BillingDetails
извлекается сразу же
Полиморфные ассоциации  173
Таким же способом можно работать с ассоциациями один к одному. Но что по
поводу множественных ассоциаций, таких как коллекции платежных реквизитов
(billingDetails) для каждого пользователя (User)? Давайте посмотрим на них
далее.
6.8.2. Полиморфные коллекции
У пользователя (User) могут быть ссылки на множество платежных реквизитов
(BillingDetails), а не только заданный по умолчанию (один из нескольких будет
выбираться по умолчанию, но пока мы это проигнорируем). Отобразить такую
связь можно с помощью двунаправленной ассоциации один ко многим:
Файл: /model/src/main/java/org/jpwh/model/inheritance/associations/
onetomany/User.java
@Entity
@Table(name = "USERS")
public class User {
@OneToMany(mappedBy = "user")
protected Set<BillingDetails> billingDetails = new HashSet<>();
// ...
}
Далее показан владелец отношения (объявленный в предыдущем отображении
с помощью параметра mappedBy):
Файл: /model/src/main/java/org/jpwh/model/inheritance/associations/
onetomany/BillingDetails.java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class BillingDetails {
@ManyToOne(fetch = FetchType.LAZY)
protected User user;
// ...
}
До сих пор в отображении этой ассоциации не встретилось ничего необычно-
го. Иерархия классов BillingDetails может отображаться со стратегиями TABLE_
PER_CLASS, SINGLE_TABLE или JOINED. Hibernate автоматически будет использовать
правильные запросы SQL с оператором JOIN или UNION для загрузки коллекции
элементов.
Правда, есть одно ограничение – класс BillingDetails не может иметь аннота-
цию @MappedSuperclass, как было показано в разделе 6.1. Он должен отображаться
с аннотациями @Entity и @Inheritance.
174  Отображение наследования
Ассоциации с неявным полиморфизмом
Если вам потребуется отобразить ассоциацию, направленную на иерархию клас-
сов, не отображая ее явно с помощью @Inheritance, в качестве крайнего средства
Hibernate предоставляет следующий способ. Такое отображение можно опреде-
лить в XML-файле отображений Hibernate, используя элемент <any/>. Мы советуем
найти описание этой возможности в документации Hibernate или в предыдущем
издании данной книги, но старайтесь избегать ее, поскольку она может привести
к появлению уродливых схем.
6.9. Резюме
 Одна таблица для каждого конкретного класса с неявным полиморфизмом –
это простейшая стратегия отображения иерархий наследования сущностей,
но она не очень хорошо поддерживает полиморфные ассоциации. Кроме того,
разные столбцы в разных таблицах разделяют одинаковую семантику, что за-
трудняет эволюционирование схемы. Мы советуем применять этот подход для
верхушки иерархии классов, где полиморфизм на самом деле не нужен и не
предвидится изменений в суперклассе в будущем.
 Использование одной таблицы для каждого конкретного класса с операциями
объединения не является обязательной стратегией, и реализации JPA могут ее
не поддерживать, зато она может работать с полиморфными ассоциациями.
 Стратегия с использованием единой таблицы для всех классов иерархии явля-
ется лучшей с точки зрения производительности и простоты; можно создавать
отчеты на основе произвольных запросов, не используя сложных соединений
и объединений, а эволюция схемы происходит довольно просто. Главной проблемой
при этом является целостность данных, поскольку приходится разре-
шить некоторым столбцам содержать null. Другой проблемой является нор-
мализация: данная стратегия создает функциональные зависимости между
простыми столбцами, нарушая третью нормальную форму.
 Главным преимуществом стратегии одной таблицы для каждого подкласса
с операциями соединения являются нормализация схемы SQL, упрощение ее
эволюции и возможность определения ограничений целостности данных. Не-
достаток заключается в сложности ее реализации вручную и низкой произво-
дительности для сложных иерархий классов.
Глава 7
Отображение
коллекций и связей
между сущностями
В этой главе:
 отображение хранимых коллекций;
 коллекции основных и встраиваемых типов;
 простые ассоциации многие к одному и один ко многим.
Как следует из нашего опыта общения с сообществом пользователей Hibernate,
многие разработчики, приступая к работе с Hibernate, в первую очередь пытаются
отобразить отношения родитель/потомок. Обычно тогда они впервые и сталки-
ваются с коллекциями. Также они впервые начинают задумываться о различиях
между сущностями и типами-значениями или просто теряются в сложности ORM.
Центральной частью ORM является управление связями между классами и от-
ношениями между таблицами. Большинство трудностей объектно-реляционного
отображения связано с коллекциями и управлением связями между сущностями.
Вы можете вернуться к этой главе позже, чтобы лучше разобраться в данной теме.
Мы начнем со знакомства с основными понятиями отображения коллекций и рас-
смотрим несколько простых примеров. После этого вы будете готовы отобразить
вашу первую связь между сущностями в виде коллекции, хотя позже, в следую-
щей главе, мы вернемся к отображению более сложных связей. Для полноты кар-
тины рекомендуем прочесть эту главу и следующую.
Главные нововведения в JPA 2
• Поддержка коллекций и словарей основных и встраиваемых типов.
• Поддержка хранимых списков, когда индекс каждого элемента хранится в до-
полнительном столбце в базе данных.
• Для ассоциации один ко многим стала доступна возможность удаления «осиро-
тевших» объектов.
176  Отображение коллекций и связей между сущностями
7.1. Множества, контейнеры, списки и словари
с типами-значениями
Для работы с коллекциями в Java имеется богатый API, из которого можно вы-
бирать те интерфейсы и реализации, которые более всего подходят модели пред-
метной области. Давайте рассмотрим отображения основных коллекций, исполь-
зуя один и тот же пример с классами Image и Item и внося в него лишь небольшие
изменения. Мы начнем с рассмотрения схемы базы данных и отображения поля
коллекции в целом. Затем перейдем к выбору конкретного интерфейса коллекции
и отобразим несколько реализаций: множество, контейнер (bag) идентификато-
ров, список, словарь и, наконец, отсортированные и упорядоченные коллекции.
7.1.1. Схема базы данных
Давайте расширим приложение CaveatEmptor, предоставив возможность добав-
ления изображений аукционных товаров. Забудем пока об Java-коде и, сделав шаг
назад, рассмотрим лишь схему базы данных.
В базе данных вам понадобится таблица IMAGE для хранения изображений или,
быть может, только имен файлов. В таблице также должен быть столбец внешнего
ключа, например ITEM_ID, ссылающийся на таблицу ITEM. Взгляните на схему, по-
казанную на рис. 7.1.
ID << PK >>
NAME
...
<< Table >>
ITEM
ITEM_ID << PK >> << FK>>
FILENAME << PK >>
<< Table >>
IMAGE
Рис. 7.1  Таблица IMAGE хранит имена файлов,
каждый из которых ссылается на ITEM_ID
Это все, что касается схемы, – никаких коллекций или жизненного цикла ком-
позиции. (Вы, конечно, можете указать ограничение ON DELETE CASCADE для столбца
внешнего ключа ITEM_ID. При удалении приложением записи из таблицы ITEM база
данных автоматически удалит записи из таблицы IMAGE, ссылающиеся на удаляе-
мую запись в ITEM. Давайте пока предположим, что это не так.)
7.1.2. Создание и отображение поля коллекции
Как бы вы отобразили таблицу IMAGE, используя то, что вам уже известно? Воз-
можно, вы отобразили бы ее как класс сущности (@Entity) с именем Image. Позже
в этой главе вы отобразите столбец внешнего ключа, используя поле с аннотацией
@ManyToOne. Вам также понадобится отображение составного первичного ключа
для класса сущности, как показано в разделе 9.2.2.
Нет никаких отображаемых коллекций – они попросту не нужны. Когда по-
требуется извлечь изображения товара, вы напишете и выполните инструкцию на
Множества, контейнеры, списки и словари с типами-значениями  177
языке запросов JPA: select img from Image img where img.item = :itemParameter. Нет
никакой необходимости хранить коллекции как таковые. Но зачем тогда может
понадобиться отображать коллекции?
Коллекция, которую вы можете создать, – это Item#images, ссылающаяся на все
изображения конкретного товара. Это поле создается и отображается для решения
следующих задач:
 автоматически выполнять SQL-запрос SELECT * from IMAGE where ITEM_ID = ?
при каждом вызове метода someItem.getImages(). До тех пор, пока экземпля-
ры вашей предметной модели находятся в управляемом состоянии, вы мо-
жете читать данные из базы по требованию во время навигации по связям
между классами. Для загрузки данных не нужно вручную писать и выпол-
нять запросы, используя объект EntityManager. С другой стороны, запрос,
выполняемый при обходе коллекции, всегда будет выбирать для данного
товара все изображения, а не только те, что удовлетворяют условию XYZ;
 избежать сохранения экземпляров Image с помощью entityManager.persist().
Если вы отобразили коллекцию, добавление в нее объекта Image
с помощью someItem.getImages().add() автоматически сделает его храни-
мым. Такая каскадность удобна тем, что можно сохранять экземпляры, не
вызывая EntityManager;
 гарантировать зависимый жизненный цикл экземпляров Image. Во время
удаления объекта Item Hibernate также удалит все прикрепленные объек-
ты Image, выполняя дополнительное SQL-выражение DELETE. Вам не нужно
беспокоиться о жизненном цикле изображений и удалении «осиротевших»
объектов (мы предполагаем, что для внешнего ключа в базе данных отсут-
ствует ограничение ON DELETE CASCADE). Реализация JPA берет управление
жизненным циклом композиции на себя.
Важно осознать, что, хотя все эти преимущества и выглядят привлекательно, вы
платите за них дополнительной сложностью отображения. Мы видели, как мно-
гие новички в JPA мучатся с отображениями коллекций и часто на вопрос: «Зачем
ты это делаешь?», – отвечают: «Я думал, что обязательно должна использоваться
коллекция».
Анализ сценария с изображениями товаров показывает, что вы только выиграете
от отображения коллекции. Изображения имеют зависимый жизненный
цикл: при удалении товара все прикрепленные изображения тоже удаляются.
При сохранении товара все прикрепленные изображения тоже сохраняются.
При отображении товара вы обычно показываете и все его изображения, поэтому
someItem.getImages() – это удобный метод пользовательского интерфейса. Вам не
нужно повторно обращаться к уровню хранения для загрузки изображений – они
уже здесь.
Далее мы выберем такой интерфейс и реализацию коллекции, которые лучше
всего подойдут для нашей предметной модели. Давайте рассмотрим отображения
основных коллекций, используя один и тот же пример с классами Image и Item
и внося в него лишь небольшие изменения.
178  Отображение коллекций и связей между сущностями
7.1.3. Выбор интерфейса коллекции
Идиома для работы с коллекциями в модели предметной области Java выгладит
так:
<<Interface>> images = new <<Implementation>>();
// Методы доступа к свойствам
// ...
Для объявления типа поля используйте интерфейс, а не реализацию. Выберите
подходящую реализацию и сразу же инициализируйте коллекцию; поступая так,
вы избегаете появления неинициализированных коллекций. Мы не советуем ини-
циализировать коллекции позже, в конструкторах или методах записи.
Вот типичный пример объявления параметризованного множества (Set):
Set<String> images = new HashSet<String>();
Обычные коллекции без параметризации
Если вы не указываете типа коллекции или ключей/значений словаря с помощью
параметризации, вы должны сообщить Hibernate об этом типе (типах). К приме-
ру, вместо Set<String> можно отобразить обычное множество Set, добавив аннота-
цию @ElementCollection(targetClass=String.class). Вышесказанное также применимо
к параметрам типов словаря (Map). Тип ключа словаря можно задать с помощью ан-
нотации @MapKeyClass. Все примеры в этой книге используют параметризованные
коллекции и словари, и вы должны поступать так же.
По умолчанию Hibernate поддерживает наиболее важные интерфейсы кол-
лекций JDK с сохранением типичной семантики хранимых словарей и масси-
вов. Для каждого интерфейса JDK в Hibernate имеется соответствующая ре-
ализация, и важно, чтобы вы выбирали правильную комбинацию. Hibernate
обертывает коллекции, которые вы уже инициализировали в объявлении члена
класса, а иногда заменяет их, если они были выбраны неверно. Это делается
в том числе и для поддержки отложенной загрузки и проверки состояния эле-
ментов коллекций.
В Hibernate без расширений на выбор имеются следующие коллекции:
 свойство типа java.util.Set, инициализированное экземпляром java.util.
HashSet. Порядок элементов не сохраняется, хранение повторяющихся эле-
ментов запрещено. Этот тип данных поддерживают все реализации JPA;
 свойство типа java.util.SortedSet, инициализированное экземпляром
java.util.TreeSet. Данная коллекция поддерживает постоянный порядок
элементов: сортировка осуществляется в памяти после загрузки данных.
Упорядоченность коллекции поддерживается только в Hibernate – осталь-
ные реализации JPA могут игнорировать ее;
 свойство типа java.util.List, инициализированное экземпляром java.util.
ArrayList. Hibernate сохраняет порядок следования элементов, используя
Множества, контейнеры, списки и словари с типами-значениями  179
дополнительный столбец с индексами. Этот тип данных поддерживают все
реализации JPA;
 свойство типа java.util.Collection, инициализированное экземпляром
java.util.ArrayList. Обладает семантикой контейнера: может хранить по-
вторяющиеся элементы, но их порядок не сохраняется. Этот тип данных
поддерживают все реализации JPA;
 свойство типа java.util.Map, инициализированное экземпляром java.util.
HashMap. Пары ключей и значений словаря могут сохраняться в базе данных.
Этот тип данных поддерживают все реализации JPA;
 свойство типа java.util.SortedMap, инициализированное экземпляром java.
util.TreeMap. Поддерживает порядок элементов: сортировка происходит
в памяти, когда Hibernate загружает данные. Упорядоченность поддержива-
ется только в Hibernate – остальные реализации JPA могут игнорировать ее;
 Hibernate, в отличие от JPA, поддерживает хранимые массивы. Они редко
используются, и мы не станем приводить их в книге; Hibernate не может обе-
ртывать свойства-массивы, из-за чего многие преимущества коллекций, та-
кие как отложенная загрузка, не будут работать. Используйте хранимые мас-
сивы, только если вы уверены, что отложенная загрузка вам не понадобится
(есть возможность организовать отложенную загрузку массивов, но для это-
го потребуется перехватывать вызовы, как будет показано в разделе 12.1.3).
Особенности Hibernate
Чтобы отобразить интерфейсы и реализации коллекций, не поддерживаемые Hibernate,
необходимо сообщить Hibernate о семантике ваших собственных коллек-
ций. Точкой расширения в Hibernate является интерфейс PersistentCollection из
пакета org.hibernate.collection.spi, в котором обычно выбирают для расширения
один из существующих классов: PersistentSet, PersistentBag или PersistentList.
Создать собственную коллекцию непросто, поэтому мы не советуем этого делать,
если только вы не являетесь опытным пользователем Hibernate. Соответствую-
щие примеры можно найти в исходном коде тестов для Hibernate.
Для примера с изображениями товаров мы предположим, что само изображение
находится где-то в файловой системе, а в базе данных хранится лишь имя файла.
Транзакционные файловые системы
Если в базе данных SQL хранятся лишь имена файлов изображений, вы должны
где-то хранить двоичные данные каждого изображения. Можно хранить данные
изображений в базе SQL, в столбце типа BLOB (см. раздел «Двоичные типы и типы
для представления больших значений» в главе 5). Если вы все же решите хранить
изображения не в базе данных, а в обычных файлах, учтите, что прикладные про-
граммные интерфейсы Java для работы с файловой системой – java.io.File и java.
nio.file.Files – не поддерживают транзакций. Операции файловой системы не яв-
ляются частью системы транзакций (JTA): транзакция может завершиться успеш-
но, и Hibernate запишет имя файла в базу данных SQL, но сохранение или удаление
180  Отображение коллекций и связей между сущностями
файла может не выполниться. Эти операции нельзя откатить как атомарную едини-
цу, а также не обеспечивается необходимой изоляции операций.
К счастью, сейчас доступны реализации транзакционных файловых систем с откры-
тым исходным кодом для Java, такие как XADisk (см. https://xadisk.java.net). Вы мо-
жете запросто интегрировать XADisk с системным диспетчером транзакций, таким
как Bitronix, который используется в примерах из этой книги. Файловые операции
тогда будут включаться в транзакцию, фиксироваться и откатываться вместе с SQL-
операциями Hibernate в рамках выполнения одного экземпляра UserTransaction.
Давайте отобразим коллекцию с именами файлов изображений для товара
(Item).
7.1.4. Отображение множества
Простейшей реализацией является множество (Set) строк (String) с именами
файлов. Добавьте свойство-коллекцию в класс Item, как показано в листинге 7.1.
Листинг 7.1  Изображения отображаются в виде множества строк
Файл: /model/src/main/java/org/jpwh/model/collections/setofstrings/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(
name = "IMAGE", Имя по умолчанию ITEM_IMAGES
joinColumns = @JoinColumn(name = "ITEM_ID")) Значение по умолчанию
@Column(name = "FILENAME") Имя по умолчанию IMAGES
protected Set<String> images = new
HashSet<String>(); Инициализация поля класса
// ...
}
Коллекция экземпляров типов-значений должна быть отмечена JPA-аннотацией
@ElementCollection. Без аннотаций @CollectionTable и @Column фреймворк Hibernate
будет использовать имена элементов схемы. Посмотрите на схему на рис. 7.2:
столбцы первичных ключей подчеркнуты.
ITEM
ID
1
NAME
Foo
2
3
B
C
IMAGE
ITEM_ID
1
FILENAME
foo.jpg
1 bar.jpg
2 b.jpg
1 baz.jpg
Рис. 7.2  Структура таблиц и данные
для примера со множеством строк
Множества, контейнеры, списки и словари с типами-значениями  181
Таблица IMAGE имеет составной первичный ключ, включающий два столбца:
ITEM_ID и FILENAME. Это значит, что записи не могут повторяться: каждое изображе-
ние может быть прикреплено к каждому товару только один раз. Порядок изображений
не сохраняется. Это согласуется с моделью предметной области и с коллек-
цией Set.
Кажется маловероятным, чтобы пользователю понадобилось прикрепить к од-
ному товару одно и то же изображение несколько раз, но предположим, что это
действительно необходимо. Какой тип отображения подойдет в этом случае?
Особенности Hibernate
7.1.5. Отображение контейнера идентификаторов
Контейнер (bag) – неупорядоченная коллекция, позволяющая хранить повторяющиеся
элементы, подобно коллекции с интерфейсом java.util.Collection. Любо-
пытно, но в библиотеке Java Collections реализация контейнера отсутствует. Вы
инициализируете свойство объектом ArrayList, а Hibernate игнорирует индексы
элементов при сохранении и загрузке элементов.
Листинг 7.2  Контейнер строк, позволяющий хранить дублирующие элементы
Файл: /model/src/main/java/org/jpwh/model/collections/bagofstrings/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@Column(name = "FILENAME")
@org.hibernate.annotations.CollectionId(
columns = @Column(name = "IMAGE_ID"),  Столбец суррогатного первичного ключа
type = @org.hibernate.annotations.Type(type = "long"),
generator = Constants.ID_GENERATOR)
protected Collection<String> images = new ArrayList<String>();
// ...
}
Это отображение выглядит сложнее: вы не можете использовать прежнюю схе-
му. Для таблицы коллекции IMAGE требуется определить другой первичный ключ,
допускающий повторение значений FILENAME для каждого ITEM_ID. С этой целью
вводится столбец суррогатного первичного ключа с именем IMAGE_ID  и приме-
няется аннотация, доступная только в Hibernate , которая определяет способ ге-
нерации первичного ключа . Если вы забыли, как работают генераторы ключей,
прочтите раздел 4.2.4.
Модифицированная схема показана на рис. 7.3.
Суррогатный первичный ключ
допускает повторение элементов
 Настройка
первичного
ключа
 Аннотация,
доступная
только в Hibernate
В JDK отсутствует
реализация BagImpl
182  Отображение коллекций и связей между сущностями
IMAGE
ITEM_ID
1
FILENAME
1
1
IMAGE_ID
1
2
3
ITEM
ID
1
NAME
Foo
2
3
B
C
foo.jpg
bar.jpg
baz.jpg
b.jpg
4
5
1 baz.jpg
2
Рис. 7.3  Столбец суррогатного первичного ключа
для контейнера со строками
Возникает интересный вопрос: сможете ли вы сказать, как эти таблицы отобра-
жаются в Java, глядя только на эту схему? Таблицы ITEM и IMAGE выглядят одинако-
во: каждая имеет столбец суррогатного первичного ключа и прочие нормализован-
ные столбцы. Каждая таблица могла бы отображаться с помощью класса сущности
(@Entity). Мы решили использовать функциональность, доступную в JPA, отобра-
зив коллекцию в таблицу IMAGE, несмотря на жизненный цикл, характерный для
композиции. В сущности, это решение о том, что все, что нужно для этой табли-
цы, – это некоторые предопределенные запросы и правила работы с данными, а не
более обобщенное отображение @Entity. Принимая подобное решение, вы должны
быть уверены в его причинах и последствиях.
Следующий способ отображения сохраняет порядок изображений в списке.
7.1.6. Отображение списка
Если прежде вам не приходилось пользоваться механизмами ORM, хранимый спи-
сок может показаться мощной идеей; представьте, сколько усилий потребовалось
бы для сохранения и загрузки объекта java.util.List<String>, используя JDBC
и SQL. При вставке элемента в середину списка, в зависимости от реализации,
список сдвигает все последующие элементы вправо и переустанавливает указате-
ли. Если удалить элемент из середины списка, произойдет что-то еще и т. д. Если
механизм ORM может делать все это для записей в базе данных автоматически,
это делает хранимый список более привлекательным, чем он есть на самом деле.
Как отмечалось в разделе 3.2.4, в первый момент возникает желание сохранить
элементы в порядке их ввода пользователем. Нередко эти данные приходится
показывать позже в таком же порядке. Но если будет применено другое условие
сортировки, например по времени создания записи, вам придется сортировать
данные в запросе, не сохраняя их порядка. А что, если порядок вывода изменит-
ся? Порядок вывода практически никогда не является существенной характеристикой
данных. Поэтому дважды подумайте, перед тем как отображать хранимый
список List; Hibernate не настолько умен, как может показаться, что наглядно де-
монстрируют следующие примеры.
Для начала модифицируем сущность Item и ее свойство-коллекцию.
Множества, контейнеры, списки и словари с типами-значениями  183
Листинг 7.3  Хранимый список, поддерживающий порядок следования
элементов в базе данных
Файл: /model/src/main/java/org/jpwh/model/collections/listofstrings/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@OrderColumn Позволяет сохранять порядок; имя по умолчанию: IMAGES_ORDER
@Column(name = "FILENAME")
protected List<String> images = new ArrayList<String>();
// ...
}
В этом примере появилась новая аннотация: @OrderColumn. В данном столбце
хранятся индексы элементов хранимого списка, начиная с нуля. Обратите внима-
ние, что Hibernate сохраняет индекс в базе данных непрерывным и ожидает, что
он будет оставаться таким же. Если возникнут пропуски, при загрузке и создании
объекта List Hibernate добавит соответствующие элементы со значением null. По-
смотрите на схему на рис. 7.4.
IMAGE
IMAGES_ORDER
0
FILENAME
1
2
ITEM_ID
1
1
1
2
2
0
1
b1jpg
b2.jpg
1 3
ITEM
ID
1
NAME
Foo
2
3
B
C
foo.jpg
bar.jpg
baz.jpg
baz.jpg
Рис. 7.4  Таблица коллекции
хранит позицию каждого элемента в списке
Первичный ключ таблицы IMAGE состоит из ITEM_ID и IMAGES_ORDER. Это позволя-
ет хранить одинаковые значения FILENAME, что согласуется с семантикой типа List.
Ранее мы сказали, что Hibernate не так умен, как может показаться. Посмотрим,
как выполнится изменение списка из трех элементов A, B и C, расположенных
именно в таком порядке. Что произойдет при удалении A из списка? Hibernate
выполнит одну SQL-инструкцию DELETE для этой строки. Затем две инструкции
UPDATE для B и C, сдвигая их позиции влево, чтобы заполнить пропущенный ин-
декс. Для каждого элемента справа от удаляемого Hibernate выполнит выражение
UPDATE. Если написать SQL-запрос вручную, можно обойтись одной инструкцией
UPDATE. То же верно и для вставки в середину списка. Hibernate сдвинет все эле-
менты справа на одну позицию. Hibernate хотя бы сообразит выполнить одно вы-
ражение DELETE при вызове метода списка clear().
184  Отображение коллекций и связей между сущностями
Теперь предположим, что помимо имени файла изображение товара имеет на-
звание, которое вводится пользователем. Смоделировать это в Java можно, напри-
мер, применив словарь (map).
7.1.7. Отображение словаря
И снова внесем небольшое изменение в Java-класс, чтобы использовать свойство
типа Map.
Листинг 7.4  Хранимый словарь с ключами и значениями
Файл: /model/src/main/java/org/jpwh/model/collections/mapofstrings/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@MapKeyColumn(name = "FILENAME")  Отображает ключ
@Column(name = "IMAGENAME")  Отображает значение
protected Map<String, String> images = new HashMap<String, String>();
// ...
}
Каждый элемент словаря – это пара ключ/значение. Здесь ключ словаря отображается
с помощью аннотации @MapKeyColumn в столбец FILENAME , а значение –
в столбец IMAGENAME . Это значит, что пользователь может добавить файл только
раз, потому что словарь (Map) не допускает повторения ключей.
Как видно из схемы на рис. 7.5, столбец первичного ключа таблицы коллекции
состоит из столбцов ITEM_ID и FILENAME. В качестве типа ключа словаря в примере
выбран String, но Hibernate поддерживает все основные типы, такие как BigDecimal
и Integer. Если ключ является Java-перечислением (enum), вы должны исполь-
зовать @MapKeyEnumerated. С любым типом для представления времени, таким как
java.util.Date, используйте аннотацию @MapKeyTemporal. Мы уже обсуждали эти
возможности в разделах 5.1.6 и 5.1.7, хотя и не в контексте отображения коллекций.
Словарь из предыдущего примера был неупорядоченным. Что необходимо сде-
лать, чтобы сохранить словарь, отсортированный по имени файла?
IMAGE
IMAGENAME
Foo
FILENAME
Bar
Baz
ITEM_ID
1
1
1
2 B1
ITEM
ID
1
NAME
Foo
2
3
B
C
b1.jpg
b2.jpg
foo.jpg
bar.jpg
baz.jpg
2 B2
Рис. 7.5  Таблица для отображения словаря,
в котором ключи и значения являются строками
Множества, контейнеры, списки и словари с типами-значениями  185
Особенности Hibernate
7.1.8. Отсортированные и упорядоченные коллекции
В английском языке слова sorted (отсортированный) и ordered (упорядоченный)
имеют разное значение, когда речь заходит о хранимых коллекциях Hibernate.
Коллекции сортируются в памяти, с использованием Java-компараторов (функ-
ций сравнения). Упорядочивание коллекции производится при загрузке из базы
данных, с использованием предложения ORDER BY в запросе SQL.
Давайте сделаем словарь с изображениями отсортированным. Для этого нужно
изменить Java-свойство и его отображение.
Листинг 7.5  Сортировка записей словаря в памяти с помощью компаратора
Файл: /model/src/main/java/org/jpwh/model/collections/sortedmapofstrings/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@MapKeyColumn(name = "FILENAME")
@Column(name = "IMAGENAME")
@org.hibernate.annotations.SortComparator(ReverseStringComparator.class)
protected SortedMap<String, String> images =
new TreeMap<String, String>();
// ...
}
Отсортированные коллекции – это особенность Hibernate, поэтому здесь ис-
пользована аннотация org.hibernate.annotations.SortComparator с одной из реали-
заций java.util.Comparator. Мы не будем показывать этот простейший класс – он
просто сортирует строки в обратном порядке.
Как и в следующих примерах, схема базы данных не меняется. Если вам нужно
вспомнить, как выглядит схема, посмотрите иллюстрации в предыдущем разделе.
Отобразим java.util.SortedSet, как показано далее.
Листинг 7.6  Сортировка элементов множества в памяти с помощью
String#compareTo()
Файл: /model/src/main/java/org/jpwh/model/collections/sortedsetof-strings/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@Column(name = "FILENAME")
@org.hibernate.annotations.SortNatural
186  Отображение коллекций и связей между сущностями
protected SortedSet<String> images = new TreeSet<String>();
// ...
}
Здесь применяется естественная сортировка, использующая метод String#compareTo().
К сожалению, вы не сможете отсортировать контейнер – не существует такого
типа, как TreeBag. Порядок элементов определяется их индексами.
С другой стороны, вместо применения интерфейсов Sorted* и сортировки кол-
лекции в памяти ее элементы можно сразу извлекать из базы данных в правиль-
ном порядке. Вместо типа java.util.SortedSet в следующем примере выбран java.
util.LinkedHashSet.
Листинг 7.7  LinkedHashSet сохраняет порядок вставки при обходе
Файл: /model/src/main/java/org/jpwh/model/collections/setofstringsorderby/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@Column(name = "FILENAME")
// @javax.persistence.OrderBy
@org.hibernate.annotations.OrderBy(clause = "FILENAME desc")
protected Set<String> images = new LinkedHashSet<String>();
// ...
}
Класс LinkedHashSet сохраняет постоянный порядок обхода элементов, и Hibernate
заполнит его в правильном порядке при загрузке коллекции. Для этого
Hibernate добавит предложение ORDER BY в SQL-выражение, загружающее коллек-
цию. Это SQL-предложение должно объявляться с помощью аннотации @org.hibernate.
annotations.OrderBy. В ней можно даже вызывать функции SQL, такие как
@OrderBy("substring(FILENAME, 0, 3) desc"), которая отсортирует коллекцию по
первым трем буквам в именах файлов. Но будьте внимательны и убедитесь, что
СУБД поддерживает вызываемую функцию SQL. Кроме того, можно применить
синтаксис SQL:2003, например ORDER BY ... NULLS FIRST|LAST, и Hibernate автомати-
чески преобразует его в диалект, поддерживаемый СУБД.
@OrderBy из Hibernate или @OrderBy из JPA
Аннотацию @org.hibernate.annotations.OrderBy можно применить к любой коллекции;
ее параметр – это обычный фрагмент SQL-кода, который Hibernate добавит в SQL-
выражение, загружающее коллекцию. В Java Persistence есть похожая аннотация –
@javax.persistence.OrderBy. Она принимает единственный параметр – someProperty
Поддерживает единственный способ
упорядочивания «FILENAME asc»
Множества, контейнеры, списки и словари с типами-значениями  187
DESC|ASC. Элементы типа String или Integer не имеют свойств. Следовательно, если
применить JPA-аннотацию @OrderBy к коллекции простого типа, как в предыдущем
примере с Set<String>, согласно спецификации упорядочение будет производиться
по значениям объектов простого типа. Это значит, что вы не можете поменять по-
рядок: в предыдущем примере порядок всегда соответствовал бы условию FILENAME
asc. Мы будем использовать аннотации JPA позже, в разделе 7.2.2, когда в классе
значения элемента появятся сохраняемые поля и его тип будет отличаться от простого/
скалярного.
В следующем примере показано такое же упорядочение во время загрузки, но
с отображением контейнера.
Листинг 7.8  Тип ArrayList сохраняет постоянный порядок при обходе
Файл: /model/src/main/java/org/jpwh/model/collections/bagofstringsorderby/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@Column(name = "FILENAME")
@org.hibernate.annotations.CollectionId(
columns = @Column(name = "IMAGE_ID"),
type = @org.hibernate.annotations.Type(type = "long"),
generator = Constants.ID_GENERATOR)
@org.hibernate.annotations.OrderBy(clause = "FILENAME desc")
protected Collection<String> images = new ArrayList<String>();
// ...
}
Наконец, упорядоченные пары ключей и значений можно загрузить с помощью
LinkedHashMap.
Листинг 7.9  LinkedHashMap хранит упорядоченные пары ключей и значений
Файл: /model/src/main/java/org/jpwh/model/collections/mapofstringsorderby/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@MapKeyColumn(name = "FILENAME")
@Column(name = "IMAGENAME")
@org.hibernate.annotations.OrderBy(clause = "FILENAME desc")
protected Map<String, String> images = new LinkedHashMap<String, String>();
// ...
}
Суррогатный первичный ключ
допускает дублирование элементов
188  Отображение коллекций и связей между сущностями
Помните, что элементы упорядоченных коллекций располагаются в необходи-
мом порядке только во время загрузки. После добавления или удаления элементов
порядок обхода коллекции может отличаться от упорядочивания по имени файла;
эти коллекции ведут себя как обычные связанные множества, словари и списки.
В действующей системе вам, скорее всего, потребуется что-то большее, чем
просто
название изображения и имя файла. Возможно, придется создать класс
Image
для хранения дополнительной информации. А это может послужить превос-
ходным примером работы с коллекцией компонентов.
7.2. Коллекции компонентов
В разделе 5.2 мы уже отображали встраиваемые компоненты: свойство address
класса User. Но та ситуация отличается от текущей, потому что объект Item может
иметь много ссылок на экземпляры Image, как показано на рис. 7.6. Связь на диа-
грамме UML является композицией (закрашенный ромбик); следовательно, объ-
ект Image связан с жизненным циклом объекта Item.
title : String
width : int
height : int
Image
0..*
Item filename : String
Рис. 7.6  Коллекция компонентов Image класса Item
В листинге 7.10 показан новый встраиваемый класс Image, описывающий все
интересующие нас свойства изображения.
Листинг 7.10  Инкапсуляция всех полей изображения
Файл: /model/src/main/java/org/jpwh/model/collections/setofembeddables/
Image.java
@Embeddable
public class Image {
@Column(nullable = false)
protected String title;
@Column(nullable = false)
protected String filename;
protected int width;
protected int height;
// ...
}
Во-первых, обратите внимание, что все свойства являются обязательными
(с ограничением NOT NULL). Свойства для хранения размеров не могут иметь зна-
Коллекции компонентов  189
чения null, поскольку хранят значения простых типов. Во-вторых, мы должны по-
думать, как база данных и Java-приложение будут сравнивать два изображения.
7.2.1. Равенство экземпляров компонентов
Предположим, что мы сохранили несколько объектов Image в коллекции Hash-
Set. Известно, что множества не хранят повторяющихся элементов. Как же оно их
определяет? Коллекция HashSet вызывает метод equals() для каждого объекта Image,
который добавляется во множество Set. (Очевидно, она также вызывает метод
hashCode(), чтобы получить хэш-код.) Сколько изображений окажется в следую-
щей коллекции?
someItem.getImages().add(new Image(
"Foo", "foo.jpg", 640, 480
));
someItem.getImages().add(new Image(
"Bar", "bar.jpg", 800, 600
));
someItem.getImages().add(new Image(
"Baz", "baz.jpg", 1024, 768
));
someItem.getImages().add(new Image(
"Baz", "baz.jpg", 1024, 768
));
assertEquals(someItem.getImages().size(), 3);
Вы ожидали четыре изображения вместо трех? Вы правы – обычная про-
верка на равенство в Java использует идентичность объектов. Метод java.lang.
Object#equals() сравнивает два экземпляра как a==b. Используя такое сравнение,
в коллекции у вас окажутся четыре экземпляра Image. Ясно, что в данном примере
«правильный» ответ – три.
Класс Image не должен полагаться на идентичность в Java, поэтому мы должны
переопределить методы equals() и hashCode().
Листинг 7.11  Собственное определение равенства с помощью методов equals()
и hashCode()
Файл: /model/src/main/java/org/jpwh/model/collections/setofembeddables/
Image.java
@Embeddable
public class Image {
@Override
public boolean equals(Object o) {  Проверка на равенство
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Image other = (Image) o;
if (!title.equals(other.title)) return false;
190  Отображение коллекций и связей между сущностями
if (!filename.equals(other.filename)) return false;
if (width != other.width) return false;
if (height != other.height) return false;
return true;
}
@Override
public int hashCode() {  Должен быть симметричным
int result = title.hashCode();
result = 31 * result + filename.hashCode();
result = 31 * result + width;
result = 31 * result + height;
return result;
}
// ...
}
Здесь метод equals()  сравнивает все значения одного объекта Image со значе-
ниями другого объекта Image. Если совпали значения всех свойств, значит, изображения
одинаковые. Метод hashCode()  должен быть симметричным – если два
экземпляра равны, они должны иметь одинаковые хэш-коды.
Почему мы не переопределяли функцию сравнения при отображении адреса
(Address) пользователя (User) в разделе 5.2? По правде говоря, нам, скорее всего,
стоило это сделать. Единственное оправдание – отсутствие каких-либо проблем
при применении обычного сравнения Java-идентичности, пока мы не добавляем
встраиваемых компонентов во множество (Set) и не используем их в качестве
ключей словаря (Map). Иначе пришлось бы переопределять метод equals() и срав-
нивать значения объектов, а не их идентичности. Эти методы желательно пере-
определять для всех встраиваемых (@Embeddable) классов; все экземпляры типов-
значений должны сравниваться «по значению».
Рассмотрим теперь первичный ключ в базе данных: Hibernate сгенерирует
схему, объединяющую в составной первичный ключ все столбцы таблицы IMAGE,
которые не могут содержать null. Столбцы не могут содержать null, поскольку не-
возможно индентифицировать то, что неизвестно. Это согласуется с процедурой
определения равенства в классе Java. Схему вы увидите в следующем разделе,
а также найдете больше подробностей о первичных ключах.
ПРИМЕЧАНИЕ Необходимо отметить следующую особенность генератора
схемы Hibernate: если отметить свойство встраиваемого класса аннотацией
@NotNull вместо @Column(nullable=false), Hibernate не сгенерирует ограничения
NOT NULL для столбца таблицы коллекции. Проверка экземпляра механизмом Bean
Validation будет работать, как полагается; только в базе данных не будет правил
ограничения целостности. Используйте аннотацию @Column(nullable=false), ког-
да встраиваемый класс отображается в коллекции, а свойство должно быть ча-
стью первичного ключа.
Коллекции компонентов  191
Итак, класс компонента готов, и его можно использовать в отображениях кол-
лекций.
7.2.2. Множество компонентов
Множество (Set) компонентов отображется, как показано далее.
Листинг 7.12  Множество (Set) встраиваемых компонентов с переопределением
Файл: /model/src/main/java/org/jpwh/model/collections/setofembeddables/
Item.java
@Entity
public class Item {
@ElementCollection  Обязательная аннотация
@CollectionTable(name = "IMAGE")  Переопределяет имя таблицы коллекции
@AttributeOverride(
name = "filename",
column = @Column(name = "FNAME", nullable = false)
)
protected Set<Image> images = new HashSet<Image>();
// ...
}
Как и раньше, аннотация @ElementCollection  обязательна. По объявлению
параметризованной коллекции Hibernate автоматически определит, что целевым
типом коллекции является встраиваемый (@Embeddable) тип.
Аннотация @CollectionTable  переопределяет имя таблицы по умолчанию, ко-
торая иначе называлась бы ITEM_IMAGES.
Отображение класса Image определяет столбцы таблицы коллекции. Так же как
в случае с единственным значением встраиваемого типа, для настройки отображе-
ния без изменения целевого встраиваемого класса можно применить аннотацию
@AttributeOverride. Взгляните на схему базы данных на рис. 7.7.
ITEM
ID
1
NAME
Foo
2
3
B
C
IMAGE
TITLE
Foo
FNAME
foo.jpg
Bar
Baz
bar.jpg
baz.jpg
ITEM_ID
1
1
1
WIDTH HEIGHT
640 480
800 600
1024 768
2 B b.jpg 640 480
Рис. 7.7  Таблица с данными
для примера с коллекцией компонентов
Поскольку отображается множество, первичный ключ таблицы коллекции бу-
дет составлен из столбца внешнего ключа ITEM_ID и всех «встроенных» столбцов,
которые не могут содержать null: TITLE, FNAME, WIDTH и HEIGHT.
192  Отображение коллекций и связей между сущностями
Значение ITEM_ID не используется в переопределенных методах equals() и hash-
Code() класса Image, как было показано в предыдущем разделе. Следовательно,
смешав изображения различных товаров в одном множестве, вы столкнетесь
с проблемой определения равенства на Java-уровне. Очевидно, в базе данных
можно отличить изображения разных товаров, поскольку идентификатор товара
участвует в проверках равенства первичных ключей.
Чтобы использовать объект Item в процедуре проверки равенства класса Image
для соответствия проверке равенства первичного ключа в базе данных, необходи-
мо добавить свойство Image#item. Это простой указатель на сущность-владельца,
предоставляемый Hibernate во время загрузки экземпляров Image:
Файл: /model/src/main/java/org/jpwh/model/collections/setofembeddables/
Image.java
@Embeddable
public class Image {
@org.hibernate.annotations.Parent
protected Item item;
// ...
}
Теперь вы сможете использовать родительский экземпляр Item в реализации
методов equals() и hashCode() и выполнять сравнение, например так: this.get-
Item().getId().equals(other.getItem().getId()). Но будьте осторожны: если объ-
ект Item еще не был сохранен, он не имеет идентификатора; мы глубже изучим эту
проблему далее в разделе 10.3.2.
Чтобы упорядочить элементы во время загрузки и сохранить постоянный по-
рядок обхода в LinkedHashSet, используйте JPA-аннотацию @OrderBy:
Файл: /model/src/main/java/org/jpwh/model/collections/
setofembeddablesor-derby/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@OrderBy("filename, width DESC")
protected Set<Image> images = new LinkedHashSet<Image>();
// ...
}
Аргументы аннотации @OrderBy – это список полей класса Image, за которыми
следует либо строка ASC для упорядочивания по возрастанию, либо DESC для упо-
рядочивания по убыванию. По умолчанию упорядочение происходит по возраста-
нию, следовательно, в данном примере элементы упорядочены (по возрастанию)
сначала по имени файла, а затем по ширине изображения. Обратите внимание на
отличия от аннотации @org.hibernate.annotations.OrderBy, параметр которой яв-
ляется обычным SQL-предложением, как было показано в разделе 7.1.8.
Коллекции компонентов  193
Возможно, что объявление всех свойств класса Image как @NotNull – это не то,
что вам надо. Если какое-либо из полей является необязательным, вам понадобит-
ся определить другой первичный ключ для таблицы коллекции.
7.2.3. Контейнер компонентов
Вы уже применяли аннотацию @org.hibernate.annotations.CollectionId ранее для
добавления столбца суррогатного ключа в таблицу коллекции. Но типом коллек-
ции был не Set, а Collection, т. е. контейнер. Это согласуется с обновленной схе-
мой: если у вас есть столбец суррогатного первичного ключа, «значения элемен-
тов» могут повторяться. Давайте разберем это на примере.
Во-первых, класс Image теперь может иметь свойства со значениями null:
Файл: /model/src/main/java/org/jpwh/model/collections/bagofembeddables/
Image.java
@Embeddable
public class Image {
@Column(nullable = true) Может содержать null, если задан суррогатный первичный ключ
protected String title;
@Column(nullable = false)
protected String filename;
protected int width;
protected int height;
// ...
}
Не забудьте принять во внимание необязательность значения title объекта
Image в переопределяемых методах equals() и hashCode(), когда будете сравнивать
экземпляры «по значению».
Далее показано отображение контейнера в классе Item:
Файл: /model/src/main/java/org/jpwh/model/collections/bagofembeddables/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@org.hibernate.annotations.CollectionId(
columns = @Column(name = "IMAGE_ID"),
type = @org.hibernate.annotations.Type(type = "long"),
generator = Constants.ID_GENERATOR)
protected Collection<Image> images = new ArrayList<Image>();
// ...
}
194  Отображение коллекций и связей между сущностями
Особенности Hibernate
Так же как в разделе 7.1.5, с помощью аннотации @org.hibernate.annotations.CollectionId
объявлен дополнительный столбец суррогатного первичного ключа IMAGE_
ID. Схема базы данных показана на рис. 7.8.
ITEM
ID
1
NAME
Foo
2
3
B
C
IMAGE
TITLE
Foo
FILENAME
foo.jpg
Baz
bar.jpg
baz.jpg
ITEM_ID
1
1
1
WIDTH HEIGHT
640 480
800 600
1024 768
2 B b.jpg 640 480
IMAGE_ID
1
2
3
5
4 1 Baz baz.jpg 1024 768
Рис. 7.8  Таблица коллекции компонентов
со столбцом суррогатного первичного ключа
Поле title экземпляра Image с идентификатором 2 содержит null.
Далее мы увидим другой способ изменения первичного ключа таблицы коллек-
ции с помощью словаря (Map).
7.2.4. Словарь с компонентами в качестве значений
Если хранить экземпляры Image в коллекции Map, на роль ключа можно выбрать
имя файла:
Файл: /model/src/main/java/org/jpwh/model/collections/
mapofstringsembeddables/Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
@MapKeyColumn(name = "FILENAME") Необязательная аннотация; имя по умолчанию IMAGES_KEY
protected Map<String, Image> images = new HashMap<String, Image>();
// ...
}
Теперь первичный ключ таблицы коллекции состоит из столбца внешнего клю-
ча ITEM_ID и ключа словаря FILENAME, как показано на рис. 7.9.
Встраиваемый класс Image отображает оставшиеся столбцы, которые могут со-
держать null:
Файл: /model/src/main/java/org/jpwh/model/collections/
mapofstringsembeddables/Image.java
@Embeddable
public class Image {
Коллекции компонентов  195
@Column(nullable = true) Может содержать null; не входит в состав первичного ключа
protected String title;
protected int width;
protected int height;
// ...
}
ITEM
ID
1
NAME
Foo
2
3
B
C
IMAGE
FILENAME
foo.jpg
bar.jpg
baz.jpg
ITEM_ID
1
1
1
WIDTH HEIGHT
640 480
800 600
1024 768
2 b.jpg 640 480
TITLE
Foo
Baz
B
Рис. 7.9  Таблицы базы данных для словаря компонентов
В предыдущем примере значениями элементов словаря были экземпляры клас-
са встраиваемого компонента, а ключами – обычные строки. Теперь попробуем
использовать в качестве ключей и значений встраиваемые типы.
7.2.5. Компоненты в роли ключей словаря
В последнем примере рассмотрим отображение словаря (Map), ключи и значения
которого хранят значения встраиваемых типов данных, как показано на рис. 7.10.
title : String
width : int
height : int
Image
0..*
Item
name : String
extension : String
Filename
<<Map Key>>
Рис. 7.10  Класс Item содержит коллекцию Map
с ключами типа Filename
Для представления имени файла вместо строки можно выбрать пользователь-
ский тип, как показано далее.
Листинг 7.13  Представление имени файла пользовательским типом
Файл: /model/src/main/java/org/jpwh/model/collections/mapofembeddables/
Filename.java
@Embeddable
public class Filename {
196  Отображение коллекций и связей между сущностями
@Column(nullable = false)
protected String name;
@Column(nullable = false)
protected String extension;
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Filename filename = (Filename) o;
if (!extension.equals(filename.extension)) return false;
if (!name.equals(filename.name)) return false;
return true;
}
@Override
public int hashCode() {
int result = name.hashCode();
result = 31 * result + extension.hashCode();
return result;
}
// ...
}
Чтобы использовать этот класс в качестве ключей словаря, отображаемые
столбцы в базе данных не должны поддерживать хранения значения null, посколь-
ку являются частями составного первичного ключа. Также необходимо переопре-
делить методы equals() и hashCode(), так как ключи словаря являются элементами
множества и каждый объект Filename должен быть уникальным в пределах мно-
жества ключей.
Специальных аннотаций для отображения коллекции не требуется.
Файл: /model/src/main/java/org/jpwh/model/collections/mapofembeddables/
Item.java
@Entity
public class Item {
@ElementCollection
@CollectionTable(name = "IMAGE")
protected Map<Filename, Image> images = new HashMap<Filename, Image>();
// ...
}
Аннотации @MapKeyColumn и @AttributeOverrides здесь не могут использовать-
ся; когда роль ключа играет встраиваемый (@Embeddable) класс, эти аннотации не
окажут никакого влияния. Составной первичный ключ таблицы IMAGE включает
столбцы IMAGE_ID, NAME и EXTENSION, как показано на рис. 7.11.
Должны иметь ограничение NOT NULL:
части первичного ключа
Коллекции компонентов  197
ITEM
ID
1
NAME
Foo
2
3
B
C
IMAGE
NAME
foo
bar
baz
ITEM_ID
1
1
1
WIDTH HEIGHT
640 480
800 600
1024 768
2 b 640 480
TITLE
Foo
Baz
B
EXTENSION
jpg
jpg
jpg
jpg
Рис. 7.11  Таблицы базы данных для коллекции Map
с экземплярами Image и ключами типа Filename
Такой встраиваемый класс, как Image, не ограничен свойствами простых типов.
Вы уже видели на примере класса City в классе Address, как можно делать компо-
ненты вложенными. Можно извлечь и инкапсулировать свойства width и height
класса Image в новом классе Dimensions.
Встраиваемый класс также может содержать коллекции.
7.2.6. Коллекции во встраиваемых компонентах
Предположим, что нужно хранить список контактов для каждого адреса (Address).
Это простое множество типа Set<String> во встраиваемом классе:
Файл: /model/src/main/java/org/jpwh/model/collections/
embeddablesetofstrings/Address.java
@Embeddable
public class Address {
@NotNull
@Column(nullable = false)
protected String street;
@NotNull
@Column(nullable = false, length = 5)
protected String zipcode;
@NotNull
@Column(nullable = false)
protected String city;
@ElementCollection
@CollectionTable(
name = "CONTACT", По умолчанию USER_CONTACTS
joinColumns = @JoinColumn(name = "USER_ID")) Значение по умолчанию
@Column(name = "NAME", nullable = false) По умолчанию – CONTACTS
protected Set<String> contacts = new HashSet<String>();
// ...
}
Единственная обязательная аннотация – @ElementCollection; таблица и столб-
цы могут называться по умолчанию. Взгляните на схему на рис. 7.12: столбец
USER_ID имеет ограничение по внешнему ключу, ссылающемуся на таблицу сущ-
198  Отображение коллекций и связей между сущностями
ности-владельца USERS. Первичный ключ таблицы коллекции состоит из столбцов
USER_ID и NAME, что не позволяет дублировать элементы в соответствии с семанти-
кой коллекции Set.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
USERS
USER_ID << PK >> << FK >>
NAME << PK >>
<< Table >>
CONTACT
Рис. 7.12  Ограничение столбца USER_ID по внешнему ключу,
ссылающемуся на таблицу USERS
Вместо коллекции Set можно выбрать отображение списка, контейнера или
словаря, параметризованных простыми типами. Также Hibernate поддерживает
коллекции встраиваемых типов, поэтому вместо хранения контактной информа-
ции в строках можно написать встраиваемый класс Contact и добавить в класс Address
коллекцию с типом Contact.
Несмотря на то что Hibernate дает большую гибкость в выборе способов
отображения
компонентов и хорошо детализированных моделей, помните, что
код читают гораздо чаще, чем пишут. Подумайте о следующем программисте, ко-
торый будет поддерживать все это через несколько лет.
Пришло время переключить наше внимание на связи между сущностями,
в частности на простые связи многие к одному и один ко многим.
7.3. Отображение связей между сущностями
В начале главы мы пообещали обсудить отношения родитель/потомок. До сих пор
мы отображали только сущность Item. Пусть она будет родителем. В ней содер-
жится коллекция потомков – экземпляров Image. Термин родитель/потомок под-
разумевает некоторую зависимость жизненных циклов, поэтому вполне подойдет
коллекция строк или встраиваемых компонентов. Потомки целиком зависят от
родителей: они сохраняются, обновляются и удаляются всегда только вместе с ро-
дителем, а не сами по себе. Вот мы и отобразили отношение родитель/потомок!
В роли родителя выступила сущность, а множеством ее детей были экземпляры
типа-значения.
Теперь отобразим отношение другого рода: связь между двумя классами сущ-
ностей. Их экземпляры существуют независимо. Один объект может сохраняться,
обновляться и удаляться, никак не влияя на другой. Естественно, иногда возника-
ют зависимости и между экземплярами сущностей. Нам нужен более тонкий контроль
над тем, как отношение между двумя классами влияет на состояние экзем-
пляров не полностью зависимых (встроенных) типов. Но не выходим ли мы при
этом за рамки отношения родитель/потомок? Получается, что понятие родитель/
потомок очень расплывчатое, и каждый определяет его по-своему. Мы постара-
Отображение связей между сущностями  199
емся больше не использовать этого термина, полагаясь на более точную или, по
крайней мере, достаточно конкретную терминологию.
В следующих разделах мы будем рассматривать одно и то же отношение: между
классами сущностей Item и Bid, как показано на рис. 7.13. Между классами Bid
и Item определена связь многие к одному.
Item Bid
Рис. 7.13  Отношение между классами Item и Bid
Позже мы сделаем эту связь двунаправленной, связав Item и Bid отношением
один ко многим.
Связь многие к одному проще, поэтому начнем с нее. Другие виды связей – мно-
гие ко многим и один к одному – сложнее, поэтому мы рассмотрим их в следующей
главе.
Начнем со связи многие к одному.
7.3.1. Самая простая связь
Мы называем отображение свойства Bid#item однонаправленной связью многие
к одному. Прежде чем начать обсуждение этого отображения, взгляните на схему
базы данных на рис. 7.14.
ID << PK >>
NAME
...
<< Table >>
ITEM ID << PK >>
ITEM_ID << FK >>
AMOUNT
...
<< Table >>
BID
Рис. 7.14  Отношение многие к одному в схеме SQL
Листинг 7.14  У объекта Bid определена единственная ссылка на объект Item
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
bidirectional/Bid.java
@Entity
public class Bid {
@ManyToOne(fetch = FetchType.LAZY) По умолчанию – EAGER
@JoinColumn(name = "ITEM_ID", nullable = false)
protected Item item;
// ...
}
Аннотация @ManyToOne отмечает свойство как связь с сущностью и не являет-
ся обязательной. К сожалению, параметр fetch по умолчанию получает значение
EAGER:
это значит, что вместе с экземпляром Bid всегда загружается связанный эк-
200  Отображение коллекций и связей между сущностями
земпляр Item. Как правило, в качестве стратегии по умолчанию мы предпочитаем
отложенную загрузку; но об этом мы поговорим в разделе 12.1.1.
Связь многие к одному прекрасно отображается в столбец внешнего ключа: ITEM_
ID в таблице BID. В JPA это называется столбцом соединения (join column). Для ее
объявления достаточно только аннотации @ManyToOne. По умолчанию столбец со-
единения получает имя ITEM_ID: Hibernate автоматически использует комбинацию
из имени целевой сущности и ее свойства-идентификатора, разделенных подчер-
киванием.
Имя столбца внешнего ключа можно переопределить, используя аннотацию
@JoinColumn. Но мы применили ее здесь по иной причине – чтобы при создании
схемы SQL фреймворк Hibernate добавил в столбец внешнего ключа ограничение
NOT NULL. Ставка всегда должна иметь ссылку на товар – она не может существовать
сама по себе (обратите внимание, что это уже указывает на некоторый вид зависи-
мости жизненного цикла, который нужно учитывать). С другой стороны, мы мог-
ли отметить эту ассоциацию как обязательную – с помощью @ManyToOne(optional =
false) или, как обычно, с помощью аннотации @NotNull из Bean Validation.
Это было довольно просто. Чрезвычайно важно понимать, что вы можете созда-
вать полноценные и сложные приложения, не используя ничего другого.
Отображать другую сторону данного отношения не обязательно; вы можете
проигнорировать связь многие к одному от Item к Bid. В схеме базы данных есть
только столбец внешнего ключа, который вы уже отобразили. Мы говорим се-
рьезно: когда вам встретятся столбец внешнего ключа и два класса, участвующих
в отношении сущностей, вы, скорее всего, должны отобразить их с помощью @
ManyToOne
и ничего более. Теперь можно получить товар (Item) для каждой ставки
(Bid), вызвав someBid.getItem(). Реализация JPA разыменует внешний ключ и за-
грузит экземпляр Item за вас; она также возьмет на себя управление значениями
внешних ключей. Но как теперь получить все ставки для товара? Для этого мож-
но написать запрос и выполнить его с помощью объекта EntityManager, используя
любой язык запросов, какой поддерживает Hibernate. Например, на JPQL можно
написать: select b from Bid b where b.item = :itemParameter. Одна из причин, почему
вы выбрали полноценный инструмент ORM, такой как Hibernate, состоит в неже-
лании создавать и выполнять этот запрос самим.
7.3.2. Определение двунаправленной связи
В начале главы мы привели доводы в пользу отображения коллекции Item#images.
Сделаем то же для коллекции Item#bids. Эта коллекция станет реализацией отно-
шения один ко многим между классами сущностей Item и Bid. Создав и отобразив
поле этой коллекции, вы получите следующее:
 Hibernate автоматически будет выполнять SQL-запрос SELECT * from BID
where ITEM_ID = ? при вызове метода someItem.getBids() или в начале обхода
элементов коллекции;
 вы сможете: каскадно передавать изменения состояния от экземпляра Item ко
всем дочерним экземплярам Bid в коллекции; сами выбирать, какие собы-
Отображение связей между сущностями  201
тия жизненного цикла должны быть транзитивными, например объявить,
что все дочерние объекты Bid должны сохраняться вместе с родительски-
ми экземплярами Item, чтобы не приходилось вызывать метода EntityManager#
persist() повторно для каждого элемента коллекции.
Что ж, это не очень длинный список. Главным преимуществом отображения
один ко многим является поддержка доступа к данным во время навигации. Обеспечение
доступа к данным только посредством вызова методов предметной мо-
дели на Java является одной из основных целей ORM. Как предполагается, за
«интеллектуальную» загрузку данных должен отвечать механизм ORM, а ваша
задача – работать с собственноручно спроектированными высокоуровневыми ин-
терфейсами: someItem.getBids().iterator().next().getAmount() и т. д.
Возможность каскадной передачи некоторых изменений дочерним экземпля-
ром является приятным дополнением. Тем не менее обратите внимание, что неко-
торые зависимости на уровне Java указывают на типы-значения, а не на сущности.
Спросите себя: будет ли хоть одна таблица в схеме иметь столбец внешнего ключа
BID_ID? Если нет, отобразите класс Bid как встраиваемый с аннотацией @Embeddable,
а не @Entity, используя те же таблицы, что и прежде, но с другими отобра-
жениями, задающими конкретные правила передачи изменений состояния. Если
в какой-нибудь таблице есть внешний ключ, ссылающийся на записи в таблице
BID, вам потребуется разделяемая сущность Bid – в таком случае она не может ото-
бражаться как встроенная в Item.
Нужно ли вообще отображать коллекцию Item#bids? Вы, конечно, получаете
доступ к данным при навигации, но за это придется заплатить дополнительным
Java-кодом и значительным увеличением сложности. Почти всегда это будет не-
простой выбор. Как часто вы будете вызывать someItem.getBids() в своем при-
ложении, а затем обходить/отображать все ставки в предопределенном порядке?
Если вам потребуется показать лишь подмножество ставок или извлекать их каж-
дый раз в разном порядке, вам все равно придется писать и выполнять запросы
вручную. Отображение один ко многим и соответствующая коллекция только ус-
ложнят сопровождение. По нашему опыту это часто становится источником про-
блем и ошибок, особенно среди новичков в ORM.
В случае приложения CaveatEmptor ответ будет положительным: нам часто
придется вызывать метод someItem.getBids() и передавать список ставок пользо-
вателю, желающему участвовать в аукционе. Обновленная диаграмма UML с дву-
направленной связью показана на рис. 7.15.
Отображение коллекции и другой стороны связи один ко многим выглядит так.
Листинг 7.15  В классе Item объявлена коллекция ссылок на Bid
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
bidirectional/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item", Требуется для двунаправленной связи
202  Отображение коллекций и связей между сущностями
fetch = FetchType.LAZY) Значение по умолчанию
protected Set<Bid> bids = new HashSet<>();
// ...
}
Item 0..* Bid
Рис. 7.15  Двунаправленная связь между классами Item и Bid
Аннотация @OneToMany является обязательной. В данном случае мы также долж-
ны задать значение параметра mappedBy. Аргументом является имя поля на «другой
стороне».
Взгляните еще раз на другую сторону отношения многие к одному в листин-
ге 7.15. Свойство в классе Bid называется item. На стороне ставки (Bid) оно от-
вечает за столбец внешнего ключа ITEM_ID, отображаемого аннотацией @ManyToOne.
Параметр mappedBy сообщает Hibernate, что данную коллекцию нужно загружать,
используя столбец внешнего ключа, соответствующий этому полю, в данном слу-
чае Bid#item. Параметр mappedBy обязательно должен определяться для двунаправ-
ленных отношений один ко многим, если вы уже отобразили столбец внешнего
ключа. Мы вернемся к этому обсуждению в следующей главе.
По умолчанию параметр fetch отображения коллекции получает значение
FetchType.LAZY. В будущем этот параметр вам не понадобится. Ему также можно
присвоить значение EAGER, но оно редко применяется на практике – нечасто тре-
буется, чтобы вместе с экземпляром Item загружалась вся коллекция ставок bids.
Они должны загружаться при обращении, то есть по требованию.
Вторая причина отображения коллекции Item#bids – возможность каскадной
передачи изменений состояния.
7.3.3. Каскадная передача состояния
Если изменение состояния сущности можно каскадно передать через связь с дру-
гой сущностью, для управления отношениями вам потребуется меньше строк кода.
Далее показан код, создающий экземпляры Item и Bid и связывающий их вместе:
Item someItem = new Item("Some Item");
Bid someBid = new Bid(new BigDecimal("123.00"), someItem);
someItem.getBids().add(someBid); Не забывайте!
Помните об обеих сторонах отношения: конструктор класса Bid принимает
ссылку на товар, которая присваивается свойству Bid#item. Для поддержания
целостности экземпляров в памяти вы должны добавить ссылку на ставку в кол-
лекцию Item#bids. Теперь, с точки зрения Java-кода, связь установлена, все ссылки
присвоены. Если вы не понимаете, зачем нужен этот код, прочитайте раздел 3.2.4.
Давайте сохраним товар со всеми ставками в базу данных – сначала без, а затем
с применением механизма транзитивного сохранения.
Отображение связей между сущностями  203
Транзитивное сохранение
С текущими отображениями @ManyToOne и @OneToMany для сохранения экземпля-
ра Item и нескольких экземпляров Bid нам потребуется следующий код.
Листинг 7.16  Раздельное управление независимыми экземплярами сущностей
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyBidirectional.java
Item someItem = new Item("Some Item");
em.persist(someItem);
Bid someBid = new Bid(new BigDecimal("123.00"), someItem);
someItem.getBids().add(someBid); Не забывайте!
em.persist(someBid);
Bid secondBid = new Bid(new BigDecimal("456.00"), someItem);
someItem.getBids().add(secondBid);
em.persist(secondBid);
tx.commit(); Проверка изменений; выполнение кода SQL
При создании нескольких ставок вызывать метод persist() для каждого объ-
екта кажется излишеством. Новые экземпляры являются временными (transient)
и должны сохраняться. Отношение между Bid и Item не влияет на их жизненный
цикл. Если бы класс Bid был типом-значением, состояние экземпляра Bid автома-
тически соответствовало бы состоянию сущности-владельца Item. В нашем случае
экземпляр Bid обладает собственным, полностью независимым состоянием.
Мы говорили выше, что для представления зависимостей между связанными
классами сущностей иногда требуется возможность управления на более низком
уровне; это как раз такой случай. Механизмом такого управления в JPA является
параметр cascade. Например, чтобы сохранить все ставки вместе с товаром, отобразите
коллекцию, как показано далее.
Листинг 7.17  Каскадная передача состояния хранения от экземпляра Item
каждому элементу коллекции bids
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
cascadepersist/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item", cascade = CascadeType.PERSIST)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Тип каскадной передачи выбирается для операций, которые, по вашему мнению,
должны быть транзитивными, поэтому здесь для операции EntityManager#persist()
используется значение CascadeType.PERSIST. Теперь код, связывающий товар со
ставками и сохраняющий их, можно упростить.
204  Отображение коллекций и связей между сущностями
Листинг 7.18  Все элементы коллекции bids сохраняются автоматически
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyCascadePersist.java
Item someItem = new Item("Some Item");
em.persist(someItem); Автоматически сохранит ставку (позже, во время выталкивания контекста)
Bid someBid = new Bid(new BigDecimal("123.00"), someItem);
someItem.getBids().add(someBid);
Bid secondBid = new Bid(new BigDecimal("456.00"), someItem);
someItem.getBids().add(secondBid);
tx.commit(); Проверка изменений; выполнение кода SQL
В момент подтверждения транзакции Hiberante проверяет все управляе-
мые/хранимые экземпляры Item, а также коллекцию bids. Затем сам вызывает
метод persist() для каждого зависимого экземпляра Bid, сохраняя их. Значе-
ние для столбца BID#ITEM_ID извлекается из свойства Bid#item каждого объекта
Bid. Столбец внешнего ключа «отображается» с помощью аннотации @ManyToOne
над ним.
Аннотация @ManyToOne также имеет параметр cascade. Но он редко используется
на практике. Например, мы же не можем сказать: «когда сохраняется ставка, нуж-
но сохранить и товар». Товар уже должен существовать, иначе ставка не пройдет
проверку в базе данных. Подумайте еще об одном возможном отношении @ManyToOne:
свойстве Item#seller, ссылающемся на продавца. Пользователь (User) дол-
жен существовать раньше, чем он сможет продать товар (Item).
Транзитивное сохранение (transitive persistence) – простое понятие, которое
часто оказывается полезным при работе с отображениями @OneToMany или @ManyTo-
Many. Транзитивное удаление (transitive deletion), с другой стороны, нужно при-
менять крайне осторожно.
Каскадное удаление
Кажется разумным вместе с товаром удалять все его ставки, поскольку сами
по себе они бессмысленны. Именно это и означает композиция (закрашенный
ромбик) на UML-диаграмме. С текущими настройками каскадной обработки мы
должны написать следующий код для удаления товара:
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyCascadePersist.java
Item item = em.find(Item.class, ITEM_ID);
for (Bid bid : item.getBids()) {
em.remove(bid);  Удаляет ставки
}
em.remove(item);  Удаляет владельца
Отображение связей между сущностями  205
Сначала нужно удалить ставки , а затем и владельца Item . Порядок удале-
ния важен. Если сначала удалить объект Item, получится нарушение ограничения
по внешнему ключу, поскольку операции SQL добавляются в очередь в том же по-
рядке, что и вызовы remove(). Поэтому сначала нужно удалить записи из таблицы
BID и только затем запись из таблицы ITEM.
Чтобы облегчить эту работу, JPA предоставляет поддержку каскадирования
операций. Механизм хранения может удалять связанные экземпляры сущностей
автоматически.
Листинг 7.19  Каскадное удаление всех элементов коллекции bids объекта Item
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
cascaderemove/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item",
cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
protected Set<Bid> bids = new HashSet<>();
// ...
}
Так же как и раньше для значения PERSIST, Hibernate теперь каскадно будет
выполнять операцию remove() для этого отношения. Если вызвать метод EntityManager#
remove() объекта Item, Hibernate загрузит элементы коллекции bids и для
каждого экземпляра вызовет метод remove():
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyCascadeRemove.java
Item item = em.find(Item.class, ITEM_ID);
em.remove(item); После загрузки ставок удаляет их по одной
Коллекция должна быть загружена, потому что каждый объект Bid – это экзем-
пляр независимой сущности, который должен пройти через обычный жизненный
цикл. Если в классе Bid есть метод обратного вызова с аннотацией @PreRemove, Hibernate
должен его вызвать. Больше о состоянии объектов и обратных вызовах вы
узнаете в главе 13.
Такой процесс удаления неэффективен: Hibernate должен всегда сначала за-
грузить коллекцию, а затем удалить каждый объект Bid индивидуально. Однако
с тем же эффектом можно выполнить единственное SQL-выражение: delete from
BID where ITEM_ID = ?.
Нам это известно, поскольку в базе данных нет ни одной таблицы с внешним
ключом, ссылающимся на таблицу BID. Hibernate этого не знает и не может искать
по всей базе данных запись, в которой может быть столбец BID_ID.
206  Отображение коллекций и связей между сущностями
Если бы поле Item#bids было коллекцией встраиваемых компонентов, вызов
someItem.getBids().clear() выполнил бы единственную SQL-операцию DELETE.
В случае коллекции типов-значений Hibernate полагает, что, скорее всего, никто
не может ссылаться на экземпляры ставок, и простое удаление ссылки из коллек-
ции превратит их в «осиротевшие» объекты.
Удаление осиротевших объектов
JPA поддерживает (спорный) флаг, определяющий одинаковое поведение для
связей @OneToMany (и только @OneToMany).
Листинг 7.20  Удаление осиротевших объектов из коллекции @OneToMany
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
orphanremoval/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item",
cascade = CascadeType.PERSIST,
orphanRemoval = true) Включает CascadeType.REMOVE
protected Set<Bid> bids = new HashSet<>();
// ...
}
Аргумент orphanRemoval=true сообщает фреймворку Hibernate, что тот должен
навсегда удалять объекты Bid при удалении их из коллекции. Вот пример удале-
ния одного экземпляра Bid:
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyOrphanRemoval.java
Item item = em.find(Item.class, ITEM_ID);
Bid firstBid = item.getBids().iterator().next();
item.getBids().remove(firstBid); Одна ставка удалена
Hibernate постоянно отслеживает состояние коллекции, поэтому в момент под-
тверждения транзакции он обнаружит, что оттуда был удален элемент. Теперь
Hibernate будет считать, что объект Bid – это осиротевший объект. Вы должны
гарантировать, что больше никто не будет на него ссылаться; единственной ссыл-
кой была только что удаленная из коллекции. Hibernate автоматически выполнит
SQL-операцию DELETE и удалит экземпляр Bid из базы данных.
Но метод clear() по-прежнему не будет выполняться за одну операцию DELETE,
как в случае с коллекцией компонентов. Hibernate не нарушает стандартных пере-
ходов между состояниями сущности, и каждая ставка загружается и удаляется
индивидуально.
Но почему удаление осиротевших объектов считается сомнительной операци-
ей? В данном примере она как раз уместна. Пока в базе данных нет ни одной табОтображение
связей между сущностями  207
лицы, внешний ключ которой ссылался бы на таблицу BID, удаление записи из
таблицы BID не вызовет последствий; все ссылки на ставки, хранящиеся в памяти,
находятся в коллекции Item#bids. До тех пор, пока выполняются эти условия, уда-
ление осиротевших объектов не представляет проблемы. Это удобно, например,
когда уровень представления может изъять элемент из коллекции для удаления
чего-нибудь; вы работаете только с экземплярами предметной модели, и вам не
нужно вызывать службу для этой операции.
Посмотрим теперь, что произойдет, если определить поле User#bids – другое
отображение коллекции @OneToMany, показанное на рис. 7.16. Кстати, это хороший
повод проверить ваши знания: как будут выглядеть таблицы и схема после этого
изменения? (Ответ: в таблице BID появится столбец внешнего ключа BIDDER_ID,
ссылающийся на таблицу USERS.)
Item 0..* Bid 0..* User
Рис. 7.16  Двунаправленные связи
между классами Item, Bid и User
Тест в следующем листинге потерпит неудачу.
Листинг 7.21  Hibernate не очищает ссылки в памяти после удаления из базы
данных
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToManyOrphanRemoval.java
User user = em.find(User.class, USER_ID);
assertEquals(user.getBids().size(), 2); Пользователь сделал две ставки
Item item = em.find(Item.class, ITEM_ID);
Bid firstBid = item.getBids().iterator().next();
item.getBids().remove(firstBid); Одна ставка удалена
// ТЕСТ НЕ ПРОЙДЕТ!
// assertEquals(user.getBids().size(), 1);
assertEquals(user.getBids().size(), 2); Их по-прежнему две!
Hibernate считает, что удаленный объект Bid осиротел и его можно удалить;
он будет удален из базы данных автоматически, но в коллекции User#bids име-
ется вторая ссылка на него. После подтверждения этой транзакции база данных
останется в корректном состоянии; запись, удаленная из таблицы BID, содержала
оба внешних ключа: ITEM_ID и BIDDER_ID. Но в оперативной памяти вы получите
противоречивое состояние, поскольку фраза «Удали этот экземпляр при удалении
ссылки из коллекции» естественно вызовет конфликт при использовании разде-
ляемых ссылок.
208  Отображение коллекций и связей между сущностями
Вместо удаления осиротевших объектов или параметра CascadeType.REMOVE
всегда ищите более простое отображение. В данном примере поле Item#bids мож-
но представить в виде коллекции компонентов, отображаемой аннотацией @ElementCollection.
Класс Bid был бы тогда встраиваемым (@Embeddable) и имел бы
свойство bidder с аннотацией @ManyToOne, ссылающееся на экземпляр User (встра-
иваемые компоненты могут определять однонаправленные связи, направленные
к сущностям).
Это дало бы требуемый жизненный цикл – полную зависимость от сущности-
владельца. Избегайте разделяемых ссылок; на UML-диаграмме (рис. 7.16) связь
от класса Bid к классу User сделана однонаправленной. Избавьтесь от коллекции
User#bids – это отображение @OneToMany не нужно. Если вам нужны все ставки, сде-
ланные пользователем, создайте запрос: select b from Bid b where b.bidder = :userParameter
(в следующей главе мы дополним это отображение аннотацией @ManyToOne
во встраиваемом компоненте).
Особенности Hibernate
Использование ON DELETE CASCADE для внешнего ключа
Все продемонстрированные операции удаления неэффективны – каждая став-
ка должна загружаться в память, и нужно выполнять много SQL-операций DELETE.
Базы данных SQL оказывают более эффективную поддержку внешнего ключа:
параметр ON DELETE. Для таблицы BID на языке DDL это выглядит так: foreign key
(ITEM_ID) references ITEM on delete cascade.
Этот параметр говорит базе данных, что нужно поддерживать прозрачную ссы-
лочную целостность для приложения, обращающегося к базе данных. Когда бы вы
ни удалили запись из таблицы ITEM, база данных автоматически удалит из таблицы
BID все записи с таким же значением ключа ITEM_ID. Для рекурсивного удаления
всех зависимых данных потребуется только одна операция DELETE, и ничего не при-
дется загружать в память приложения (сервера). Проверьте, включено ли это огра-
ничение для внешних ключей в вашей схеме. Если вы захотите использовать его
в схеме, сгенерированной Hibernate, используйте Hibernate-аннотацию @OnDelete.
Листинг 7.22  Генерация схемы с ограничением внешнего ключа ON DELETE CASCADE
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
ondeletecascade/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item", cascade = CascadeType.PERSIST)
@org.hibernate.annotations.OnDelete(
action = org.hibernate.annotations.OnDeleteAction.CASCADE
)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Особенность Hibernate: параметры схемы
обычно задаются на «другой» стороне связи,
на которую указывает параметр «mappedBy»
Резюме  209
Мы видим здесь одну из особенностей Hibernate: аннотация @OnDelete влияет
только на схему, которую генерирует Hibernate. Настройки, влияющие на форми-
рование схемы, обычно находятся на «другой» стороне mappedBy – там, где опре-
деляется отображение внешнего ключа/столбца соединения. Соответствующая
аннотация @OnDelete обычно помещается рядом с @ManyToOne в классе Bid. Но если
связь двунаправленная, Hibernate распознает ее только на стороне @OneToMany.
Применение ограничения каскадного удаления для внешнего ключа в базе дан-
ных не влияет на поведение Hibernate во время выполнения. Вы можете столкнуться
с теми же проблемами, что и в листинге 7.21. Данные в памяти могут не
отражать состояния базы данных. Если все записи в таблице BID автоматически
удаляются при удалении записи из таблицы ITEM, тогда код приложения должен
очищать ссылки и синхронизировать данные в памяти с содержимым в базе дан-
ных. По неосторожности можно заново сохранить то, что было удалено до этого.
Экземпляры Bid не следуют стандартному жизненному циклу, и такие методы
обратных вызовов, как @PreRemove, не окажут никакого эффекта. Кроме того, Hibernate
не очищает необязательный глобальный кэш второго уровня автоматиче-
ски, что может привести к устареванию данных. По сути, все проблемы, с которы-
ми вы можете столкнуться, используя каскадные изменения для внешнего ключа
на уровне базы данных, такие же, как в случае, когда другое приложение, кроме
вашего, обращается к той же базе данных либо когда изменения вносит триггер
базы данных. Hibernate может быть очень эффективным инструментом в подоб-
ном случае, но не нужно забывать про остальные движущиеся части системы. Мы
подробнее рассмотрим многопоточность и кэширование позже в этой книге.
При разработке новой схемы проще не применять каскадных изменений на
уровне базы данных и отобразить отношение композиции в предметной модели
как встроенное/встраиваемое, а не как связь с сущностью. В этом случае Hibernate
сможет выполнять эффективные SQL-операции DELETE для удаления композиций
целиком. Повторим рекомендацию из предыдущего раздела: если можно избе-
жать использования общих ссылок, отображайте класс Big как @ElementCollection
в классе Item, а не как отдельную сущность со связями @ManyToOne и @OneToMany.
Конечно, можно вообще не отображать никаких коллекций, используя простей-
шее отображение: столбец внешнего ключа с аннотацией @ManyToOne и однонаправ-
ленную связь между классами сущностей (@Entity).
7.4. Резюме
 Вы познакомились со множеством интерфейсов и реализаций, использующих
простые отображения коллекций, такие как Set<String>.
 Вы узнали, как работают отсортированные коллекции, а также средства, при-
меняемые в Hibernate для получения элементов из базы данных в заданном
порядке.
 Мы обсудили сложные коллекции пользовательских встраиваемых типов,
а также множества, контейнеры и словари компонентов.
210  Отображение коллекций и связей между сущностями
 Вы увидели, как использовать компоненты в качестве ключей и значений
в словарях и как определять коллекции во встраиваемых компонентах.
 Отображение первого столбца внешнего ключа в связь с сущностью многие
к одному делает ее двунаправленной, так же как связь один ко многим. Вы также
узнали о возможности каскадной передачи изменений.
 Мы обсудили основные понятия объектно-реляционного отображения. По-
сле того как вы отобразите первую связь @ManyToOne и, возможно, коллекцию
строк, худшее окажется позади.
 Обязательно выполните код примеров (и загляните в журнал SQL)!
Глава 8
Продвинутые приемы
отображения связей
между сущностями
В этой главе:
 отображение связей вида один к одному;
 варианты отображения связи один ко многим;
 связь многие ко многим и тройные отношения между сущностями.
В предыдущей главе мы рассмотрели однонаправленную связь многие к одному,
сделали ее двунаправленной, а затем реализовали транзитивную передачу состоя-
ния посредством каскадирования. Причина, по которой мы обсуждаем более про-
двинутые приемы отображения сущностей в отдельной главе, заключается в том,
что многие из них редко находят практическое применение и почти всегда есть
возможность не использовать их. Обычно можно обойтись лишь отображениями
компонентов и связями между сущностями многие к одному (иногда один к одно-
му). Можно даже написать довольно сложное приложение, не отобразив ни одной
коллекции! В предыдущей главе мы перечислили определенные преимущества
отображения коллекций; эти же соображения относятся ко всем примерам данной
главы. Прежде чем начать реализацию сложного отображения коллекции, всегда
нужно убедиться в ее необходимости.
Начнем с отображения, в котором коллекции не задействованы, – связи сущ-
ностей вида один к одному.
Главные нововведения в JPA 2
• Связи многие к одному и один к одному теперь могут отображаться с помощью
промежуточной таблицы соединения.
• Классы встраиваемых компонентов могут иметь однонаправленные связи
с сущностями, даже когда они содержат коллекции компонентов.
212  Продвинутые приемы отображения связей между сущностями
8.1. Связи один к одному
В разделе 5.2 мы доказывали, что отношение между классами User и Address –
когда пользователь имеет платежный адрес (billingAddress), домашний адрес
(homeAddress) и адрес доставки (shippingAddress) – лучше представить в виде ото-
бражения встраиваемого (@Embeddable) компонента. Как правило, это простейший
способ представления отношений один к одному, поскольку в подобных случаях
реализуется зависимый жизненный цикл компонентов. На UML-диаграмме это
представлено либо агрегацией, либо композицией.
Но что, если создать отдельную таблицу ADDRESS, отображая классы User и Address
как отдельные сущности? Одним из преимуществ такого подхода является
возможность разделения ссылок: другая сущность, например Shipment (доставка),
сможет ссылаться на конкретный экземпляр класса Address. Если поле shipping-
Address объекта User будет ссылаться на этот же адрес, экземпляр Address должен
обладать собственной идентичностью для поддержки общих ссылок.
В таком случае между классами User и Address возникнет настоящая связь один
к одному. Взгляните на исправленную диаграмму классов на рис. 8.1.
Рис. 8.1  Класс Address как сущность с двумя связями,
допускающая разделение ссылок
Существует несколько способов отображения связи один к одному. Первая стра-
тегия, которую мы рассмотрим, заключается в использовании общего значения
первичного ключа.
8.1.1. Общий первичный ключ
Записи в двух таблицах, связанные по первичному ключу, имеют одинаковые зна-
чения первичных ключей. У пользователя (User) такой же первичный ключ, как
и у его адреса (доставки), объекта Address. Самое сложное в данном подходе – га-
рантировать присваивание связанным экземплярам одинакового значения пер-
вичного ключа. Прежде чем исследовать эту проблему, создадим основное отображение.
Класс Address – теперь самостоятельная сущность: он больше не является
компонентом.
Листинг 8.1  Класс Address как самостоятельная сущность
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/
sharedprimarykey/Address.java
@Entity
public class Address {
@Id
Связи один к одному  213
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull
protected String street;
@NotNull
protected String zipcode;
@NotNull
protected String city;
// ...
}
Класс User также является сущностью, связь в которой представлена полем
shippingAddress.
Листинг 8.2  Сущность User и ассоциация shippingAddress
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/
sharedprimarykey/User.java
@Entity
@Table(name = "USERS")
public class User {
@Id  По умолчанию EAGER
protected Long id;
@OneToOne(  Значение идентификатора присваивается приложением
fetch = FetchType.LAZY,
optional = false
)
@PrimaryKeyJoinColumn  Выбор стратегии общего первичного ключа
protected Address shippingAddress;
protected User() {
}
public User(Long id, String username) {  Требуется идентификатор
this.id = id;
this.username = username;
}
// ...
}
В классе User не нужно объявлять автоматическое создание идентификаторов
. Как было сказано в разделе 4.2.4, это один из немногих случаев, когда значение
идентификатора выбирается приложением. В строке  видно, как конструктор га-
рантирует это условие: публичный API требует указать значение идентификатора
при создании экземпляра.
В этом примере появились две новые аннотации. Аннотация @OneToOne , как
вы наверняка догадались, отмечает свойство с типом сущности как связь один
 Помечает поле с типом сущности
как ассоциацию один к одному
 Обязательно для поддержки
отложенной загрузки
с помощью прокси-объектов
214  Продвинутые приемы отображения связей между сущностями
к одному. Как обычно, желательно применять стратегию отложенной загрузки,
поэтому значение по умолчанию FetchType.EAGER заменяется на LAZY . Вторая
новая аннотация – @PrimaryKeyJoinColumn  – определяет требуемую стратегию
отображения с общим первичным ключом. В результате получается отображение
однонаправленной связи один к одному с общим первичным ключом, направлен-
ной от класса User к классу Address.
Параметр optional=false  указывает, что объект User должен иметь непустую
ссылку shippingAddress. Фреймворк Hibernate отразит этот факт в сгенерирован-
ной схеме базы данных с помощью ограничения внешнего ключа. Первичный
ключ таблицы USERS также является внешним ключом, ссылающимся на первич-
ный ключ таблицы ADDRESS. См. рис. 8.2.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
ADDRESS
ID << PK >> << FK >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
Рис. 8.2  Первичный ключ таблицы USERS
отдновременно является внешним ключом
Спецификация JPA не предоставляет стандартных методов создания общих
первичных ключей. А это значит, что только вы отвечаете за присваивание экземпляру
User такого же значения идентификатора, как у связанного объекта Address,
перед сохранением:
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToOneSharedPrimaryKey.java
Address someAddress =
new Address("Some Street 123", "12345", "Some City");
em.persist(someAddress); Формирует значение идентификатора
User someUser =
new User(
someAddress.getId(), Присваивает такое же значение идентификатора
"johndoe"
);
em.persist(someUser);
someUser.setShippingAddress(someAddress); Необязательно
После сохранения объекта Address нужно взять его идентификатор и присво-
ить его экземпляру User перед сохранением. Последняя строка в этом примере не
является обязательной, но поскольку код ожидает получить значение при вызове
someUser.getShippingAddress(), вы должны присвоить свойству значение. Hibernate
не сообщит об ошибке, если вы опустите этот последний шаг.
Связи один к одному  215
Данный способ отображения и его реализация имеют три проблемы:
 вы должны помнить, что объект Address нужно сохранять первым, а затем,
после вызова persist(), извлечь из него значение идентификатора. Это воз-
можно лишь в случае, когда в классе Address объявлен генератор иденти-
фикаторов, формирующий значения во время вызова persist(), но перед
выполнением INSERT, как обсуждалось в разделе 4.2.5. Иначе вызов someAddress.
getId() вернет null и вы не сможете вручную установить значение
идентификатора в объекте User;
 отложенная загрузка с помощью прокси-объектов будет работать, только
если связь является обязательной. Обычно это становится неожиданно-
стью для разработчиков, только начинающих работу с JPA. Для аннотации
@OneToOne по умолчанию используется режим загрузки FetchType.EAGER: при
загрузке экземпляра User Hibernate сразу же загрузит и shippingAddress.
Концептуально отложенная загрузка с помощью прокси-объектов имеет
смысл, лишь когда Hibernate знает о существовании объекта, связанного со
свойством shippingAddress. Если свойство может содержать null, Hibernate
должен проверять, не содержит ли поле в базе данных значения NULL, вы-
полняя запрос к таблице ADDRESS. Но если приходится проверять состояние
базы данных, можно сразу же загрузить значение, поскольку никакого вы-
игрыша от использования прокси-объекта не будет;
 связь один к одному – однонаправленная; иногда может потребоваться реа-
лизовать возможность двунаправленной навигации.
Первая проблема не имеет иного решения, и это одна из причин, почему следу-
ет использовать генератор идентификаторов, способный формировать значения
перед выполнением SQL-операции INSERT.
Ассоциация @OneToOne(optional=true) не поддерживает отложенную загрузку
данных с помощью прокси-объектов. Это соответствует спецификации JPA. Ар-
гумент аннотации FetchType.LAZY для реализации механизма хранения является
лишь просьбой, но не требованием. Можно обеспечить отложенную загрузку поля
@OneToOne, которое может содержать null, используя прием внедрения в байт-код,
как будет показано в разделе 12.1.3.
Что касается последней проблемы, сделать связь двунаправленной можно, ис-
пользуя оригинальный генератор идентификаторов Hibernate, помогающий при-
сваивать значения первичных ключей.
8.1.2. Генератор внешнего первичного ключа
Двунаправленное отображение всегда требует наличия отображаемой (mappedBy)
стороны. Здесь мы выберем сторону класса User (это дело вкуса и, возможно,
каких-то несущественных требований):
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/
foreigngenerator/User.java
@Entity
@Table(name = "USERS")
public class User {
216  Продвинутые приемы отображения связей между сущностями
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@OneToOne(
mappedBy = "user",
cascade = CascadeType.PERSIST
)
protected Address shippingAddress;
// ...
}
Сравните это отображение с предыдущим: здесь мы добавили параметр mappedBy,
сообщив Hibernate, что низкоуровневые детали теперь отображаются с помощью
свойства user на «другой стороне». Для удобства укажем параметр CascadeType.
PERSIST; механизм транзитивного сохранения упростит запись экземпляров в базу
данных в правильном порядке. При сохранении экземпляра User Hibernate авто-
матически сохранит объект, на который ссылается свойство shippingAddress, а так-
же автоматически сформирует и присвоит идентификатор первичного ключа.
Теперь посмотрим на «другую сторону» – класс Address.
Листинг 8.3  В классе Address определен особый генератор значений
внешнего ключа
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/
foreigngenerator/Address.java
@Entity
public class Address {
@Id
@GeneratedValue(generator = "addressKeyGenerator")
@org.hibernate.annotations.GenericGenerator(
name = "addressKeyGenerator",
strategy = "foreign",
parameters =
@org.hibernate.annotations.Parameter(
name = "property", value = "user"
)
)
protected Long id;
@OneToOne(optional = false)  Создает ограничение внешнего ключа
@PrimaryKeyJoinColumn  Адрес должен ссылаться на пользователя
protected User user;
protected Address() {
}
public Address(User user) {
this.user = user;
}
public Address(User user, String street, String zipcode, String city) {
 Определяет генератор значений
первичного ключа
 Общедоступные
конструкторы
класса Address
Связи один к одному  217
this.user = user;
this.street = street;
this.zipcode = zipcode;
this.city = city;
}
// ...
}
Здесь довольно много нового кода. Сначала рассмотрим свойство идентифика-
тора, а затем связь один к одному.
Особенности Hibernate
Аннотация @GenericGenerator перед свойством идентификатора  определяет спе-
циальный генератор значений первичного ключа, использующий стратегию foreign,
доступную только в Hibernate. Мы не рассматривали этого генератора в раз-
деле 4.2.5; его единственное применение – связь один к одному с общим первичным
ключом. При сохранении экземпляра Address этот специальный генератор извле-
кает значение идентификатора из экземпляра сущности User, на который ссыла-
ется свойство user.
Далее рассмотрим отображение @OneToOne . С помощью аннотации @PrimaryKeyJoinColumn
 свойство user отмечено как связь между сущностями с общим
первичным ключом. Параметр optional=false в аннотации требует, чтобы объ-
ект Address имел ссылку на объект User. Теперь в вызовы общедоступных кон-
структоров Address  требуется передавать экземпляр User. Благодаря параметру
optional=false столбец первичного ключа в таблице ADDRESS теперь имеет ограни-
чение внешнего ключа, как показано в схеме на рис. 8.3.
ID << PK >> << FK >>
STREET
ZIPCODE
CITY
<< Table >>
ADDRESS
ID << PK >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
Рис. 8.3  Ограничение внешнего ключа
для столбца первичного ключа таблицы ADDRESS
Больше не нужно вызывать someAddress.getId() или someUser.getId() при вы-
полнении единицы работы. Теперь сохранять данные стало проще:
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToOneForeignGenerator.java
User someUser = new User("johndoe");
Address someAddress =
new Address(
218  Продвинутые приемы отображения связей между сущностями
someUser,
"Some Street 123", "12345", "Some City"
);
someUser.setShippingAddress(someAddress);
em.persist(someUser); Транзитивное сохранение для поля shippingAddress
Не забывайте, что связать нужно обе стороны двунаправленного отношения
сущностей. Обратите внимание, что такое отображение дает отложенную загрузку
поля User#shippingAddress (оно необязательно/может содержать null), но вы смо-
жете загружать поле Address#user по требованию (оно обязательно) с помощью
прокси-объектов.
Общий первичный ключ в связи один к одному используется относительно
редко. Вместо этого связи «к одному» обычно отображаются с помощью столбца
внешнего ключа с ограничением уникальности.
8.1.3. Соединение с помощью столбца внешнего ключа
Две записи могут быть связаны с помощью дополнительного столбца внешнего
ключа вместо общего первичного ключа. В этом случае одна из таблиц должна
иметь столбец внешнего ключа, ссылающегося на первичный ключ ассоциирован-
ной таблицы. (Источником и целью этого внешнего ключа может выступать одна
таблица: мы называем это рекурсивным отношением.)
Давайте изменим отображение поля User#shippingAddress. Вместо общего пер-
вичного ключа добавим в таблицу USERS столбец SHIPPINGADDRESS_ID. Добавим так-
же ограничение UNIQUE, чтобы два пользователя не могли иметь одинакового адре-
са доставки. Взгляните на схему, показанную на рис. 8.4.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
ID << PK >> ADDRESS
SHIPPINGADDRESS_ID << FK >> << UNIQUE >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
Рис. 8.4  Столбец соединения для связи один к одному
между таблицами USERS и ADDRESS
Address – это обычный класс сущности, такой же, как показанный в начале этой
главы в листинге 8.1. В классе сущности User объявлено поле shippingAddress, реализующее
однонаправленную связь:
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/foreignkey/
User.java
@Entity
@Table(name = "USERS")
Связывание
Связи один к одному  219
public class User {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@OneToOne(
fetch = FetchType.LAZY,
optional = false, NOT NULL
cascade = CascadeType.PERSIST
)
@JoinColumn(unique = true) По умолчанию SHIPPINGADDRESS_ID
protected Address shippingAddress;
// ...
}
Вам не нужны ни специальные генераторы идентификаторов, ни присваивание
значения первичного ключа; вместо аннотации @PrimaryKeyJoinColumn пользуйтесь
@JoinColumn как обычно. Если вы больше знакомы с SQL, нежели с JPA, восприни-
майте отображение @JoinColumn как столбец внешнего ключа.
Для данной связи требуется использовать отложенную загрузку. В отличие от
стратегии с общим первичным ключом, здесь не возникнет проблем с отложенной
загрузкой: после загрузки записи из таблицы USERS в ней будет содержаться зна-
чение столбца SHIPPINGADDRESS_ID. Благодаря этому Hibernate узнает о существо-
вании записи в таблице ADDRESS и для загрузки экземпляра Address по требованию
сможет использовать прокси-объект.
Тем не менее в отображении указан параметр optional=false, требующий нали-
чия у пользователя адреса доставки. Это не влияет на алгоритм загрузки, но явля-
ется лишь логическим следствием параметра unique=true в аннотации @JoinColumn.
Этот параметр добавляет ограничение уникальности в сформированную схему
SQL. Так как значения столбца SHIPPINGADDRESS_ID должны быть уникальны, лишь
у одного пользователя адрес доставки может оказаться пустым. Следовательно,
нет смысла создавать столбцы, которые могут содержать null и иметь ограничение
уникальности.
Создавать, связывать и сохранять экземпляры очень просто:
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToOneForeignKey.java
User someUser =
new User("johndoe");
Address someAddress =
new Address("Some Street 123", "12345", "Some City");
someUser.setShippingAddress(someAddress); Связывание
em.persist(someUser); Транзитивное сохранение поля shippingAddress
220  Продвинутые приемы отображения связей между сущностями
Вы познакомились с двумя основными способами отображения связи один к од-
ному: первый – с общим первичным ключом, второй – с внешним ключом и огра-
ничением уникальности столбца. Последний способ отображения, который мы
хотим продемонстрировать, более экзотический: отображение связи один к одному
с помощью дополнительной таблицы.
8.1.4. Использование таблицы соединения
Вы, наверное, замечали, что столбцы, которые могут содержать null, порой созда-
ют проблемы. Иногда лучшим решением для работы с необязательными значе-
ниями является промежуточная таблица: если в таблице нашлась строка, значит,
ссылка существует, и наоборот.
Давайте рассмотрим сущность Shipment в приложении CaveatEmptor и обсудим
ее назначение. Продавцы и покупатели взаимодействуют в приложении CaveatEmptor,
запуская аукционы и делая на них ставки. Отправка товаров как будто
не входит в сферу ответственности приложения; после окончания аукциона про-
давец и покупатель сами договариваются о способах платежа и доставки. Они мо-
гут сделать это и без приложения CaveatEmptor.
С другой стороны, в приложении CaveatEmptor можно было бы предложить
услугу условного депонирования (escrow). Продавцы будут использовать ее для
создания отслеживаемых поставок по окончании аукциона. Продавец будет опла-
чивать стоимость аукционного товара доверенному лицу (вам), а вы будете ин-
формировать покупателя о поступлении денег. После доставки и приемки товара
покупателем вы будете переводить деньги продавцу.
Если вы хоть раз принимали участие в онлайн-аукционе со значительной сум-
мой, то наверняка пользовались подобной услугой. Но от приложения CaveatEmptor
хотелось бы большего: не только предоставлять такую услугу для за-
вершившихся аукционов, но также дать пользователям возможность создавать
отслеживаемые и надежные отправки для любой сделки, заключенной вне аукциона,
вне приложения CaveatEmptor.
Такой сценарий требует наличия сущности Shipment с необязательной связью
один к одному с классом Item. Взгляните на диаграмму классов для этой предмет-
ной модели на рис. 8.5.
Item 0..1 Shipment
Рис. 8.5  Отправка (Shipment) может быть связана
с аукционным товаром (Item)
ПРИМЕЧАНИЕ В этом разделе мы сначала хотели отойти от примера с CaveatEmptor,
поскольку не смогли найти естественного сценария, который бы тре-
бовал необязательной связи один к одному. Если этот пример с условным де-
понированием кажется притянутым за уши, попробуйте рассмотреть проблему
распределения сотрудников по рабочим местам. Это такое же необязательное
отношение один к одному.
Связи один к одному  221
В схему базы данных следует добавить промежуточную таблицу связи с име-
нем ITEM_SHIPMENT. Запись в этой таблице представляет объект Shipment, созданный
в рамках аукциона. Таблицы показаны на рис. 8.6.
ID << PK >>
...
<< Table >>
SHIPMENT
ID << PK >>
...
<< Table >>
ITEM
SHIPMENT_ID << PK >> << FK >
ITEM_ID << FK >> << UNIQUE >>>
<< Table >>
ITEM_SHIPMENT
Рис. 8.6  Промежуточная таблица связывает товар с отправкой
Обратите внимание, как схема гарантирует уникальность и обеспечивает отно-
шение один к одному: первичный ключ таблицы ITEM_SHIPMENT хранится в столбце
SHIPMENT_ID, а ITEM_ID содержит только уникальные значения. То есть одному това-
ру соответствует лишь одна отправка. Конечно, это также означает, что отправка
может содержать лишь один товар.
Такая модель отображается при помощи аннотации @OneToOne в классе сущно-
сти Shipment:
Файл: /model/src/main/java/org/jpwh/model/associations/onetoone/jointable/
Shipment.java
@Entity
public class Shipment {
@OneToOne(fetch = FetchType.LAZY)
@JoinTable(
name = "ITEM_SHIPMENT", Имя обязательно!
joinColumns =
@JoinColumn(name = "SHIPMENT_ID"), По умолчанию ID
inverseJoinColumns =
@JoinColumn(name = "ITEM_ID", По умолчанию AUCTION_ID
nullable = false,
unique = true)
)
protected Item auction;
public Shipment() {
}
public Shipment(Item auction) {
this.auction = auction;
}
// ...
}
Отложенная загрузка включается за счет следующей особенности: когда Hibernate
загружает экземпляр Shipment, он выполняет запросы к таблице SHIPMENT
и таблице соединения ITEM_SHIPMENT. Прежде чем использовать прокси-объект, Hibernate
должен убедиться, что ссылка на экземпляр Item существует. Он делает это
222  Продвинутые приемы отображения связей между сущностями
при помощи SQL-запроса с внешним соединением, поэтому дополнительных вы-
ражений SQL вы не встретите. Если искомая запись имеется в таблице ITEM_SHIPMENT,
Hibernate вернет прокси-объект для экземпляра Item.
Аннотация @JoinTable не встречалась нам ранее; она всегда требует указывать
имя промежуточной таблицы. Это отображение фактически скрывает таблицу со-
единения; не существует Java-класса, который бы ей соответствовал. Эта аннота-
ция задает имена столбцов таблицы ITEM_SHIPMENT, а Hibernate сгенерирует в схеме
ограничение UNIQUE для столбца ITEM_ID. Также Hibernate сгенерирует подходящие
ограничения внешнего ключа для столбцов таблицы соединения.
Следующий фрагмент сохраняет одну отправку (Shipment) без товара (Item),
а другую связывает с одним товаром (Item):
Файл: /examples/src/test/java/org/jpwh/test/associations/
OneToOneJoinTable.java
Shipment someShipment = new Shipment();
em.persist(someShipment);
Item someItem = new Item("Some Item");
em.persist(someItem);
Shipment auctionShipment = new Shipment(someItem);
em.persist(auctionShipment);
На этом мы завершим обзор способов отображения связи один к одному. В ито-
ге, когда одна из двух сущностей всегда сохраняется раньше другой и может быть
источником значений первичного ключа, мы советуем использовать связь с об-
щим первичным ключом. В остальных ситуациях применяйте связь с внешним
ключом, а если связь один к одному является необязательной, используйте скры-
тую промежуточную таблицу соединения.
Далее мы сосредоточим внимание на множественных (many-valued) связях
между сущностями, начиная с некоторых продвинутых способов отображения
связи один ко многим.
8.2. Связь один ко многим
Множественная связь между сущностями – это по определению коллекция ссы-
лок на сущности. Вы уже видели, как отображается связь один ко многим в преды-
дущей главе, в разделе 7.3.2. Связи один ко многим представляют наиболее важный
тип связей, использующий коллекции. Мы даже рискнем отговорить вас от ис-
пользования более сложных типов связей, поскольку подойдет и простая двуна-
правленная ассоциация многие к одному/один ко многим.
Помните также, что необязательно отображать все коллекции сущностей, если
в этом нет необходимости; всегда можно написать явный запрос вместо прямого
обращения к данным во время обхода. Если вы все же решите отобразить коллек-
цию ссылок на сущности, у вас на выбор есть несколько вариантов, и сейчас мы
рассмотрим некоторые наиболее сложные ситуации.
Связь один ко многим  223
8.2.1. Применение контейнеров в связях один ко многим
До сих пор мы использовали связь @OneToMany только со множеством (Set); однако
вместо двунаправленной связи один ко многим можно использовать отображение
контейнера. Но зачем это делать?
Среди всех коллекций, пригодных для реализации двунаправленной связи один
ко многим, контейнеры обладают лучшими показателями производительности.
По умолчанию коллекции в Hibernate загружаются во время первого обращения
к ним. Поскольку контейнер не должен хранить индексов своих элементов (как
список) или проверять дублирования элементов (как множество), вы можете до-
бавлять в контейнер новые элементы, не инициируя при этом загрузку данных.
Это может быть важно при отображении потенциально большой коллекции ссы-
лок на сущности.
С другой стороны, невозможно одновременно загрузить два контейнера: на-
пример, если бы поля bids и images класса Item были контейнерами, связанными
отношением один ко многим. Это не большая потеря, поскольку одновременное
извлечение двух коллекций, как правило, создает декартово произведение; таких
операций нужно избегать, независимо от того, используете вы контейнеры, списки
или множества. Но отложим пока стратегии извлечения до главы 12. В целом мы
считаем, что контейнер является лучшей коллекцией для обратной стороны связи
один ко многим, когда та отображается аннотацией @OneToMany(mappedBy = "...").
Для отображения двунаправленной связи один ко многим с помощью контей-
нера следует поменять тип коллекции bids в классе Item на Collection, указав тип
ArrayList в качестве реализации. Отображение связи между классами Item и Bid,
по сути, не поменяется:
Файл: /model/src/main/java/org/jpwh/model/associations/oneto-many/bag/
Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item")
public Collection<Bid> bids = new ArrayList<>();
// ...
}
Класс Bid с аннотацией @ManyToOne (отображающая сторона, владелец отноше-
ния) и даже таблицы останутся такими же, как в разделе 7.3.1.
В отличие от множества, которое мы отображали ранее, контейнер допускает
дублирование элементов:
Файл: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item someItem = new Item("Some Item");
em.persist(someItem);
Bid someBid = new Bid(new BigDecimal("123.00"), someItem);
someItem.getBids().add(someBid);
224  Продвинутые приемы отображения связей между сущностями
someItem.getBids().add(someBid); Не вызывает немедленого сохранения!
em.persist(someBid);
assertEquals(someItem.getBids().size(), 2);
Как оказывается, для данного примера это не актуально, поскольку дублирование
означает повторное добавление определенной ссылки на экземпляр Bid. Вы бы не
стали так делать в настоящем приложении. Даже если добавить в коллекцию одну
ссылку несколько раз, Hibernate проигнорирует ее. Стороной, влияющей на обнов-
ление базы данных, является сторона @ManyToOne, которая уже отображает данное
отношение. При загрузке экземпляра Item в коллекции уже не будет дубликата:
Файл: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item item = em.find(Item.class, ITEM_ID);
assertEquals(item.getBids().size(), 1);
Как уже упоминалось, преимущество контейнера заключается в том, что для
добавления элемента не требуется инициализировать коллекцию:
Файл: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item item = em.find(Item.class, ITEM_ID);
Bid bid = new Bid(new BigDecimal("456.00"), item);
item.getBids().add(bid); Никакого SELECT!
em.persist(bid);
Этот код вызовет лишь одну SQL-операцию SELECT для загрузки экземпляра
Item. Если вызвать em.getReference() вместо em.find(), Hibernate все равно инициализирует
и вернет прокси-объект Item, используя операцию SELECT, как только
вы вызовете item.getBids(). Но до тех пор, пока не начат обход коллекции (Collection),
не нужны никакие запросы, а операция INSERT для новых объектов Bid
будет выполняться без загрузки поля bids. Если коллекция имеет тип Set или List,
Hibernate загрузит все элементы при добавлении нового элемента.
Давайте поменяем тип коллекции, превратив ее в хранимый список (List).
8.2.2. Однонаправленное и двунаправленное отображения
списка
Если вам потребуется настоящий список, чтобы сохранить позиции элементов
в коллекции, вам понадобится дополнительный столбец для хранения индексов.
В случае связи один ко многим это также означает, что необходимо поменять тип
поля Item#bids на List, инициализируя его объектом ArrayList:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/ list/
Item.java
@Entity
public class Item {
@OneToMany
Связь один ко многим  225
@JoinColumn(
name = "ITEM_ID",
nullable = false
)
@OrderColumn(
name = "BID_POSITION", По умолчанию BIDS_ORDER
nullable = false
)
public List<Bid> bids = new ArrayList<>();
// ...
}
Это однонаправленное отображение – другая, отображающая сторона отсут-
ствует. В классе Bid отсутствует поле с аннотацией @ManyToOne. Для хранения ин-
дексов хранимого списка используется новая аннотация @OrderColumn, в которой,
как обычно, нужно задать для столбца ограничение NOT NULL. Представление та-
блицы BID в базе данных со столбцами соединения и упорядочивания показано на
рис. 8.7.
ID AMOUNT
1 99.00
2
3
4
ITEM_ID
1
1
1
2
100.00
101.00
4.99
BID
BID_POSITION
0
1
2
0
Рис. 8.7  Таблица BID
Для каждой коллекции сохраняемый индекс начинается с нуля и является не-
прерывным (разрывы отсутствуют). Потенциально Hibernate может выполнять
множество SQL-операций при добавлении, удалении и сдвиге элементов списка
(List). Мы уже говорили об этой проблеме производительности в разделе 7.1.6.
Давайте сделаем это отображение двунаправленным с помощью поля @ManyToOne
сущности Bid:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/list/
Bid.java
@Entity
public class Bid {
@ManyToOne
@JoinColumn(
name = "ITEM_ID",
updatable = false, insertable = false Запретить запись!
)
226  Продвинутые приемы отображения связей между сущностями
@NotNull Для формирования схемы
protected Item item;
// ...
}
Вы, наверное, ожидали увидеть другой код, например @ManyToOne(mappedBy=
"bids") без дополнительной аннотации @JoinColumn. Но в аннотации @ManyToOne
отсутствует атрибут mappedBy: она всегда находится на стороне, владеющей отно-
шением. Вы должны сделать отображаемой другую сторону с аннотацией @One-
ToMany. Здесь вы столкнетесь с одной концептуальной проблемой и некоторыми
нюансами Hibernate.
Коллекция Item#bids теперь доступна не только для чтения, поскольку Hibernate
должен сохранять индекс каждого элемента. Если бы отношением владела
сторона Bid#item, Hibernate проигнорировал бы коллекцию при сохранении дан-
ных, не записав индексов элементов. Нужно дважды отобразить @JoinColumn, а за-
тем запретить запись на стороне @ManyToOne с помощью параметров updatable=false
и insertable=false. После этого Hibernate будет учитывать сторону коллекции при
сохранении данных, включая индекс каждого элемента. Связь @ManyToOne доступ-
на, по сути, только для чтения, как если бы она обладала атрибутом mappedBy.
Двунаправленный список с атрибутом mappedBy
В Hibernate есть несколько нерешенных проблем, связанных с этим обстоятель-
ством; будущие версии, возможно, позволят применять к коллекции, совместимые
с JPA аннотации @OneToMany(mappedBy) и @OrderColumn. На момент написания книги
представленное отображение было единственной рабочей реализацией двуна-
правленной связи один ко многим, использующей хранимый список (List).
Наконец, генератор схемы в Hibernate всегда полагается на аннотацию @Join-
Column на стороне @ManyToOne. Следовательно, чтобы получить корректную схе-
му, необходимо поместить аннотацию @NotNull на этой стороне или применить
@JoinColumn(nullable=false). Генератор проигнорирует сторону @OneToMany и ее
столбец соединения, если обнаружит аннотацию @ManyToOne.
В действующем приложении вы бы не стали отображать ассоциацию, исполь-
зуя коллекцию List. Сохранение порядка элементов в базе данных кажется рас-
пространенным вариантом использования, но, если подумать, он не очень полезен:
иногда требуется показывать пользователю список, где сначала идут последние
ставки, или ставки, сделанные конкретным пользователем, или ставки, сделанные
в заданном временном интервале. Ни одной из этих операций индекс элемента
в списке не нужен. Как уже упоминалось в разделе 3.2.4, не следует хранить по-
рядок отображения в базе данных; используйте гибкий подход с применением
запросов, а не жестко закодированные отображения. Кроме того, сопровождение
индексов при удалении, добавлении или сдвиге элементов списка может быть до-
рогостоящим и вызывать выполнение множества выражений SQL. Отобразите
Связь один ко многим  227
столбец соединения с внешним ключом, используя аннотацию @ManyToOne, и из-
бавьтесь от коллекции.
Далее будет представлен еще один сценарий с отношением один ко многим:
с отображением связи в промежуточную таблицу соединения.
8.2.3. Необязательная связь один ко многим
с таблицей соединения