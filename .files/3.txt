Аукцион состоит из последовательности предложений цены и одного победив-
шего предложения. Данные о пользователях включают имя, адрес и платежную
информацию.
Результат этого анализа – высокоуровневая схема предметной модели – пока-
зан на рис. 3.3. Давайте коротко обсудим некоторые интересные особенности этой
модели.
60  Модели предметной области и метаданные
0..* seller
1..*
0..*
0..*
BillingDetails
number : String
expMonth: String
expYear : String
account : String
bankname : String
swift : String
0..*
home
billing
shipping
0..*
bidder
0..*
0..*
parent
Category
Bid
Item User Address
Image
CreditCard BankAccount
name : String
amount : BigDecimal
createdOn : Date
name : String
initialPrice : BigDecimal
auctionEnd : Date
username : String
firstname : String
lastname : String
street : String
zipcode : String
city : String
title : String
filename : String
owner : String
Рис. 3.3  Хранимые классы предметной модели CaveatEmptor
и их отношения
Каждый товар может быть продан только один раз, поэтому нет смысла делать
сущность, представляющую товар (Item), отличной от любой другой сущности на
аукционе. Вместо этого у вас будет одна сущность для аукционного товара – Item.
Соответственно, предложение цены (Bid) будет иметь прямую ассоциацию с това-
ром. Информация об адресе моделируется как отдельный класс Address; пользо-
ватель может иметь три адреса: домашний (home), платежный (billing) и доставки
(shipping). Пользователь может иметь несколько вариантов платежной информа-
ции (BillingDetails). Подклассы абстрактного класса представляют различные
платежные стратегии (допуская будущие расширения).
Категория (Category) может быть вложена внутрь другой категории. Рекурсив-
ная ассоциация сущности с самой собой (parent) выражает это отношение. От-
метим, что категория может иметь несколько дочерних категорий, но лишь одну
родительскую. Каждый товар относится, по меньшей мере, к одной категории.
Эта схема не является полноценной предметной моделью. Она содержит лишь
классы, которые требуют длительного хранения. Нам определенно необходимо
сохранять и загружать экземпляры классов Category, Item, User и т. д. Мы немного
упростили высокоуровневую схему, но можем добавить дополнительные классы
позже или внести незначительные изменения, когда нам потребуются более слож-
ные примеры.
Сущности предметной модели, безусловно, должны инкапсулировать состоя-
ние и поведение. К примеру, сущность User должна определять имя и адрес клиен-
та, а также логику вычисления стоимости доставки товаров (для этого конкрет-
ного клиента).
В модели предметной области также могут быть классы, экземпляры которых
существуют лишь в памяти приложения в момент выполнения. Рассмотрим класс
Реализация предметной модели  61
WinningBidStrategy, инкапсулирующий логику победы на аукционе предложивше-
го наибольшую цену. Он может вызываться уровнем бизнес-логики (контролле-
ром) во время проверки состояния аукциона. В какой-то момент, возможно, вам
придется выяснить, как вычисляется налог на проданный товар или как система
может разрешить создание новой учетной записи пользователя. Мы не считаем по-
добную бизнес-логику или поведение предметной модели неважными; скорее, эта
функциональность является ортогональной по отношению к хранению данных.
Теперь, когда у вас есть проект приложения (пусть и примитивный) с предмет-
ной моделью, следующим шагом будет его реализация на Java.
ORM без предметной модели
Хранение объектов с полноценным объектно-реляционным отображением боль-
ше подходит приложениям с насыщенной предметной моделью. Если ваше прило-
жение не реализует сложной бизнес-логики или сложных взаимодействий между
сущностями (или если сущностей очень немного), предметная модель может не
понадобиться. Для большинства простых, а иногда и не слишком простых, реше-
ний отлично подходят таблично-ориентированные (table-oriented) решения, когда
приложение проектируется вокруг схемы базы данных, а не вокруг объектно-ори-
ентированной предметной модели, и логика реализована на стороне базы данных
(в виде хранимых процедур). Другой аспект, требующий рассмотрения, – это кри-
вая обучения: освоив фреймворк Hibernate, вы будете использовать его в любых
приложениях, даже таких простых, которые генерируют SQL-запросы и отобража-
ют результаты. Если вы еще только изучаете ORM, реализация простейшего при-
мера использования может не оправдать ваших затрат.
3.2. Реализация предметной модели
Начнем с проблемы, с которой сталкивается любая реализация: разделение ответ-
ственности. Как правило, реализация предметной модели – это центральный ор-
ганизующий компонент; она повторно используется всякий раз, когда в приложе-
ние добавляется новая функциональность. Поэтому будьте готовы потрудиться,
чтобы задачи, не касающиеся предметной области, не просочились в реализацию
предметной модели.
3.2.1. Предотвращение утечек функциональности
Когда такие области ответственности, как хранение данных, управление транзакциями
или авторизация, просачиваются в классы предметной модели, – это
пример утечки функциональности (leakage of concerns). Реализация предметной
модели является настолько важным участком кода, что она должна быть ортого-
нальна любым Java API. К примеру, код предметной модели не должен выполнять
JNDI-запросов или обращаться к базе данных посредством JDBC API ни напря-
мую, ни с использованием промежуточных абстракций. Это позволяет повторно
использовать классы предметной модели практически повсеместно:
62  Модели предметной области и метаданные
 уровень представления может получать доступ к экземплярам и атрибутам
сущностей предметной модели для вывода представлений;
 контроллеры уровня бизнес-логики также могут обращаться к состоянию
сущностей предметной модели и вызывать методы сущностей для выпол-
нения бизнес-логики;
 уровень хранения может сохранять экземпляры в базе данных и извлекать
их из нее.
Более того, предотвращение утечки функциональности позволяет с легкостью
проводить модульное тестирование предметной модели без необходимости ис-
пользовать конкретную среду выполнения или контейнер или имитировать ка-
кие-либо зависимости от служб. Можно создавать модульные тесты, проверяю-
щие корректность поведения классов модели, без использования специального
тестового фреймворка (мы не говорим сейчас о тестировании аспектов загрузки
из базы данных или сохранении в базу данных, но о таких аспектах, как расчет
стоимости доставки и налога).
Стандарт JavaEE решает проблему утечки функциональности при помощи ме-
таданных в виде аннотаций или внешних XML-дескрипторов. Такой подход по-
зволяет контейнеру среды выполнения реализовывать в общем виде некоторую
заранее определенную сквозную функциональность: безопасность, многопоточ-
ность, хранение данных, поддержку транзакций и удаленные взаимодействия –
путем перехвата вызовов к компонентам приложения. Hibernate не является ни
средой выполнения JavaEE, ни сервером приложений. Этот проект является реа-
лизацией лишь одной спецификации из состава JavaEE – JPA – и решением лишь
для одной области ответственности – хранения данных.
JPA определяет класс сущности как первичный программный артефакт. Эта мо-
дель программирования поддерживает прозрачный подход к хранению данных,
а поставщик JPA, такой как Hibernate, предоставляет также возможность автома-
тизации.
3.2.2. Прозрачность сохранения и его автоматизация
Мы используем слово прозрачность, чтобы подчеркнуть полное разделение ответ-
ственности между хранимыми классами предметной модели и уровнем хранения.
Хранимые классы ничего не знают о механизме хранения данных и не зависят от
него. Под словом автоматизация мы подразумеваем способность решения хра-
нения данных (включающего аннотированные классы, уровень хранения и ме-
ханизм хранения) избавлять вас от решения низкоуровневых задач – написания
большинства SQL-выражений и взаимодействий с JDBC API.
Класс Item предметной модели CaveatEmptor, например, не должен иметь ника-
ких зависимостей времени выполнения от какого-либо прикладного программно-
го интерфейса Java Persistence или Hibernate. Более того:
 JPA не требует, чтобы хранимый класс наследовал какой-то специальный
суперкласс или реализовал интерфейс. Также не существует специальных
классов для реализации атрибутов и ассоциаций (безусловно, возможность
использования обоих вариантов всегда присутствует);
Реализация предметной модели  63
 хранимые классы можно повторно использовать вне контекста хранения, на-
пример в модульных тестах или на уровне представления. Вы можете созда-
вать экземпляры в любой среде выполнения, используя обычный оператор
new, сохраняя возможности для тестирования и повторного использования;
 в системе с прозрачной поддержкой хранения экземпляры сущностей по-
нятия не имеют о хранилище данных; они не должны даже понимать, что
могут сохраняться или извлекаться. JPA передает ответственность за хра-
нение универсальному API диспетчера механизмов хранения;
 следовательно, большая часть вашего кода и, конечно, бизнес-логики не
должна беспокоиться о текущем состоянии экземпляров сущностей пред-
метной модели ни в каком потоке выполнения.
Мы рассматриваем прозрачность как требование, потому что она упрощает
разработку и сопровождение приложений. Прозрачность должна быть основной
цельюлюбого
ORM. Очевидно, что ни одно автоматическое решение не является
полностью прозрачным: каждый уровень автоматизации, включая JPA и Hibernate,
накладывает некоторые ограничения на хранимые классы. Например, JPA
требует, чтобы атрибуты-коллекции имели типы интерфейсов, таких как java.
util.Set или java.util.List, а не конкретных реализаций, таких как java.util.
HashSet (вообще-то, это хорошая практика). Также класс сущности JPA должен
иметь особый атрибут – идентификатор в базе данных (что является скорее удоб-
ством, чем ограничением).
Теперь вы понимаете, почему механизм хранения должен иметь ограниченное
влияние на реализацию модели предметной области и почему он должен быть
прозрачным и автоматическим. Предпочтительной программной моделью для до-
стижения этого является POJO.
POJO
Аббревиатура POJO расшифровывается как Plain Old Java Objects (старые добрые
объекты Java). Термин был введен в употребление Мартином Фаулером (Martin
Fowler), Ребеккой Парсонс (Rebecca Parsons) и Джошем Маккензи (Josh Mackenzie)
в 2000 г.
Около десяти лет назад разработчики заговорили о POJO – подходе, ведущем
назад к основам, который, по сути, воскрешает JavaBeans, компонентную модель
разработки пользовательских интерфейсов, и применяет ее к другому уровню си-
стемы. После нескольких ревизий спецификаций EJB и JPA появились легковес-
ные сущности, которые правильно было бы называть JavaBeans с возможностью
сохранения. Java-инженеры часто используют эти термины как синонимы для обо-
значения одного и того же базового подхода к проектированию.
Вам не следует слишком беспокоиться о терминах, используемых в книге; ко-
нечной целью является как можно более прозрачное добавление аспекта хранения
в Java-классы. Практически каждый Java-класс можно сделать хранимым, если сле-
довать некоторым простым советам. Давайте посмотрим, как это выглядит в коде.
64  Модели предметной области и метаданные
3.2.3. Создание классов с возможностью сохранения
Главной задачей Hibernate является работа со сложными, детализированными
предметными моделями. По этой причине мы работаем с POJO. В общем, исполь-
зование детализированных объектов подразумевает большее количество классов,
чем таблиц.
Старый добрый Java-класс с возможностью сохранения объявляет атрибуты, ко-
торые представляют состояние, и бизнес-методы, которые представляют поведение.
Некоторые атрибуты представляют ассоциации с другими хранимыми классами.
POJO-реализация для сущности User предметной модели показана в следую-
щем листинге. Давайте пройдемся по коду.
Листинг 3.1  POJO-реализация для сущности User
Файл:/model/src/main/java/org/jpwh/model/simple/User.java
public class User implements Serializable {
protected String username;
public User() {
}
public String getUsername() {
return username;
}
public void setUsername(String username) {
this.username = username;
}
public BigDecimal calcShippingCosts(Address fromLocation) {
// Пустая реализация бизнес-метода
return null;
}
// ...
}
JPA не требует, чтобы хранимые классы реализовали интерфейс java.io.Serializable.
Но когда экземпляры сохраняются в HttpSession или передаются по
значению с помощью механизма удаленного вызова методов (Remote Method
Invocation,
RMI), сериализация необходима. В вашем приложении этот механизм
может не использоваться, но класс будет сериализуемым без какой-либо допол-
нительной работы, и от этого не будет проблем (мы не станем объявлять классы
сериализуемыми в каждом примере, подразумевая, что вы понимаете, когда это
необходимо).
Класс может быть абстрактным и, если необходимо, расширять нехранимый
класс или реализовать интерфейс. Он должен быть классом верхнего уровня, а не
вложенным внутрь другого класса. Ни хранимые классы, ни их методы не могут
быть финальными (требование спецификации JPA).
Реализация предметной модели  65
В отличие от спецификации JavaBeans, которая не требует наличия какого-ли-
бо специального конструктора, Hibernate (и JPA) требует, чтобы каждый храни-
мый класс имел конструктор без аргументов. С другой стороны, можно вообще
обойтись без конструктора – Hibernate будет использовать Java-конструктор по
умолчанию. Такой конструктор без аргументов вызывается для создания экземпляров
при помощи механизма рефлексии в Java. Конструктор может не быть обще-
доступным, но он должен как минимум иметь область видимости уровня пакета,
если для оптимизации производительности Hibernate должен будет использовать
прокси-классы, сгенерированные во время выполнения. Рассмотрим также тре-
бования других спецификаций: стандарт EJB требует, чтобы у сеансовых ком-
понентов (session beans) конструкторы были общедоступными, а спецификация
JavaServer Faces (JSF) требует того же для управляемых компонентов (managed
beans). Существуют и другие ситуации, когда может понадобиться общедоступ-
ный конструктор для создания «пустого» состояния – например, построение за-
проса по образцу.
Свойства POJO представляют атрибуты бизнес-сущностей – например, свой-
ство username представляет имя пользователя (User). Свойства обычно реализова-
ны как приватные или защищенные переменные-члены класса вместе с общедо-
ступными или защищенными методами доступа – для каждого поля класса есть
метод получения и метод установки значения. Они известны как методы чтения
(getter) и записи (setter) соответственно. Объект POJO в листинге 3.1 имеет мето-
ды чтения и записи для свойства username.
Спецификация JavaBean определяет принципы именования методов доступа;
это позволяет таким инструментам общего назначения, как Hibernate, с легкостью
находить их и управлять значениями свойств. Имя метода чтения должно начи-
наться со слова get, за которым следует имя свойства (первая буква прописная);
имя метода записи должно начинаться со слова set и аналогично заканчиваться
именем свойства. В именах методов чтения логических свойств (типа Boolean) до-
пускается вместо get использовать префикс is.
Hibernate не требует создания методов доступа. Вы выбираете, как должно со-
храняться состояние экземпляра хранимого класса, а Hibernate будет либо обра-
щаться к полям класса напрямую, либо станет вызывать методы доступа. Эти со-
ображения не должны оказывать сильного влияния на дизайн классов. Вы можете
сделать какие-то методы доступа приватными или защищенными либо вовсе из-
бавиться от них – просто настройте Hibernate на доступ к полям класса для этих
свойств.
Должны ли поля класса и методы доступа быть приватными,
защищенными или видимыми на уровне пакета?
Как правило, желательно запрещать прямой доступ к внутреннему состоянию клас-
сов, поэтому поля классов не делают общедоступными. Объявляя поля класса или
его методы приватными, вы фактически заявляете, что никто и никогда не должен
иметь к ним доступа; только вы можете сделать это (или служба, подобная Hiber66
 Модели предметной области и метаданные
nate). Это категоричное заявление. Иногда у кого-нибудь могут возникнуть веские
причины для доступа к вашему «приватному» содержимому – обычно, чтобы испра-
вить одну из ваших ошибок, – и вы только разозлите остальных, если в экстренном
случае им придется прибегать к механизму рефлексии. Вместо этого предпочти-
тельнее предполагать, что инженер, пришедший после вас, которому потребуется
доступ к вашему коду, знает, что делает.
Защищенная видимость в таком случае является более разумным выбором. Вы
запрещаете прямой публичный доступ, показывая, что детали этого конкретного
поля класса являются внутренними, но открываете доступ подклассам на случай
необходимости. Вы доверяете инженеру – создателю подкласса. Ограничение
видимости рамками пакета – не лучшее решение: вы заставляете кого-то созда-
вать код в том же пакете для доступа к переменным-членам и методам, т. е. делать
лишнюю работу без веской на то причины. Более важно, что эти рекомендации по
выбору области видимости актуальны и в средах без политик безопасности и на-
личия объекта SecurityManager в среде выполнения. Если вам нужно сделать свой
внутренний код приватным – делайте его приватным.
Тривиальные методы доступа широко используются, но мы обычно предпо-
читаем методы доступа в стиле JavaBeans, потому что они обеспечивают инкап-
суляцию – вы можете поменять внутреннюю реализацию атрибута, не изменяя
публичного интерфейса. Если вы настроите Hibernate на доступ к атрибутам через
методы, вы абстрагируете внутреннюю структуру данных класса – переменные
экземпляра – от схемы базы данных.
Например, если имя пользователя хранится в базе данных в одном столбце NAME,
но в классе User есть поля firstname и lastname, вы можете определить в классе хра-
нимое свойство name.
Листинг 3.2  Реализация класса User в виде POJO с логикой в методах доступа
public class User {
protected String firstname;
protected String lastname;
public String getName() {
return firstname + ' ' + lastname;
}
public void setName(String name) {
StringTokenizer t = new StringTokenizer(name);
firstname = t.nextToken();
lastname = t.nextToken();
}
}
Позже вы увидите, что для большинства подобных ситуаций лучше подходит
преобразователь пользовательских типов в службе хранения. Он позволяет полу-
чить несколько вариантов на выбор.
Еще один аспект, на который стоит обратить внимание, – это сравнение состоя-
ния объектов (dirty checking). Hibernate автоматически определяет изменение со-
Реализация предметной модели  67
стояния для синхронизации с базой данных. Как правило, можно без проблем воз-
вращать из метода чтения не тот экземпляр, который Hibernate передал в метод
записи. Hibernate сравнит их значения, а не идентичность, чтобы выяснить, нужно
ли обновлять сохраненное состояние атрибута. Следующий метод, к примеру, не
станет причиной ненужных SQL-выражений UPDATE:
public String getFirstname() { Это нормально
return new String(firstname);
}
Но есть одно важное исключение – для коллекций проверяется идентичность!
Для свойства, представляющего хранимую коллекцию, метод чтения должен воз-
вращать ту же коллекцию, которую фреймворк Hibernate передал в метод записи.
В противном случае Hibernate будет обновлять базу данных, даже если никакого
обновления не требуется, для синхронизации состояния в памяти и в базе данных.
Обычно вы должны стараться избегать подобного кода в методах потомков:
protected String[] names = new String[0];
public void setNames(List<String> names) {
this.names = names.toArray(new String[names.size()]);
}
public List<String> getNames() {
return Arrays.asList(names); Не делайте этого, если Hibernate обращается к методам доступа!
}
Конечно, это не является проблемой, если Hibernate обращается к переменной-
члену names непосредственно, в обход методов доступа.
Как Hibernate обрабатывает исключения, возбуждаемые методами доступа?
Если метод доступа во время сохранения/извлечения экземпляра возбудит ис-
ключение RuntimeException (неконтролируемое), Hibernate откатит текущую
транзакцию, и вы сможете обработать исключение в коде, вызвавшем Java Persistence
API (или Hibernate). Если метод возбудит контролируемое исключение,
Hibernate завернет его в RuntimeException.
Пример в листинге 3.1 также определяет метод расчета стоимости доставки то-
вара конкретному пользователю (мы опустили его реализацию).
Далее мы сфокусируемся на отношениях между сущностями и ассоциациях
между хранимыми классами.
3.2.4. Реализация ассоциаций в POJO
В этом разделе вы узнаете, как создавать различные виды отношений между объ-
ектами: один к одному, многие к одному и двунаправленные отношения. Мы рас-
смотрим вспомогательный код (scaffolding code), необходимый для создания этих
ассоциаций, и как обеспечивать целостность этих отношений.
Для выражения ассоциаций между классами создаются свойства, и вы (как пра-
вило) вызываете методы доступа к ним для навигации от экземпляра к экземпля-
68  Модели предметной области и метаданные
ру во время выполнения. Давайте рассмотрим ассоциации, определенные между
хранимыми классами Bid и Item, показанные на рис. 3.4:
name : String
description : String
createdOn : Date
verified : boolean
auctionType : AuctionType
initialPrice : BigDecimal
auctionStart : Date
auctionEnd : Date
amount : BigDecimal
createdOn : Date
0..*
Bid
Item
Рис. 3.4  Ассоциации
между классами Bid и Item
Так же как на других UML-диаграммах, мы не опустили атрибутов, связанных
с ассоциациями: Item#bids и Bid#item. Эти свойства и методы управления их зна-
чениями называются вспомогательным кодом. Так выглядит вспомогательный код
для класса Bid:
Файл:/model/src/main/java/org/jpwh/model/simple/Bid.java
public class Bid {
protected Item item;
public Item getItem() {
return item;
}
public void setItem(Item item) {
this.item = item;
}
}
Свойство item позволяет осуществить переход от предложения цены (Bid)
к связанному товару (Item). Это – ассоциация вида многие к одному: пользователи
могут делать несколько предложений цены для одного товара. А вот вспомога-
тельный код класса Item:
Файл:/model/src/main/java/org/jpwh/model/simple/Item.java
public class Item {
protected Set<Bid> bids = new HashSet<Bid>();
public Set<Bid> getBids() {
return bids;
}
Реализация предметной модели  69
public void setBids(Set<Bid> bids) {
this.bids = bids;
}
}
Ассоциация между двумя классами позволяет осуществлять двунаправленную
(bidirectional) навигацию: связь многие к одному с этой точки зрения – то же, что
и связь один ко многим (напомним, у одного товара может быть несколько предло-
жений цены). Вспомогательный код для свойства bids использует тип интерфейса
коллекции java.util.Set. JPA требует применения интерфейсов для полей-кол-
лекций, и вы должны использовать java.util.Set, java.util.List или java.util.
Collection, а не, к примеру, HashSet. Вообще, использование интерфейсов вместо
конкретных реализаций является хорошей практикой, поэтому данное ограниче-
ние не должно вас беспокоить.
Выбрав Set, вы инициализируете поле класса новым объектом HashSet, потому
что приложение не позволяет делать двух одинаковых предложений. Это хорошая
практика, потому что предотвращает любое исключение типа NullPointerException,
когда кто-нибудь обращается к свойству нового экземпляра Item, у которого
отсутствуют предложения цены. Реализация JPA также обязана присвоить непустое
значение любому отображаемому полю-коллекции – например, когда товар
(Item) без предложений цены загружается из базы данных. (Необязательно ис-
пользовать HashSet – выбор типа остается на усмотрение реализации. В Hibernate
есть собственные реализации коллекций с дополнительными возможностями, та-
кими как сравнение состояния объектов.)
Не лучше ли хранить предложения цены за товар в списке?
Обычно первое решение – запоминать тот порядок элементов, в котором их вводят
пользователи, потому что позже вы, возможно, захотите показывать их в таком же
порядке. Безусловно, в приложении для аукциона должен существовать порядок,
в котором пользователю будут показываться предложения цены за товар: напри-
мер, самая высокая цена показывается первой или самое последнее предложе-
ние – последним. Вы могли бы даже использовать java.util.List в вашем пользова-
тельском интерфейсе для сортировки и отображения предложений цены за товар.
Но это не означает, что порядок отображения должен сохраняться: целостность
данных не зависит от порядка, в котором показываются предложения цен. Вам не-
обходимо хранить значение цены, чтобы можно было найти наибольшую, и метку
времени для каждого предложения, чтобы определить последнее. Если у вас есть
сомнения, сделайте вашу систему гибкой и сортируйте данные при загрузке из
хранилища данных (в запросе) и/или при показе пользователю (в Java-коде), а не
при сохранении.
Так же как основные свойства, методы доступа к ассоциациям стоит делать
общедоступными, только если они являются частью внешнего интерфейса храни-
мого класса и используются логикой приложения для создания связи между дву-
мя экземплярами. Мы сейчас подробно рассмотрим этот вопрос, т. к. управление
70  Модели предметной области и метаданные
связью между товаром (Item) и предложением цены (Bid) в Java гораздо сложнее,
чем в базе данных SQL с декларативными ограничениями внешнего ключа. По
нашему опыту, большинство инженеров незнакомо с этим затруднением, возни-
кающим в графе объектов с двунаправленными ссылками (указателями). Давайте
последовательно разберемся с этим вопросом.
Основной способ привязки предложения цены (Bid) к товару (Item) выглядит
следующим образом:
anItem.getBids().add(aBid);
aBid.setItem(anItem);
Когда бы ни создавалась эта двунаправленная связь, необходимо выполнить
два действия:
 добавить экземпляр Bid в коллекцию bids объекта Item;
 установить свойство item экземпляра Bid.
JPA не управляет ассоциациями. Если вы хотите управлять ассоциациями, то
должны писать такой же код, какой создали бы без Hibernate. Если ассоциация
двунаправленная, то вы должны помнить об обеих сторонах отношения. Если
у вас когда-нибудь возникнут проблемы с пониманием поведения ассоциаций
в JPA, задайте себе вопрос: «Что бы я сделал в отсутствие Hibernate?» Hibernate
не изменяет обычную семантику Java.
Мы советуем создавать вспомогательные методы, объединяющие эти операции,
которые обеспечивают повторное использование кода, помогают убедиться в кор-
ректности и гарантируют целостность данных (у предложения цены (Bid) должна
быть ссылка на товар (Item)). Следующий листинг показывает такой вспомога-
тельный метод для класса Item.
Листинг 3.3  Вспомогательный метод упрощает управление отношениями
Файл:/model/src/main/java/org/jpwh/model/simple/Item.java
public void addBid(Bid bid) {
if (bid == null) Используйте защитное программирование
throw new NullPointerException("Can't add null Bid");
if (bid.getItem() != null)
throw new IllegalStateException("Bid is already assigned to an Item");
getBids().add(bid);
bid.setItem(this);
}
Метод addBid() не только сокращает количество строк кода при работе с экземплярами
Item и Bid, но и обеспечивает множественный характер ассоциации.
Избегайте ошибок, отказываясь от выполнения одного из необходимых действий.
По возможности всегда объединяйте операции над ассоциациями подобным обра-
зом. Если сравнить эту реализацию с реляционной моделью внешних ключей в базе
данных SQL, легко можно увидеть, как модель, включающая граф объектов и ука-
затели, может усложнить простую операцию: вместо декларативного ограничения
потребуется написать процедурный код, гарантирующий целостность данных.
Реализация предметной модели  71
Поскольку желательно, чтобы addBid() оставался единственным методом, изме-
няющим предложения цен на товар, – возможно, как дополнение к методу remove-
Bid(), – можно сделать метод Item#setBids() приватным или избавиться от него,
настроив Hibernate на прямой доступ к полям класса для поддержки хранения. По
той же причине для метода Bid#setItem() можно установить видимость на уровне
пакета.
Метод чтения Item#getBids() по-прежнему возвращает изменяемую коллек-
цию, так что клиенты могут использовать ее для внесения изменений, которые не
будут отражаться на противоположной стороне. Предложения цены, помещенные
непосредственно в коллекцию, не будут ссылаться на товар: согласно ограниче-
ниям базы данных, это является противоречивым состоянием. Чтобы избежать
этого, можно обернуть внутреннюю коллекцию перед возвратом с помощью Collections.
unmodifiableCollection(c)и Collections.unmodifiableSet(s). В этом случае
клиент получит исключение при попытке изменить коллекцию; вы, таким об-
разом, вынуждаете делать каждое изменение с помощью методов, управляющих
отношениями, что обеспечивает целостность данных. Обратите внимание, что
в этом случае необходимо настроить Hibernate на прямой доступ к полям класса,
поскольку коллекция, возвращаемая методом чтения, будет отличаться от пере-
данной в метод записи.
Альтернативой является использование неизменяемых экземпляров. Напри-
мер, целостность данных можно обеспечить, требуя передачи аргумента типа Item
в конструктор класса Bid, как показано в листинге 3.4.
Листинг 3.4  Обеспечение целостности отношений с помощью конструктора
Файл:/model/src/main/java/org/jpwh/model/simple/Bid.java
public class Bid {
protected Item item;
public Bid(Item item) {
this.item = item;
item.getBids().add(this); Двунаправленный
}
public Item getItem() {
return item;
}
}
Этот конструктор присваивает значение полю item – его значение больше не
должно меняться. Коллекция с «другой» стороны тоже обновляется для поддер-
жания двустороннего отношения. Метод Bid#setItem() отсутствует, и, возможно,
не следует также делать общедоступным метод Item#setBids().
У такого подхода есть несколько проблем. Во-первых, Hibernate не сможет вы-
звать этот конструктор. Hibernate может использовать только конструктор без ар-
гументов, и он должен иметь, по меньшей мере, видимость пакета. Кроме того, по-
72  Модели предметной области и метаданные
скольку отсутствует метод setItem(), необходимо настроить Hibernate на прямой
доступ к полюitem. Это означает, что это поле не может иметь модификатор final
и, следовательно, нельзя гарантировать неизменяемость класса.
В примерах из этой книги мы иногда будем создавать вспомогательные мето-
ды наподобие Item#addBid(), показанного выше, или дополнительные конструк-
торы для нужных значений. Только вам решать, сколько вспомогательных мето-
дов и слоев использовать для обертывания хранимых свойств ассоциаций и/или
полей, но мы бы советовали быть последовательными и придерживаться одной
стратегии для всех классов предметной модели. Для краткости мы не всегда бу-
дем показывать вспомогательные методы, специальные конструкторы и прочий
дополнительный код в будущих примерах и рассчитываем, что вы сами добавите
их согласно своим предпочтениям и требованиям.
Вы уже рассмотрели классы предметной модели, узнали, как представлять их
атрибуты и отношения между ними. Далее мы повысим уровень абстрагирования,
добавляя в реализацию модели метаданные и описывая такие свойства, как пра-
вила валидации и хранения.
3.3. Метаданные предметной модели
Метаданные – это данные о данных, поэтому метаданные предметной модели яв-
ляются данными о ней. Например, когда вы используете механизм рефлексии Java
для определения имен классов предметной модели или их атрибутов, вы обращаетесь
к метаданным этой модели.
Инструментам ORM также требуются метаданные для описания отображений
между классами и таблицами, свойствами и столбцами, ассоциациями и внеш-
ними ключами, типами Java и типами SQL и т. д. Эти метаданные объектно-ре-
ляционного отображения управляют преобразованиями между различными
системами типов и представлениями отношений в объектно-ориентированных
и SQL-системах. JPA обладает прикладным программным интерфейсом для рабо-
ты с метаданными, который можно вызвать для получения информации о храни-
мых свойствах предметной модели, таких как имена хранимых сущностей и атри-
бутов. Ваша первоочередная задача как инженера – создавать и сопровождать эти
метаданные.
Стандарт JPA определяет два варианта объявления метаданных: при помощи
аннотаций в Java-коде или внешних файлов XML-дескрипторов. В Hibernate име-
ются некоторые собственные расширения, также доступные в виде аннотаций и/
или XML-дескрипторов. Как правило, в качестве основного источника метадан-
ных отображений мы выбираем либо аннотации, либо XML. После прочтения
этого раздела у вас будет необходимая информация для принятия обоснованного
решения в собственном проекте.
Мы также обсудим спецификацию Bean Valildation (JSR 303) и то, как она обеспечивает
декларативную валидацию классов предметной модели (или любых
других классов). Проект Hibernate Validator является эталонной реализацией этой
Метаданные предметной модели  73
спецификации. Ныне в качестве основного механизма объявления метаданных
большинство инженеров предпочитает использовать аннотации.
3.3.1. Определение метаданных с помощью аннотаций
Большим достоинством аннотаций является их близость к описываемым данным.
Приведем пример:
Файл:/model/src/main/java/org/jpwh/model/simple/Item.java
import javax.persistence.Entity;
@Entity
public class Item {
}
Стандартные аннотации JPA можно найти в пакете javax.persistence. В данном
примере аннотация @javax.persistence.Entity объявляет класс Item хранимой сущ-
ностью. При этом все его атрибуты автоматически становятся хранимыми, с при-
менением стратегии по умолчанию. Это значит, что вы можете загружать и сохра-
нять экземпляры Item, и все его свойства будут частью управляемого состояния.
(Читая предыдущую главу, вы, возможно, заметили отсутствие обязательной
аннотации @Id и свойства-идентификатора. Если вы захотите использовать при-
мер Item, добавьте свойство-идентификатор. Мы обсудим свойства-идентифика-
торы снова в следующей главе, в разделе 4.2.)
Аннотации типобезопасны, и метаданные JPA включаются в файлы скомпили-
рованных классов. Затем, во время запуска приложения, Hibernate читает классы
и метаданные, используя механизм рефлексии Java. Интегрированная среда раз-
работки (IDE) может с легкостью проверять и подсвечивать аннотации – в конце
концов, это обычные типы Java. При проведении рефакторинга постоянно при-
ходится переименовывать, удалять или перемещать классы и свойства. Большин-
ство текстовых редакторов и инструментов для разработки не может проводить
рефакторинг значений атрибутов и элементов XML, но аннотации являются
частьюязыка
Java и участвуют во всех операциях рефакторинга.
Мой класс теперь зависит от JPA?
Да, но это лишь зависимость времени компиляции. Вам потребуется обеспечить
доступность библиотек JPA во время компиляции исходного кода классов вашей
предметной модели. Наличие Java Persistence API не обязательно для создания
экземпляров класса – например, в клиентском настольном приложении, не ис-
пользующем JPA. Пакеты потребуются, только если вы обращаетесь к аннотациям
через механизм рефлексии во время выполнения (так работает Hibernate, когда
читает ваши метаданные).
Когда стандартизированных аннотаций Java Persistence недостаточно, реализа-
ция JPA может предоставлять дополнительные аннотации.
74  Модели предметной области и метаданные
Использование расширений реализации JPA
Даже если большую часть прикладной модели можно отобразить с помощью
JPA-совместимых аннотаций из пакета javax.persistence, в какой-то момент вам
придется использовать расширения реализации. Например, некоторые настройки
производительности, которые можно ожидать от высококачественного ПО, до-
ступны только в качестве аннотаций Hibernate. Таким способом реализации JPA
соревнуются между собой; так что вам не удастся избежать использования анно-
таций из других пакетов – это одна из причин, почему рекомендуется выбирать
Hibernate.
Следующее определение сущности Item демонстрирует возможность отобра-
жения, доступную только в Hibernate:
import javax.persistence.Entity;
@Entity
@org.hibernate.annotations.Cache(
usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE
)
public class Item {
}
Мы предпочитаем присоединять полное имя пакета org.hibernate.annotations
к аннотациям Hibernate. Считайте это хорошей практикой, т. к. вы легко сможете
увидеть, какие метаданные класса относятся к спецификации JPA, а какие – к кон-
кретной ее реализации. Также вы можете просто выполнить поиск по строке «org.
hibernate.annotations» в исходном коде и получить список всех нестандартных ан-
нотаций, используемых в приложении.
В случае смены реализации JPA вам нужно будет лишь заменить аннотации,
относящиеся к конкретной реализации, аналогичными средствами, доступными
во всех продвинутых реализациях JPA. Конечно, мы надеемся, что вам никогда не
придется этого делать – и это нечасто встречается на практике, – просто знайте,
что такое возможно.
Аннотации классов описывают метаданные, применимые лишь к этому кон-
кретному классу. Часто требуются метаданные более высокого уровня – для всего
пакета или даже всего приложения.
Метаданные и глобальные аннотации
Аннотация @Entity отображает конкретный класс. Но в JPA и Hibernate также
имеются аннотации для глобальных метаданных. Например, аннотация @Named-
Query имеет глобальную область видимости; она применяется не к конкретному
классу. Куда ее поместить?
Несмотря на то что такую глобальную аннотацию можно поместить в файл с ис-
ходным кодом класса (любого класса, в начало файла), мы предпочитаем хранить
глобальные метаданные в отдельном файле. Хорошим выбором являются анно-
тации уровня пакета; они хранятся в файле с именем package-info.java в каталоге
Метаданные предметной модели  75
конкретного пакета. Пример объявления глобальных именованных запросов по-
казан в листинге 3.5.
Листинг 3.5  Глобальные метаданные в файле package-info.java
Файл:/model/src/main/java/org/jpwh/model/querying/package-info.java
@org.hibernate.annotations.NamedQueries({
@org.hibernate.annotations.NamedQuery(
name = "findItemsOrderByName",
query = "select i from Item i order by i.name asc"
)
,
@org.hibernate.annotations.NamedQuery(
name = "findItemBuyNowPriceGreaterThan",
query = "select i from Item i where i.buyNowPrice > :price",
timeout = 60, Секунды!
comment = "Custom SQL comment"
)
})
package org.jpwh.model.querying;
Если вы не использовали аннотации уровня пакета прежде, вас, возможно, уди-
вит синтаксис с объявлениями пакета и импорта внизу.
Существует причина, почему в предыдущем примере были только аннотации
Hibernate и никаких аннотаций JPA. Мы не стали использовать стандартную ан-
нотацию JPA @org.javax.persistence.NamedQuery, а выбрали альтернативную анно-
тацию Hibernate. Аннотации JPA не поддерживают видимость на уровне пакета по
неизвестной нам причине. По сути, JPA не позволяет помещать аннотации в файл
package-info.java. Оригинальные аннотации Hibernate предоставляют ту же са-
мую, а иногда и большую функциональность, так что это не должно стать большой
проблемой. Если вы не хотите использовать аннотации Hibernate, вам придется
либо включить аннотации JPA в начало одного из классов (с другой стороны, мож-
но создать пустой класс MyNamedQueries и сделать его частью предметной модели),
либо использовать файл XML, как будет показано ниже в этом разделе.
Аннотации будут нашим главным инструментом определения метаданных
ORM на протяжении всей книги, и вы многое узнаете о них.
3.3.2. Применение правил валидации компонентов
Большинство приложений использует огромное количество проверок целостно-
сти данных. Вы уже знаете, что бывает, если нарушить хотя бы одно из простей-
ших ограничений целостности данных: вы получите NullPointerException там, где
ожидаете получить значение. В других примерах используются свойства строко-
вого типа, которые не должны быть пустыми (помните, что пустая строка не null),
строки, которые должны соответствовать определенному шаблону регулярного
выражения, а также числа и даты, которые должны находиться в определенном
диапазоне.
76  Модели предметной области и метаданные
Эти бизнес-правила влияют на каждый уровень приложения. Пользователь-
ский интерфейс должен отображать подробные и локализованные сообщения
об ошибках. Уровни бизнес-логики и хранения должны проверять приходящие
от клиентов значения, прежде чем передавать их в хранилище. База данных SQL
должна делать окончательную проверку, чтобы гарантировать целостность храни-
мой информации.
Суть идеи, лежащей в основе Bean Validation, – в том, что определять такие
правила, как «Это поле не может быть null» или «Это число должно находить-
ся в заданном диапазоне», гораздо проще, чем постоянно писать подверженные
ошибкам процедуры проверок с использованием условных операторов. Более
того, задание таких правил для центрального компонента приложения – реализа-
ции предметной модели – позволяет осуществлять проверку целостности на каж-
дом уровне системы. Эти правила доступны уровням представления и хранения.
Если вы посмотрите, как ограничения целостности данных влияют не только на
код приложения, но и на схему базы данных SQL, являющуюся набором правил
поддержания целостности, вы сможете представить ограничения Bean Validation
как дополнительные метаданные ORM.
Посмотрите на расширенную версию класса Item предметной модели.
Листинг 3.6  Применение правил валидации к свойствам сущности Item
Файл:/model/src/main/java/org/jpwh/model/simple/Item.java
import javax.validation.constraints.Future;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
@Entity
public class Item {
@NotNull
@Size(
min = 2,
max = 255,
message = "Name is required, maximum 255 characters."
)
protected String name;
@Future
protected Date auctionEnd;
}
Здесь добавлены еще два атрибута: наименование товара (name) и дата оконча-
ния аукциона (auctionEnd). Оба являются типичными кандидатами для дополни-
тельных ограничений – важно гарантировать присутствие осмысленного наиме-
нования (наименование из одной буквы бессмысленно), но не слишком длинного:
база данных SQL работает наиболее эффективно со строками произвольной дли-
ны до 255 символов, и пользовательский интерфейс также имеет ограничения на
пространство, занимаемое видимой надписью. Время окончания аукциона, оче-
видно, должно быть в будущем. Если вы не подготовите сообщения об ошибке,
Метаданные предметной модели  77
будет показано сообщение по умолчанию. Сообщения могут представлять собой
ключи к внешним файлам свойств, используемым для интернационализации.
Механизм валидации будет обращаться напрямую к полям класса, если их по-
метить аннотациями. Если вы предпочитаете методы доступа, помечать аннота-
цией проверки ограничений нужно метод чтения, а не записи. Ограничения яв-
ляются также частью API класса и помещаются в Javadoc, что делает реализацию
предметной модели более понятной. Обратите внимание, что механизм валидации
имеет свои настройки, не зависящие от настроек реализации JPA, т. е. Hibernate
Validator может вызывать методы доступа, тогда как Hibernate ORM может об-
ращаться напрямую к полям класса.
Bean Validation не ограничивается встроенными аннотациями; вы можете соз-
давать собственные ограничения и аннотации. Пользовательские ограничения по-
зволяют даже применять аннотации на уровне класса и проверять несколько атри-
бутов экземпляра класса одновременно. Следующий тестовый код демонстрирует,
как вручную проверить целостность экземпляра Item:
Листинг 3.7  Проверка экземпляра Item на предмет нарушения ограничений
Файл:/examples/src/test/java/org/jpwh/test/simple/ModelOperations.java
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
Item item = new Item();
item.setName("Some Item");
item.setAuctionEnd(new Date());
Set<ConstraintViolation<Item>> violations = validator.validate(item);
assertEquals(1, violations.size());
ConstraintViolation<Item> violation = violations.iterator().next();
String failedPropertyName =
violation.getPropertyPath().iterator().next().getName();
assertEquals(failedPropertyName, "auctionEnd");
if (Locale.getDefault().getLanguage().equals("en"))
assertEquals(violation.getMessage(), "must be in the future");
Мы не будем подробно объяснять этот код, а предоставим его исследование чи-
тателю. Вам редко придется писать проверки такого рода: большую часть времени
эта работа будет выполняться вашим пользовательским интерфейсом и фрейм-
ворком хранения. Поэтому важно обратить внимание на интеграцию с Bean Validation
при выборе фреймворка пользовательского интерфейса. JSF версии 2.0
и выше, к примеру, автоматически интегрируется с Bean Validation.
Hibernate, как это требуется от любой реализации JPA, автоматически интегри-
руется с Hibernate Validator, если библиотеки доступны в пути поиска классов,
и предлагает следующие возможности:
 она требует вручную осуществлять валидацию экземпляров перед переда-
чей их на сохранение;
Одна ошибка валидации:
дата аукциона
не находится в будущем
78  Модели предметной области и метаданные
 Hibernate распознает ограничения хранимых классов предметной модели
и вызывает валидацию перед операциями вставки и обновления базы дан-
ных. В случае выявления нарушений Hibernate вызывает исключение ConstraintViolationException
с информацией об ошибке в коде, который вы-
звал операцию сохранения;
 инструментарий Hibernate, автоматически генерирующий SQL-схемы,
понимает многие ограничения и создает аналогичные ограничения SQL
в DDL-определениях данных. Например, аннотация @NotNull транслирует-
ся в SQL-ограничение NOT NULL, а правило @Size(n) задает количество симво-
лов в столбце типа VARCHAR(n).
Вы можете управлять этим поведением Hibernate, используя элемент <validation-
mode> в конфигурационном файле persistence.xml. По умолчанию использует-
ся режим AUTO, следовательно, Hibernate будет осуществлять валидацию, только
если найдет реализацию Bean Validation (например, Hibernate Validator) в пути
поиска классов запущенного приложения. В режиме CALLBACK валидация выпол-
няется всегда, и вы получите ошибку развертывания (deployment error), если за-
будете скомпоновать свое приложение с реализацией Bean Validation. Режим NONE
отключает автоматическую валидацию реализацией JPA.
Вы еще увидите аннотации Bean Validation далее в этой книге; вы также найдете
их в комплекте примеров. Сейчас мы могли бы написать гораздо больше о Hibernate
Validator, но мы лишь повторили бы ту информацию, что уже содержится
в отличном справочном руководстве проекта. Прочтите ее, чтобы узнать о таких
особенностях, как группы валидации или прикладной интерфейс обнаружения
ограничений в метаданных.
Стандарты Java Persistence и Bean Validation широко используют аннотации.
Экспертные группы были хорошо осведомлены о преимуществах XML-дескрипторов
развертывания в определенных условиях, особенно для определения мета-
данных, меняющихся при каждом развертывании.
3.3.3. Метаданные во внешних XML-файлах
Вы можете заменить или переопределить любую аннотацию JPA при помощи эле-
мента XML-дескриптора. Другими словами, вы не обязаны использовать аннота-
ции, если не хотите этого или когда размещение метаданных отдельно от исход-
ного кода по каким-то причинам выгодно для вашего проекта.
XML-метаданные и JPA
В листинге 3.8 показан XML-дескриптор JPA для конкретной единицы хранения.
Листинг 3.8  XML-дескриптор JPA с метаданными отображения единицы
хранения
<entity-mappings
version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
Метаданные предметной модели  79
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm
http://xmlns.jcp.org/xml/ns/persistence/orm_2_1.xsd">
<persistence-unit-metadata> Сначала глобальные метаданные
<xml-mapping-metadata-complete/>
<persistence-unit-defaults> Некоторые настройки по умолчанию
<delimited-identifiers/>
</persistence-unit-defaults>
</persistence-unit-metadata>
<entity class="org.jpwh.model.simple.Item" access="FIELD">
<attributes>
<id name="id">
<generated-value strategy="AUTO"/>
</id>
<basic name="name"/>
<basic name="auctionEnd">
<temporal>TIMESTAMP</temporal>
</basic>
</attributes>
</entity>
</entity-mappings>
Реализация JPA начнет автоматически использовать этот дескриптор, если по-
местить его в файл META-INF/orm.xml, находящийся в пути поиска классов еди-
ницы хранения. Если вы предпочитаете использовать другое имя или несколько
файлов, придется поменять конфигурацию единицы хранения в файле METAINF/
persistence.xml:
Файл:/model/src/main/resources/META-INF/persistence.xml
<persistence-unit name="SimpleXMLCompletePU">
...
<mapping-file>simple/Mappings.xml</mapping-file>
<mapping-file>simple/Queries.xml</mapping-file>
...
</persistence-unit>
При наличии элемента <xml-mapping-metadata-complete> реализация JPA будет
игнорировать все аннотации в классах предметной модели в этой единице хране-
ния и полагаться лишь на отображения, определенные в XML-дескрипторе(ах).
Также можно (в данном случае это лишнее) активировать эту настройку на уровне
сущности, используя <metadata-complete="true"/>. При активации реализация JPA
предполагает, что вы отобразили все атрибуты сущности в XML, и ей следует иг-
норировать все аннотации в этой конкретной сущности.
Если вместо этого требуется не игнорировать, а переопределить метаданные,
указанные в аннотации, – не помечайте XML-дескриптор как «завершенный»
и укажите класс и свойство для переопределения:
Игнорировать
все аннотации
и любые метаданные
отображения
в XML-файлах
Экранировать все SQL-имена,
включая столбцы и таблицы:
например, если ваши
SQL-имена являются
ключевыми словами
(такими как «USER»)
80  Модели предметной области и метаданные
<entity class="org.jpwh.model.simple.Item">
<attributes>
<basic name="name"> Переопределить имя столбца SQL
<column name="ITEM_NAME"/>
</basic>
</attributes>
</entity>
Здесь свойство name отображается в столбец ITEM_NAME; по умолчанию свой-
ство отображалось бы в столбец NAME. Теперь Hibernate будет игнорировать все
аннотации из пакетов javax.persistence.annotation и org.hibernate.annotations,
которыми отмечено поле name класса Item. Но Hibernate не станет игнорировать
аннотации Bean Validation и продолжит использовать их для автоматической ва-
лидации и создания схемы! Все остальные аннотации для класса Item также будут
распознаваться. Обратите внимание, что в этом отображении не определена стра-
тегия доступа, поэтому, в зависимости от расположения аннотации @Id в классе
Item, будет использоваться либо прямое обращение к полю, либо методы доступа
(мы обсудим эту подробность в следующей главе).
В этой книге мы не станем много говорить о XML-дескрипторах JPA. Синтаксис
этих документов является зеркальным отражением синтаксиса JPA-аннотаций,
так что у вас не должно возникнуть проблем с их созданием. Мы заострим внима-
ние на важном вопросе – стратегиях отображения. Синтаксис, используемый для
записи метаданных, является вторичным.
К сожалению, как и большинство схем в JavaEE, JPA-схема orm_2_0.xsd не
допускает расширения реализациями. Вы не сможете использовать элементы
и атрибуты из других пространств имен в XML-документах отображений JPA.
Следовательно, использование расширений и оригинальных особенностей Hibernate
требует использования иного синтаксиса XML.
XML-файлы отображений Hibernate
Оригинальный формат XML-файлов отображений Hibernate был первоначаль-
ным вариантом метаданных до того, как в JDK 5 появились аннотации. По со-
глашению к именам этих файлов добавляется расширение .hbm.xml. Листинг 3.9
демонстрирует основной XML-документ отображения Hibernate:
Листинг 3.9  Документ определения метаданных с оригинальным
XML-синтаксисом Hibernate
Файл:/model/src/main/resources/simple/Native.hbm.xml
<?xml version="1.0"?>
<hibernate-mapping
xmlns="http://www.hibernate.org/xsd/orm/hbm"
package="org.jpwh.model.simple"
default-access="field">  Объявление метаданных
<class name="Item"> Отображение класса сущности
<id name="id">
Метаданные предметной модели  81
<generator class="native"/>
</id>
<property name="name"/>
<property name="auctionEnd" type="timestamp"/>
</class>
<query name="findItemsHibernate">select i from Item i</query>
<database-object>
<create>create index ITEM_NAME_IDX on ITEM(NAME)</create>
<drop>drop index if exists
ITEM_NAME_IDX</drop>
</database-object>
</hibernate-mapping>
 Метаданные объявляются в корневом элементе <hibernate-mapping>. Такие атрибуты,
как имя пакета и доступ по умолчанию, применяются ко всем отображениям в этом фай-
ле. Вы можете добавить столько отображений классов сущностей, сколько захотите.
Обратите внимание, что в этом файле объявляется пространство имен XML по
умолчанию для всех элементов; это новая возможность в Hibernate 5. Если у вас
уже имеются файлы отображений для Hibernate 4 или старше, содержащие опре-
деления типа документа XML, можете продолжать их использовать.
Несмотря на возможность объявления отображений для нескольких классов
в одном файле, включив несколько элементов <class>, большое количество старых
проектов Hibernate использует один файл отображения для каждого хранимого
класса. По соглашению файл должен иметь то же имя и пакет, что и класс: напри-
мер, my/model/Item.hbm.xml – для класса my.model.Item.
Отображение класса в XML-документе Hibernate является «завершенным», т. е.
любые другие метаданные отображения для этого класса в аннотациях или XML-
файлах JPA вызовут ошибку «duplicate mapping» (дублирование отображения)
при запуске. Если вы описываете отображение класса в XML-файле Hibernate, это
описание должно включать все детали отображения. Невозможно переопределить
отдельные поля или расширить существующее отображение. Кроме того, в XML-
файле Hibernate нужно перечислить и отобразить все хранимые свойства класса
сущности. Если свойство не имеет отображения, Hibernate считает его состояние
временным. Сравните это с отображениями в JPA, где одна лишь аннотация @Entity
делает все свойства класса хранимыми.
Оригинальные XML-файлы Hibernate больше не являются предпочтитель-
ным способом объявления основных метаданных ORM. Большинство инженеров
предпочитает аннотации. Оригинальные XML-файлы метаданных в основном
используются для доступа к особенностям Hibernate, которые недоступны в виде
аннотаций или которые легче сопровождать в XML-файлах (например, если это
метаданные конфигурации, зависящие от условий развертывания). В XML-файле
отображений Hibernate вообще могут отсутствовать любые элементы <class> .
В таком случае все метаданные из этого файла, такие как строки запросов (или
Запросы, вынесенные
в отдельный файл
Вспомогательные
определения DDL
82  Модели предметной области и метаданные
даже запросы на чистом SQL), вынесенные в отдельный файл, определения поль-
зовательских типов, вспомогательные выражения DDL для конкретных СУБД,
динамические фильтры контекста хранения и т. д., могут быть глобальными для
единицы хранения.
Когда позже мы будем обсуждать такие продвинутые возможности Hibernate,
мы покажем, как объявлять все это в XML-файлах. Как уже упоминалось, вы
должны сосредоточиться на понимании сущности стратегий отображения, и для
их демонстрации большинство наших примеров будет использовать аннотации
JPA и Hibernate.
Все рассматривавшиеся до сих пор подходы предполагали, что на момент раз-
работки (развертывания) известны все метаданные ORM. Предположим, что
какая-то часть информации остается неизвестной до запуска приложения. Мож-
но ли программно манипулировать метаданными отображений во время вы-
полнения? Также мы упоминали программный интерфейс метаданных JPA для
доступа к подробным деталям единицы хранения. Как это работает и когда это
полезно?
3.3.4. Доступ к метаданным во время выполнения
Спецификация JPA определяет программные интерфейсы для доступа к метамо-
дели хранимых классов. Существуют два типа таких интерфейсов. Первый, более
динамичный по природе, похож на простую рефлексию в Java. Второй представ-
ляет собой статическую метамодель, которая обычно создается процессором ан-
нотаций Java 6. В обоих случаях доступ возможен только на чтение; невозможно
менять метаданные во время выполнения.
Hibernate также предлагает оригинальный API метамодели, поддерживающий
доступ как на чтение, так и на запись, а также доступ к большему количеству дета-
лей ORM. Мы не будем рассматривать этот API (расположенный в org.hibernate.
cfg.Configuration), поскольку на момент создания книги он уже был устаревшим,
и не было API, его заменяющего. За последней информацией об этой возможности
обращайтесь к документации Hibernate.
Динамический интерфейс Metamodel API в Java Persistence
Иногда – например, когда требуется написать собственный код валидации или
обобщенный код пользовательского интерфейса, – желательно иметь программ-
ный доступ к хранимым атрибутам сущности. Так, порой желательно знать, какие
хранимые классы и атрибуты имеются в предметной модели. Код в листинге 3.10
показывает, как читать метаданные с помощью интерфейсов Java Persistence.
Листинг 3.10  Получение информации о типе сущности с помощью Metamodel API
Файл:/examples/src/test/java/org/jpwh/test/simple/AccessJPAMetamodel.java
Metamodel mm = entityManagerFactory.getMetamodel();
Set<ManagedType<?>> managedTypes = mm.getManagedTypes();
assertEquals(managedTypes.size(), 1);
Метаданные предметной модели  83
ManagedType itemType = managedTypes.iterator().next();
assertEquals(
itemType.getPersistenceType(),
Type.PersistenceType.ENTITY
);
Экземпляр Metamodel можно получить либо из объекта EntityManagerFactory,
который обычно имеется в приложении в одном экземпляре на каждый источник
данных, либо, если так удобнее, вызывая EntityManager#getMetamodel(). Множество
управляемых типов содержит информацию обо всех хранимых сущностях
и встроенных классах (которые мы рассмотрим в следующей главе). В этом при-
мере есть только одна сущность Item. Вот как можно копнуть глубже и узнать
больше о каждом атрибуте.
Листинг 3.11  Получение информации об атрибутах сущности с помощью
Metamodel API
Файл:/examples/src/test/java/org/jpwh/test/simple/AccessJPAMetamodel.java
SingularAttribute nameAttribute =
itemType.getSingularAttribute("name");  Атрибут сущности
assertEquals(
nameAttribute.getJavaType(),
String.class
);
assertEquals(
nameAttribute.getPersistentAttributeType(),
Attribute.PersistentAttributeType.BASIC
);
assertFalse(
nameAttribute.isOptional() Not null
);
SingularAttribute auctionEndAttribute =
itemType.getSingularAttribute("auctionEnd");  Атрибут сущности
assertEquals(
auctionEndAttribute.getJavaType(),
Date.class
);
assertFalse(
auctionEndAttribute.isCollection()
);
assertFalse(
auctionEndAttribute.isAssociation()
);
Получение атрибутов сущности происходит с использованием строк name ()
и auctionEnd(). Очевидно, это небезопасно с точки зрения типизации, и, если по-
меняются названия атрибутов, этот код перестанет работать. Строки не включа-
ются автоматически в операции рефакторинга, выполняемые IDE.
84  Модели предметной области и метаданные
JPA также предлагает статическую типобезопасную метамодель.
Статическая метамодель
Java (по крайней мере, до версии 8) не имеет полноценной поддержки свойств.
Невозможно получить доступ к полям класса или методам доступа компонента ти-
побезопасным способом – только по их именам с использованием строк. Особенно
это неудобно при использовании запросов на основе критериев JPA, безопасной
с точки зрения типизации альтернативы строковым языкам запросов. Вот пример:
CriteriaBuilder cb = entityManager.getCriteriaBuilder();
CriteriaQuery<Item> query =
cb.createQuery(Item.class); Эквивалент этого запроса: «select i from Item i»
Root<Item> fromItem = query.from(Item.class);
query.select(fromItem);
List<Item> items =
entityManager.createQuery(query)
.getResultList();
assertEquals(items.size(), 2);
Данный запрос возвращает все товары из базы данных; сейчас их два. Если вы
хотите ограничить результат и вернуть только товары с определенными названиями,
придется использовать выражение like, сравнивающее атрибут name каж-
дого товара с шаблоном, заданным через параметр.
Path<String> namePath = fromItem.get("name"); «where i.name like :pattern»
query.where(
cb.like(
namePath, Для оператора like() нужен экземпляр Path<String>!
cb.parameter(String.class, "pattern")
)
);
items =
entityManager.createQuery(query)
.setParameter("pattern", "%some item%") Произвольные последовательности символов!
.getResultList();
assertEquals(items.size(), 1);
assertEquals(items.iterator().next().getName(), "This is some item");
Обратите внимание, что для поиска namePath требуется строка name. В этом са-
мом месте нарушается безопасность типов в запросе на основе критериев. Вы мо-
жете переименовать класс сущности Item в процессе рефакторинга, и запрос будет
по-прежнему работать. Но стоит только изменить поле Item#name, как потребуется
вносить исправления вручную. К счастью, эта проблема легко обнаруживается
с помощью тестов.
Лучшим решением, безопасным для рефакторинга и выявления несоответствий
во время компиляции, а не выполнения, является типобезопасная статическая ме-
тамодель:
Метаданные предметной модели  85
query.where(
cb.like(
fromItem.get(Item_.name), Статическая метамодель Item!
cb.parameter(String.class, "pattern")
)
);
Item_ – это особый класс (обратите внимание на подчеркивание). Он является
классом метаданных и перечисляет все атрибуты класса сущности Item:
@javax.persistence.metamodel.StaticMetamodel(Item.class)
public abstract class Item_ {
public static volatile SingularAttribute<Item, Long> id;
public static volatile SingularAttribute<Item, String> name;
public static volatile SingularAttribute<Item, Date> auctionEnd;
}
Этот класс можно написать вручную или, как и задумывали проектировщики,
автоматически сгенерировать при помощи утилиты обработки аннотаций (annotation
processing tool – apt) компилятора Java. Hibernate JPA2 Metamodel Generator
(отдельный проект в семействе Hibernate) использует это расширение. Его един-
ственной целью является создание статических классов метамодели из управляе-
мых хранимых классов. Вы можете скачать его JAR-файл и интегрировать в свою
IDE (или в инструмент сборки Maven, как сделано в примерах к этой книге). Он
будет автоматически вызываться при каждой компиляции (или изменении, в за-
висимости от IDE) класса сущности Item, генерируя соответствующий класс ме-
таданных Item.
Что такое утилита обработки аннотаций (apt)?
Java включает утилиту командной строки apt (annotation processing tool), которая
находит и обрабатывает аннотации в исходном коде с помощью соответствующих
процессоров. Для обработки аннотаций в программе процессор аннотаций ис-
пользует механизм рефлексии (JSR 175). Программный интерфейс apt позволяет
получить время сборки, имя исходного файла и представление, доступное только
для чтения, для моделирования системы типов в Java. Процессоры аннотаций мо-
гут сначала создать новый исходный код и файлы, которые apt затем скомпилирует
вместе с остальным исходным кодом.
В предыдущих разделах вы познакомились с некоторыми конструкциями
отображений,
но мы еще не представили более изощренных способов отображе-
ния классов и свойств. Сейчас вы должны определить, какую стратегию опреде-
ления метаданных отображения использовать в своем проекте, – мы рекомендуем
аннотации, а XML применять только в случае необходимости, – а затем, в следую-
щей главе, узнать еще больше об отображениях