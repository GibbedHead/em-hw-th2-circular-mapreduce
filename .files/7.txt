Полезным дополнением к классу Item может стать свойство buyer (покупатель).
Благодаря ему вы сможете вызвать метод someItem.getBuyer(), чтобы получить
пользователя (User), сделавшего решающую ставку. Если сделать эту связь дву-
направленной, вы сможете отобразить окно со списком всех аукционов, в кото-
рых победил конкретный пользователь: вместо запроса вы сможете вызвать метод
someUser.getBoughtItems().
С точки зрения класса User связь имеет тип один ко многим. Классы и их отно-
шения показаны на рис. 8.8.
Item User 0..* bought
Рис. 8.8  Отношение «купил» между классами User и Item
Чем данная связь отличается от той, что связывает классы Item и Bid? Множественность
0..* в UML означает, что связь может быть необязательной. Это не по-
влияет на предметную модель, но будет иметь последствия для соответствующих
таблиц. Можно ожидать наличия столбца внешнего ключа BUYER_ID в таблице ITEM.
Столбец может содержать null, поскольку пользователь мог еще не купить кон-
кретный товар, представленный объектом Item (пока аукцион еще проводится).
Можно принять тот факт, что столбец внешнего ключа может содержать NULL,
и сформулировать дополнительные ограничения: «Может содержать NULL, только
если аукцион еще не закончился или не было сделано ни одной ставки». В схемах
реляционных баз данных мы всегда стараемся избегать столбцов, которые могут
хранить null. Неопределенная информация снижает качество хранимой информа-
ции. Кортежи представляют истинные высказывания, и вы не можете утверждать
того, чего не знаете. Более того, на практике многие разработчики и администра-
торы баз данных (DBA) не создают нужных ограничений, полагая, что целостность
данных будет обеспечена несовершенным кодом приложения.
Необязательную связь между сущностями, будь то один к одному или один ко
многим, лучше всего представлять в базе данных SQL таблицей соединения. Схема
базы данных показана на рис. 8.9.
ID << PK >>
...
<< Table >>
USERS
ID << PK >>
...
<< Table >>
ITEM
ITEM_ID << PK >> << FK >>
BUYER_ID << FK >>
<< Table >>
ITEM_BUYER
Рис. 8.9  Товары и покупатели связаны промежуточной таблицей
228  Продвинутые приемы отображения связей между сущностями
Ранее в этой главе мы уже добавляли таблицу соединения для организации
связи один к одному. Чтобы гарантировать множественность один к одному, мы
добавили ограничение уникальности для столбца внешнего ключа таблицы со-
единения. В данном случае мы имеем множественность один ко многим, поэтому
только первичный ключ ITEM_ID должен быть уникальным: товар (Item) может
быть куплен лишь однажды только одним пользователем (User). Значения столб-
ца BUYER_ID не должны быть уникальными, поскольку один пользователь (User)
может купить несколько товаров (Item).
Отображение коллекции User#boughtItems выглядит довольно просто:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/jointable/
User.java
@Entity
@Table(name = "USERS")
public class User {
@OneToMany(mappedBy = "buyer")
protected Set<Item> boughtItems = new HashSet<Item>();
// ...
}
Это обычная сторона двунаправленной ассоциации, доступная только для чте-
ния, действительное отображение которой на схему определено на отображающей
стороне, перед свойством Item#buyer:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/jointable/
Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.LAZY)
@JoinTable(
name = "ITEM_BUYER",
joinColumns =
@JoinColumn(name = "ITEM_ID"), По умолчанию ID
inverseJoinColumns =
@JoinColumn(nullable = false) По умолчанию BUYER_ID
)
protected User buyer;
// ...
}
Это ясно выраженное, необязательное отношение один ко многим/многие к од-
ному. Если товар (Item) никто не купил, в таблице соединения ITEM_BUYER не будет
соответствующей записи. В схеме нет проблемных столбцов, которые могли бы
содержать null. Тем не менее для таблицы ITEM_BUYER нужно создать процедур-
ное ограничение и триггер, выполняемый во время операции INSERT: «Разрешить
Связь один ко многим  229
вставку строки с покупателем, если время аукциона для данного товара закончи-
лось или пользователь сделал решающее предложение».
Далее следует последний пример со связью один ко многим. До сих пор нам
встречались только связи один ко многим, направленные от сущности к сущности.
Класс встраиваемого компонента также может быть связан с сущностью связью
один ко многим.
8.2.4. Связь один ко многим во встраиваемых классах
Давайте снова рассмотрим отображение встраиваемого компонента, с которым мы
работали на протяжении нескольких глав, – адреса (Address) пользователя (User).
Мы расширим этот пример, добавив связь один ко многим от класса Address к клас-
су Shipment – коллекцию с названием deliveries (доставки). UML-диаграмма клас-
сов для этой модели показана на рис. 8.10.
Рис. 8.10  Отношение один ко многим
от класса Address к классу Shipment
Класс Address – это встраиваемый (@Embeddable) класс, а не сущность. Он может
владеть однонаправленной связью к сущности; в данном случае связью с множественностью
один ко многим, направленной к классу Shipment (в следующем разделе
вы увидите встраиваемый класс, связанный с сущностью отношением многие к од-
ному).
В классе Address объявлено свойство Set<Shipment>, представляющее эту ассо-
циацию:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
embeddable/Address.java
@Embeddable
public class Address {
@NotNull
@Column(nullable = false)
protected String street;
@NotNull
@Column(nullable = false, length = 5)
protected String zipcode;
@NotNull
@Column(nullable = false)
protected String city;
@OneToMany
@JoinColumn(
230  Продвинутые приемы отображения связей между сущностями
name = "DELIVERY_ADDRESS_USER_ID", По умолчанию DELIVERIES_ID
nullable = false
)
protected Set<Shipment> deliveries = new HashSet<Shipment>();
// ...
}
Первая стратегия отображения этой связи основана на аннотации @JoinColumn,
определяющей столбец с именем DELIVERY_ADDRESS_USER_ID. Как видно на рис. 8.11,
этот столбец с ограничением внешнего ключа расположен в таблице SHIPMENT.
ID << PK >>
CREATEDON
DELIVERY_ADDRESS_USER_ID << FK >>
<< Table >>
ID << PK >> SHIPMENT
STREET
ZIPCODE
CITY
<< Table >>
USERS
Рис. 8.11  Первичный ключ таблицы USERS
связывает таблицы USERS и SHIPMENT
Встраиваемые компоненты не имеют собственных идентификаторов, поэтому
значением столбца внешнего ключа будет идентификатор объекта User, в который
встроен объект Address. Здесь мы также применили параметр nullable = false, чтобы
каждой отправке (Shipment) соответствовал адрес доставки. Двунаправленная нави-
гация в данном случае невозможна: экземпляр Shipment не может ссылаться на эк-
земпляр Address, потому что встроенные компоненты не могут иметь общих ссылок.
ID << PK >>
CREATEDON
<< Table >>
ID << PK >> SHIPMENT
STREET
ZIPCODE
CITY
<< Table >>
USERS
USER_ID << PK >> << FK >>
SHIPMENT_ID << PK >> << FK >>
<< Table >>
DELIVERIES
Рис. 8.12  Применение промежуточной таблицы
для представления необязательной связи между таблицами USERS и SHIPMENT
Если связь необязательная и вы не желаете использовать столбец, который мо-
жет содержать null, отобразите связь на промежуточную таблицу связи/соедине-
ния, как показано на рис. 8.12. Отображение коллекции в классе Address в этом
случае будет определяться анноацией @JoinTable вместо @JoinColumn:
Файл: /model/src/main/java/org/jpwh/model/associations/onetomany/
embeddablejointable/Address.java
@Embeddable
public class Address {
@NotNull
Тройные связи и связи многие ко многим  231
@Column(nullable = false)
protected String street;
@NotNull
@Column(nullable = false, length = 5)
protected String zipcode;
@NotNull
@Column(nullable = false)
protected String city;
@OneToMany
@JoinTable(
name = "DELIVERIES", По умолчанию USERS_SHIPMENT
joinColumns =
@JoinColumn(name = "USER_ID"), По умолчанию USERS_ID
inverseJoinColumns =
@JoinColumn(name = "SHIPMENT_ID") По умолчанию SHIPMENTS_ID
)
protected Set<Shipment> deliveries = new HashSet<Shipment>();
// ...
}
Обратите внимание: если не использовать аннотацию @JoinTable или @JoinColumn,
связь @OneToMany во встраиваемом классе по умолчанию будет использовать
стратегию с применением таблицы соединения.
Из класса сущности-владельца вы можете переопределять отображения
свойств встроенного класса, используя аннотацию @AttributeOverride, как было
показано в разделе 5.2.3. Чтобы переопределить отображение таблицы соединения
или столбца, используйте аннотацию @AssociationOverride в классе сущности-вла-
дельца. Но вы не сможете изменить стратегию отображения; применение табли-
цы соединения или столбца определяется отображением в классе встраиваемого
компонента.
Отображение таблицы соединения также подходит для полноценных отобра-
жений вида многие ко многим.
8.3. Тройные связи и связи многие ко многим
Связь между классами Category и Item имеет вид многие ко многим, как показано
на рис. 8.13. В действующей системе у вас может не быть связи многие ко многим.
Судя по нашему опыту, всегда есть дополнительная информация, сопутствующая
каждой ссылке (link) между связанными экземплярами. В качестве примера мож-
но привести время, когда товар (Item) был добавлен в категорию (Category), или
пользователя (User), создавшего эту связь. Далее в этом разделе мы расширим наш
пример, чтобы продемонстрировать такой случай. Начнем с обычной и простой
связи многие ко многим.
232  Продвинутые приемы отображения связей между сущностями
Category addedBy : String Item
addedOn : Date
0..* CategorizedItem 0..*
Рис. 8.13  Связь многие ко многим между классами Category и Item
8.3.1. Однонаправленные и двунаправленные связи
многие ко многим
Таблицу соединения в базе данных, представляющую обычную связь многие ко
многим, большинство разработчиков называет связывающей таблицей, или таблицей
связи. На рис. 8.14 показано отношение многие ко многим со связывающей
таблицей.
В связывающей таблице CATEGORY_ITEM есть два столбца, одновременно являю-
щихся внешними ключами, ссылающимися на таблицы CATEGORY и ITEM соответ-
ственно. Первичный ключ таблицы включает оба столбца. Конкретная категория
(Category) может быть связана с товаром (Item) только один раз, но каждый товар
можно связать с несколькими категориями.
Используя JPA, можно отобразить связь многие ко многим, отметив коллекцию
аннотацией @ManyToMany:
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/
bidirectional/Category.java
@Entity
public class Category {
@ManyToMany(cascade = CascadeType.PERSIST)
@JoinTable(
name = "CATEGORY_ITEM",
joinColumns = @JoinColumn(name = "CATEGORY_ID"),
inverseJoinColumns = @JoinColumn(name = "ITEM_ID")
)
protected Set<Item> items = new HashSet<Item>();
// ...
}
ID << PK >>
...
<< Table >>
ITEM
ID << PK >>
...
<< Table >>
CATEGORY
CATEGORY_ID << PK >> << FK >>
ITEM_ID << PK >> << FK >>
<< Table >>
CATEGORY_ITEM
Рис. 8.14  Отношение многие ко многим
со связывающей таблицей
Тройные связи и связи многие ко многим  233
Как обычно, чтобы упростить сохранение данных, используется параметр CascadeType.
PERSIST. Когда приложение добавит в коллекцию ссылку на новый эк-
земпляр Item, Hibernate сохранит его в базе данных. Давайте сделаем эту связь
двунаправленной (этого можно не делать, если это не нужно):
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/
bidirectional/Item.java
@Entity
public class Item {
@ManyToMany(mappedBy = "items")
protected Set<Category> categories = new HashSet<Category>();
// ...
}
Как в любом отображении двунаправленной связи, одна сторона отображается
другой стороной. Коллекция Item#categories по факту доступна только для чте-
ния; во время сохранения данных Hibernate будет анализировать лишь содержи-
мое коллекции Category#items. Далее создадим две категории и два товара, а затем
свяжем их, используя отношение многие ко многим:
Файл: /examples/src/test/java/org/jpwh/test/associations/
ManyToManyBidirectional.java
Category someCategory = new Category("Some Category");
Category otherCategory = new Category("Other Category");
Item someItem = new Item("Some Item");
Item otherItem = new Item("Other Item");
someCategory.getItems().add(someItem);
someItem.getCategories().add(someCategory);
someCategory.getItems().add(otherItem);
otherItem.getCategories().add(someCategory);
otherCategory.getItems().add(someItem);
someItem.getCategories().add(otherCategory);
em.persist(someCategory);
em.persist(otherCategory);
Благодаря использованию транзитивного сохранения запись двух категорий
сохранит весь граф экземпляров. С другой стороны, параметры каскадирования
ALL, REMOVE, а также удаление осиротевших объектов (см. раздел 7.3.3) в случае свя-
зи многие ко многим бессмысленны. Вот и наступил подходящий момент, чтобы
проверить, разбираетесь ли вы в сущностях и типах-значениях. Попробуйте са-
мостоятельно найти разумные объяснения, почему эти типы каскадирования не
имеют смысла для связи многие ко многим.
234  Продвинутые приемы отображения связей между сущностями
Можно ли вместо множества (Set) использовать список (List) или даже кон-
тейнер? Множество (Set) прекрасно согласуется со схемой базы данных, посколь-
ку там тоже нет дублирующих ссылок между классами Category и Item.
Контейнер позволяет дублировать элементы, следовательно, в таблице соеди-
нения понадобится определить другой первичный ключ. Этого можно добиться
при помощи аннотации @CollectionId, показанной в разделе 7.1.5. Одна из аль-
тернативных стратегий отображения связи многие ко многим, которую мы обсу-
дим через мгновение, является лучшим решением для поддержки дублирующих
ссылок.
Отображать упорядоченные коллекции, такие как List, можно с помощью
обычной аннотации @ManyToMany, но лишь с одной стороны. Помните, что в двуна-
правленном отношении одна сторона отображается другой стороной, т. е. Hibernate
будет игнорировать ее значение при синхронизации с базой данных. Если обе
стороны представлены списками, сделать индексы элементов хранимыми можно
только с одной стороны отношения.
Обычная аннотация @ManyToMany скрывает связывающую таблицу; она не имеет
соответствующего Java-класса; есть только свойства-коллекции. Поэтому когда
кто-то скажет: «Мне нужно больше столбцов с информацией о связи в моей свя-
зывающей таблице», – а судя по нашему опыту, рано или поздно вы обязательно
услышите такие слова, – отобразите эту информацию в классе Java.
8.3.2. Связь многие ко многим с промежуточной сущностью
Связь многие ко многим всегда можно представить в виде двух связей многие к од-
ному с промежуточным классом. В этом случае промежуточная таблица не скры-
вается, а явно определяется с помощью класса Java. Такую модель, как правило,
легче расширять, поэтому мы стараемся не использовать в приложениях обычную
связь многие ко многим. Позднее, когда в связывающую таблицу добавятся допол-
нительные столбцы, будет гораздо труднее провести рефакторинг; поэтому, прежде
чем применять отображение @ManyToMany, как показано в предыдущем разделе,
рассмотрите альтернативное решение, показанное на рис. 8.15.
Category 1..* 0..* Item
Рис. 8.15  Класс CategorizedItem,
соединяющий классы Category и Item
Представьте, что вам нужно сохранять информацию при каждом связывании
товара (Item) с категорией (Category). Класс CategorizedItem описывает время
и пользователя, создавшего связь. Эта модель требует наличия дополнительных
столбцов в таблице соединения, как видно на рис. 8.16.
Новая сущность CategorizedItem будет отображаться на связывающую таблицу,
как показано далее.
Тройные связи и связи многие ко многим  235
ID << PK >>
...
<< Table >>
ITEM
ID << PK >>
...
<< Table >>
CATEGORY
CATEGORY_ID << PK >> << FK >>
ITEM_ID << PK >> << FK >>
<< Table >>
CATEGORY_ITEM
ADDEDON
ADDEDBY
Рис. 8.16  Дополнительные столбцы
в таблице соединения для отношения многие ко многим
Листинг 8.4  Отображение отношения многие ко многим с помощью класса
CategorizedItem
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/
linkentity/ CategorizedItem.java
@Entity
@Table(name = "CATEGORY_ITEM")
@org.hibernate.annotations.Immutable  Объявляет класс неизменяемым
public class CategorizedItem {
@Embeddable
public static class Id implements Serializable {  Инкапсулирует составной ключ
@Column(name = "CATEGORY_ID")
protected Long categoryId;
@Column(name = "ITEM_ID")
protected Long itemId;
public Id() {
}
public Id(Long categoryId, Long itemId) {
this.categoryId = categoryId;
this.itemId = itemId;
}
public boolean equals(Object o) {
if (o != null && o instanceof Id) {
Id that = (Id) o;
return this.categoryId.equals(that.categoryId)
&& this.itemId.equals(that.itemId);
}
return false;
}
public int hashCode() {
return categoryId.hashCode() + itemId.hashCode();
236  Продвинутые приемы отображения связей между сущностями
}
}
@EmbeddedId  Отображает свойство идентификатора и столбцы составного ключа
protected Id id = new Id();
@Column(updatable = false)
@NotNull
protected String addedBy;  Отображает имя пользователя
@Column(updatable = false)
@NotNull
protected Date addedOn = new Date();  Отображает время
@ManyToOne
@JoinColumn(
name = "CATEGORY_ID",
insertable = false, updatable = false)
protected Category category;  Отображает категорию
@ManyToOne
@JoinColumn(
name = "ITEM_ID",
insertable = false, updatable = false)
protected Item item;  Отображает товар
public CategorizedItem(
String addedByUsername,  Конструирует объект CategorizedItem
Category category,
Item item) {
this.addedBy = addedByUsername;
this.category = category;
this.item = item;
this.id.categoryId = category.getId();
this.id.itemId = item.getId();
category.getCategorizedItems().add(this);
item.getCategorizedItems().add(this);
}
// ...
}
Это довольно большой фрагмент кода с новыми аннотациями. Во-первых, это
неизменяемый класс сущности, следовательно, вы не сможете обновить значения
свойств объекта после создания. Если объявить класс неизменяемым, Hibernate
сможет применить некоторые оптимизации, например не проверять состояния
объектов во время выталкивания контекста хранения .
Класс сущности должен иметь свойство идентификатора. Первичный ключ
связывающей таблицы включает столбцы CATEGORY_ID и ITEM_ID. Поэтому
Присваивание
значений
полям класса
Установка значения
идентификатора
Гарантирует
ссылочную целостность,
если отношение
двунаправленное
Тройные связи и связи многие ко многим  237
в классе сущности также объявлен составной ключ, который для удобства ин-
капсулирован во вложенном классе встраиваемого компонента . При желании
этот класс можно поместить в отдельный файл. Новая аннотация @EmbeddedId 
отображает
свойство идентификатора и столбцы составного ключа в таблицу
сущности.
Далее следуют два свойства, отображающие имя пользователя (addedBy) 
и время (addedOn)  в столбцы таблицы соединения. Это и есть та самая «допол-
нительная информация о связи».
Два поля с аннотацией @ManyToOne – category  (категория) и item  (товар) –
отображаются в столбцы, уже перечисленные в настройках отображения иденти-
фикатора. Интересно отметить, что здесь с помощью параметров updatable=false
и insertable=false эти свойства объявляются доступными только для чтения.
Благодаря этому Hibernate будет записывать значения столбцов, используя зна-
чение идентификатора экземпляра CategorizedItem. В то же время вы сможете чи-
тать и просматривать связанные экземпляры, вызывая categorizedItem.getItem()
и getCategory() соответственно (если отобразить один столбец дважды, не ограни-
чив доступа в одном из отображений, при запуске приложения Hibernate пожалу-
ется на дублирование отображений столбца).
Также во время создания экземпляра CategorizedItem  происходит присваи-
вание значений идентификатора: приложение всегда должно устанавливать зна-
чения составного ключа; Hibernate не будет их генерировать. Обратите особое
внимание на конструктор – как он устанавливает значения полей класса и обеспечивает
ссылочную целостность, отображая коллекции по обеим сторонам ассо-
циации. Мы отобразим эти коллекции далее, чтобы обеспечить двунаправленную
навигацию.
Этого однонаправленного отображения достаточно для поддержки отноше-
ния многие ко многим между классами Category и Item. Для создания связи нужно
сконструировать и сохранить объект CategorizedItem. Чтобы разрушить связь,
удалите экземпляр CategorizedItem. Конструктору класса CategorizedItem требу-
ется предоставить уже хранящиеся экземпляры классов Category и Item соответ-
ственно.
Если требуется реализовать двунаправленную навигацию, отобразите коллек-
цию, используя аннотацию @OneToMany в классе Category и/или Item:
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/
linkentity/ Category.java
@Entity
public class Category {
@OneToMany(mappedBy = "category")
protected Set<CategorizedItem> categorizedItems = new HashSet<>();
// ...
}
238  Продвинутые приемы отображения связей между сущностями
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/
linkentity/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item")
protected Set<CategorizedItem> categorizedItems = new HashSet<>();
// ...
}
Каждая из сторон отображается аннотациями в классе CategorizedItem, поэтому
Hibernate уже знает, что делать при выполнении итераций по элементам коллек-
ции, возвращаемой любым из методов getCategorizedItems().
Вот как создаются и сохраняются связи:
Файл: /examples/src/test/java/org/jpwh/test/associations/
ManyToManyLinkEntity.java
Category someCategory = new Category("Some Category");
Category otherCategory = new Category("Other Category");
em.persist(someCategory);
em.persist(otherCategory);
Item someItem = new Item("Some Item");
Item otherItem = new Item("Other Item");
em.persist(someItem);
em.persist(otherItem);
CategorizedItem linkOne = new CategorizedItem(
"johndoe", someCategory, someItem
);
CategorizedItem linkTwo = new CategorizedItem(
"johndoe", someCategory, otherItem
);
CategorizedItem linkThree = new CategorizedItem(
"johndoe", otherCategory, someItem
);
em.persist(linkOne);
em.persist(linkTwo);
em.persist(linkThree);
Основное преимущество этой стратегии состоит в возможности двунаправлен-
ной навигации: вы можете получить все товары, относящиеся к данной категории,
вызвав someCategory.getCategorizedItems(), а затем осуществить навигацию в об-
ратном направлении с помощью someItem.getCategorizedItems(). Недостатком яв-
ляется более сложный код управления экземплярами сущностей CategorizedItem,
которые нужно создавать и удалять независимо. Также требуется определить
Тройные связи и связи многие ко многим  239
в классе CategorizedItem некоторую инфраструктуру, такую как составной иден-
тификатор. Небольшим улучшением могло бы стать применение параметра CascadeType.
PERSIST для некоторых ассоциаций, что снизило бы число вызовов метода
persist().
В предыдущем примере мы сохраняли пользователя, создавшего связь между
экземплярами Category и Item, в виде обычной строки с именем. Если вместо этого
создать в таблице соединения столбец внешнего ключа USER_ID, получится трой-
ное отношение. Класс CategorizedItem будет находиться в отношении @ManyToOne
с классами Category, Item и User.
В следующем разделе вы познакомитесь с еще одной стратегией отображения
многие ко многим. Чтобы сделать пример более интересным, создадим тройную
связь.
8.3.3. Тройные связи с компонентами
В предыдущем разделе мы представляли отношение многие ко многим с помощью
класса сущности, отображаемого на связывающую таблицу. Возможно, что более
простой альтернативой было бы отображение класса встраиваемого компонента:
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/ternary/
CategorizedItem.java
@Embeddable
public class CategorizedItem {
@ManyToOne
@JoinColumn(
name = "ITEM_ID",
nullable = false, updatable = false
)
protected Item item;
@ManyToOne
@JoinColumn(
name = "USER_ID",
updatable = false
)
@NotNull
protected User addedBy;
@Temporal(TemporalType.TIMESTAMP)
@Column(updatable = false)
@NotNull
protected Date addedOn = new Date();
protected CategorizedItem() {
}
public CategorizedItem(User addedBy,
Item item) {
Не формирует ограничения SQL
и, следовательно, не входит
в состав первичного ключа
240  Продвинутые приемы отображения связей между сущностями
this.addedBy = addedBy;
this.item = item;
}
// ...
}
ID << PK >>
...
<< Table >>
ITEM
ID << PK >>
...
<< Table >>
CATEGORY
CATEGORY_ID << PK >> << FK >>
ITEM_ID << PK >> << FK >>
USER_ID << FK >>
ADDEDON
<< Table >>
CATEGORY_ITEM
ID << PK >>
...
<< Table >>
USERS
Рис. 8.17  Связывающая таблица
с тремя столбцами внешних ключей
Здесь появилось новое отображение связи @ManyToOne во встраиваемом (@Embeddable)
классе, а также дополнительный столбец соединения с внешним клю-
чом USER_ID, создающий тройное отношение. Взгляните на схему базы данных на
рис. 8.17.
Владельцем коллекции встраиваемых компонентов является сущность Category:
Файл: /model/src/main/java/org/jpwh/model/associations/manytomany/ternary/
Category.java
@Entity
public class Category {
@ElementCollection
@CollectionTable(
name = "CATEGORY_ITEM",
joinColumns = @JoinColumn(name = "CATEGORY_ID")
)
protected Set<CategorizedItem> categorizedItems = new HashSet<>();
// ...
}
К сожалению, данное отображение несовершенно: при отображении коллекции
(@ElementCollection) встраиваемого типа все свойства целевого типа, имеющие
параметр nullable=false, становятся частью (составного) первичного ключа. Хо-
чется, чтобы все столбцы таблицы CATEGORY_ITEM имели ограничение NOT NULL. Но
в состав первичного ключа должны входить только столбцы CATEGORY_ID и ITEM_ID.
Тройные связи и связи многие ко многим  241
Для этого все свойства, не входящие в состав первичного ключа, следует отметить
аннотацией @NotNull из Bean Validation. В таком случае (поскольку это встраи-
ваемый класс) Hibernate проигнорирует аннотации Bean Validation для реализа-
ции первичного ключа и во время генерации SQL-схемы. Однако в этом случае
столбцы USER_ID и ADDEDON в сформированной схеме не получат соответствующих
ограничений NOT NULL, которые придется добавлять вручную.
Преимуществом этой стратегии является неявный жизненный цикл связан-
ных компонентов. Для создания связи между экземплярами Category и Item
нужно добавить в коллекцию новый экземпляр CategorizedItem. Для разруше-
ния связи достаточно удалить элемент из коллекции. Дополнительных настроек
каскадирования не требуется, а Java-код стал проще (хотя и занимает больше
строк):
Файл: /examples/src/test/java/org/jpwh/test/associations/
ManyToManyTernary.java
Category someCategory = new Category("Some Category");
Category otherCategory = new Category("Other Category");
em.persist(someCategory);
em.persist(otherCategory);
Item someItem = new Item("Some Item");
Item otherItem = new Item("Other Item");
em.persist(someItem);
em.persist(otherItem);
User someUser = new User("johndoe");
em.persist(someUser);
CategorizedItem linkOne = new CategorizedItem(
someUser, someItem
);
someCategory.getCategorizedItems().add(linkOne);
CategorizedItem linkTwo = new CategorizedItem(
someUser, otherItem
);
someCategory.getCategorizedItems().add(linkTwo);
CategorizedItem linkThree = new CategorizedItem(
someUser, someItem
);
otherCategory.getCategorizedItems().add(linkThree);
Двунаправленная навигация в этой ситуации невозможна: такой встраиваемый
компонент, как CategorizedItem, не поддерживает общих ссылок по определению.
Также невозможно осуществить переход от объекта Item к объекту CategorizedItem,
поэтому в классе Item нет отображения этой связи. Вместо этого можно написать
запрос для извлечения всех категорий данного товара (Item):
242  Продвинутые приемы отображения связей между сущностями
Файл: /examples/src/test/java/org/jpwh/test/associations/
ManyToManyTernary.java
Item item = em.find(Item.class, ITEM_ID);
List<Category> categoriesOfItem =
em.createQuery(
"select c from Category c " +
"join c.categorizedItems ci " +
"where ci.item = :itemParameter")
.setParameter("itemParameter", item)
.getResultList();
assertEquals(categoriesOfItem.size(), 2);
Вот мы и завершили ваше первое отображение тройной связи. В предыдущих
главах вы видели примеры работы ORM со словарями; ключи и значения всегда
имели простой или встраиваемый тип. В следующем разделе вы познакомитесь
с более сложными типами пар ключ/значение и их отображениями.
8.4. Связи между сущностями
с использованием словарей
Ключами и значениями словарей могут быть другие сущности, что дает другую
стратегию отображения связи многие ко многим и тройного отношения. Для на-
чала предположим, что ссылкой на сущность будет только значение в каждом эле-
менте словаря.
8.4.1. Связь один ко многим со свойством для ключа
Если значением каждого элемента словаря будет ссылка на другую сущность, по-
лучится отношение один ко многим между сущностями. Ключ словаря имеет простой
тип, например Long.
Примером такой структуры может служить сущность Item со словарем экзем-
пляров Bid, где каждый элемент является парой из идентификатора объекта Bid
и ссылки на него. Во время обхода коллекции someItem.getBids() фактически бу-
дут выполняться итерации по элементам словаря, имеющим вид (1, <ссылка на
объект Bid с первичным ключом 1>), (2, <ссылка на объект Bid с первичным ключом 2>)
и т. д.:
Файл: /examples/src/test/java/org/jpwh/test/associations/MapsMapKey.java
Item item = em.find(Item.class, ITEM_ID);
assertEquals(item.getBids().size(), 2);
for (Map.Entry<Long, Bid> entry : item.getBids().entrySet()) {
assertEquals(entry.getKey(),
entry.getValue().getId()); В роли ключа выступает идентификатор объекта Bid
}
Связи между сущностями с использованием словарей  243
Таблицы, реализующие данное отображение, не представляют ничего особен-
ного; у нас есть таблицы ITEM и BID, со столбцом внешнего ключа ITEM_ID в табли-
це BID. Это та же схема, что была показана на рис. 7.14 для отображения связи
один ко многим/многие к одному, использующая обычную коллекцию вместо сло-
варя (Map). Нашей целью является несколько иное представление данных в при-
ложении.
Добавим в класс Item поле bids типа Map:
Файл: /model/src/main/java/org/jpwh/model/associations/maps/mapkey/
Item.java
@Entity
public class Item {
@MapKey(name = "id")
@OneToMany(mappedBy = "item")
protected Map<Long, Bid> bids = new HashMap<>();
// ...
}
Здесь появилась новая аннотация @MapKey. Она отображает поле целевой сущ-
ности – в данном случае Bid – как ключ словаря. Если не использовать атрибута
name, по умолчанию будет выбрано имя свойства-идентификатора целевой сущ-
ности, поэтому в данном примере параметр name не нужен. Поскольку ключи сло-
варя образуют множество, можно ожидать, что значения конкретного словаря
будут уникальными. Это справедливо для первичных ключей экземпляров Bid,
но вряд ли для каких-нибудь других полей класса Bid. Только вы можете гаранти-
ровать уникальность значений выбранного свойства – Hibernate не будет делать
проверку.
В основном, и довольно редко, данный способ отображения применяется, когда
требуется реализовать обход элементов словаря, используя в качестве ключа ка-
кое-либо свойство сущности, которая является значением записи, поскольку так,
возможно, удобнее отображать данные. Чаще словари применяются в середине
тройной ассоциации.
8.4.2. Тройное отношение вида ключ/значение
Вам, должно быть, уже скучно, но мы обещаем, что это будет последний раз, когда
мы покажем еще один способ отображения связи между классами Category и Item.
Ранее в разделе 8.3.3 для представления связи мы использовали встраиваемый
компонент CategorizedItem. Здесь мы покажем, как представить отношение с по-
мощью словаря вместо дополнительного класса Java. Ключом каждого элемента
будет служить товар (Item), а связанным значением – пользователь (User), доба-
вивший товар (Item) в категорию (Category), как показано на рис. 8.18.
Таблица соединения/связи, как показано на рис. 8.19, имеет три столбца:
CATEGORY_ID, ITEM_ID и USER_ID. Коллекцией Map владеет сущность Category:
244  Продвинутые приемы отображения связей между сущностями
User
0..*
Category
Item
<<Map Key>>
Рис. 8.18  Коллекция Map со связями
в виде пар ключ/значение
ID << PK >>
...
<< Table >>
ITEM
ID << PK >>
...
<< Table >>
CATEGORY
CATEGORY_ID << PK >> << FK >>
ITEM_ID << PK >> << FK >>
USER_ID << FK >>
<< Table >>
CATEGORY_ITEM
ID << PK >>
...
<< Table >>
USERS
Рис. 8.19  Связывающая таблица
представляет пары ключ/значение коллекции Map
Файл: /model/src/main/java/org/jpwh/model/associations/maps/ternary/
Category.java
@Entity
public class Category {
@ManyToMany(cascade = CascadeType.PERSIST)
@MapKeyJoinColumn(name = "ITEM_ID") По умолчанию ITEMADDEDBY_KEY
@JoinTable(
name = "CATEGORY_ITEM",
joinColumns = @JoinColumn(name = "CATEGORY_ID"),
inverseJoinColumns = @JoinColumn(name = "USER_ID")
)
protected Map<Item, User> itemAddedBy = new HashMap<>();
// ...
}
Аннотацию @MapKeyJoinColumn можно опустить; по умолчанию Hibernate сгене-
рирует имя ITEMADDEDBY_KEY для столбца соединения/внешнего ключа, ссылающе-
гося на таблицу ITEM.
К моменту создания связи между всеми тремя сущностями каждая из них долж-
на храниться в базе данных:
Файл: /examples/src/test/java/org/jpwh/test/associations/MapsTernary.java
someCategory.getItemAddedBy().put(someItem, someUser);
someCategory.getItemAddedBy().put(otherItem, someUser);
otherCategory.getItemAddedBy().put(someItem, someUser);
Резюме  245
Для разрушения связи удалите элемент из словаря. Это удобный Java API для
управления сложными отношениями, скрывающий связывающую таблицу с тре-
мя столбцами в базе данных. Но помните, что на практике связывающие таблицы
часто обрастают дополнительными столбцами, и последующий рефакторинг кода
Java-приложения может оказаться затратным, если вы зависите от API коллекции
Map. Ранее у нас был столбец ADDEDON со значением времени создания связи, но для
этого отображения нам пришлось его убрать.
8.5. Резюме
 Вы узнали, как отображать сложные отношения между сущностями, исполь-
зуя связи один к одному, один ко многим, многие ко многим, тройные связи
и связи сущностей со словарями.
 Упрощайте отношения между классами, и вам редко понадобится использо-
вать большую часть показанных способов отображения. В частности, всегда
лучше представить связь многие ко многим в виде двух связей многие к одному
из промежуточного класса сущности либо как коллекцию компонентов.
 Прежде чем браться за сложное отображение, убедитесь, что коллекция дей-
ствительно необходима. Спросите себя, как часто потребуется выполнять ите-
рации по всем элементам.
 Структуры Java, показанные в этой главе, порой могут упростить доступ к дан-
ным, но, как правило, усложняют хранение, изменение и удаление.
Глава 9
Сложные
и унаследованные
схемы
В этой главе:
 улучшение схемы SQL с помощью дополнительных инструкций DDL;
 взаимодействие с унаследованной базой данных;
 отображение составных ключей.
В этой главе мы рассмотрим самую важную часть вашей системы – схему базы
данных, которая содержит набор правил целостности, – созданную вами модель
реального мира. Если в реальных условиях в вашем приложении можно выстав-
лять товар на торги только один раз, схема базы данных должна гарантировать это
условие. Если на аукционе всегда есть начальная цена, модель вашей базы данных
должна содержать соответствующее ограничение. Если данные соответствуют
всем правилам целостности, они называются согласованными – термин, который
вы еще встретите в разделе 11.1.
Мы также предполагаем, что согласованные данные корректны: все утвержде-
ния в базе данных, явные или неявные, являются истинными; все остальное лож-
но. Если вам хочется узнать больше о теории, стоящей за этим подходом, прочтите
о предположении о замкнутости мира1.
Главные нововведения в JPA 2
• Формирование схемы и выполнение произвольных сценариев SQL во время за-
грузки теперь стандартизировано и может быть настроено в рамках единицы
хранения.
• Можно отображать и настраивать элементы схемы, такие как имена индексов
и внешних ключей, используя стандартные аннотации.
1 http://wiki-org.ru/wiki/Предположение_о_замкнутости_мира. – Прим. ред.
Улучшаем схему базы данных  247
• Внешние ключи и связи многие к одному можно отображать с помощью состав-
ного первичного ключа в виде «производной сущности», используя аннотацию
@MapsId.
Иногда есть возможность начать проектирование сверху вниз. Нет ни схемы
базы данных, ни, скорее всего, самих данных – ваше приложение совсем новое.
Многие разработчики с удовольствием позволяют Hibernate автоматически сгене-
рировать сценарии для создания схемы базы данных. Также вы, скорее всего, по-
зволите Hibernate развернуть схему в тестовой базе данных на вашем компьютере
для разработки или в вашей системе непрерывного развертывания для выполне-
ния интеграционных тестов. Позже администратор базы данных возьмет сгене-
рированные сценарии и создаст окончательную и улучшенную схему для развер-
тывания программы в рабочей среде. В первой части этой главы вы увидите, как
улучшить схему, используя JPA и Hibernate, чтобы сделать вашего администратора
базы данных счастливым.
На другом конце спектра находятся системы с уже существующими и, вероятно,
сложными схемами и данными, которые копились годами. Ваше новое приложе-
ние станет лишь маленьким винтиком в огромном механизме, и ваш администра-
тор базы данных не позволит внести никаких (даже самых безобидных) измене-
ний в базу данных. Вам понадобится гибкое объектно-реляционное отображение,
чтобы не пришлось потом вносить слишком много изменений в классы Java, если
не все будет получаться сразу. Это станет темой второй половины данной главы
наряду с обсуждением составных первичных и внешних ключей.
Мы начнем с совершенно новой реализации и рассмотрим схемы, сгенериро-
ванные Hibernate.
9.1. Улучшаем схему базы данных
Hibernate читает классы предметной модели и метаданные отображения и генери-
рует инструкции DDL, формирующие схему базы данных. Их можно экспортиро-
вать в текстовый файл или выполнять непосредственно в базе данных каждый раз,
когда проводится интеграционное тестирование. Поскольку язык описания схемы
в значительной степени зависит от используемой базы данных, каждый параметр
в метаданных отображения может привязать вас к определенной системе; помните
об этом при определении схемы.
Hibernate автоматически создает основную схему для таблиц и ограничений;
он даже определяет последовательности в зависимости от выбранного генератора
идентификаторов. Но некоторые элементы схемы Hibernate не может и не будет
создавать автоматически. К ним относятся настройки производительности, харак-
терные для конкретной базы данных, и прочие параметры, относящиеся к физиче-
скому хранению данных (например, пространства таблиц). Помимо физических
аспектов, ваш администратор базы данных обычно предоставляет дополнитель-
ные инструкции для улучшения схемы. Администраторы баз данных должны
248  Сложные и унаследованные схемы
включаться в процесс разработки как можно раньше для проверки схем, автомати-
чески сгенерированных Hibernate. Никогда не запускайте приложение в рабочей
среде, не проверив автоматически сгенерированную схему.
Изменения, сделанные администратором базы данных, могут передаваться об-
ратно в систему Java для добавления в метаданные отображения, если это позво-
ляет процесс разработки. Во многих проектах метаданные могут содержать все не-
обходимые изменения, полученные от администратора, и на их основе Hibernate
сможет сгенерировать окончательную рабочую схему в рамках обычной сборки,
включая все комментарии, ограничения, индексы и т. д.
В следующих разделах мы покажем, как настроить сгенерированную схему
и как добавить вспомогательные артефакты схемы базы данных (иногда мы на-
зываем их объектами; здесь мы не имеем в виду объектов Java). Мы обсудим поль-
зовательские типы данных, дополнительные правила целостности, индексы и то,
как изменить имена некоторых артефактов (иногда довольно страшные), автома-
тически сгенерированные Hibernate.
Экспорт сценария создания схемы в файл
Hibernate связывает класс org.hibernate.tool.hbm2ddl.SchemaExport с методом main(),
который можно вызвать из командной строки. Эта утилита может обращаться к ва-
шей СУБД напрямую, чтобы создать схему, или записывать текстовый файл со сце-
нарием DDL для дальнейшей доработки администратором базы данных.
Сначала рассмотрим, как внедрить произвольные SQL-выражения в процесс ав-
томатической генерации схемы фреймворком Hibernate.
9.1.1. Добавление вспомогательных объектов базы данных
В процесс генерации схемы можно внедрить три типа SQL-сценариев:
 сценарий создания выполняется во время генерации схемы. Такой сценарий
может быть выполнен до, после или вместо сценария, автоматически сге-
нерированного фреймворком Hibernate. Другими словами, можно написать
сценарий SQL, который будет выполняться до или после того, как Hibernate
сгенерирует таблицы, ограничения и пр. из метаданных отображения;
 сценарий удаления выполняется, когда Hibernate удаляет элементы схе-
мы. Подобно сценарию создания, сценарий удаления может выполняться
до, после или вместо инструкций, автоматически сгенерированных Hibernate;
 сценарий загрузки всегда выполняется на заключительном этапе созда-
ния, после того как Hibernate сгенерирует схему. Его главная цель – им-
портировать тестовые или основные данные перед запуском приложения
или модульных тестов. Он может содержать любые типы инструкций SQL,
включая такие DDL-выражения, как ALTER, если требуется дальнейшая мо-
дификация схемы.
Улучшаем схему базы данных  249
Подобная модификация процесса генерации схемы на самом деле стандарти-
зована; она настраивается спомощью параметров JPA в файле настроек единицы
хранения persistence.xml.
Листинг 9.1  Настройки генерации схемы в файле persistence.xml
Файл: /model/src/main/resources/META-INF/persistence.xml
<property name="hibernate.0hbm2ddl.import_files_sql_extractor"
value="org.hibernate.tool.hbm2ddl.
➥MultipleLinesSqlCommandExtractor"/>
<property name="javax.persistence.schema-generation.create-source"
value="script-then-metadata"/>  Определяет, когда должны выполняться сценарии
<property name="javax.persistence.schema-generation.drop-source"
value="metadata-then-script"/>
<property name="javax.persistence.schema-generation.create-script-source"
value="complexschemas/CreateScript.sql.txt"/>
<property name="javax.persistence.schema-generation.drop-script-source"
value="complexschemas/DropScript.sql.txt"/>
<property name="javax.persistence.sql-load-script-source"
value="complexschemas/LoadScript.sql.txt"/>  Сценарий загрузки
 По умолчанию Hibernate предполагает, что каждая строка сценария содержит отдель-
ное выражение SQL. Эта настройка позволяет воспользоваться более удобным много-
строчным экстрактором. В сценариях выражения SQL завершаются точкой с запятой.
Вы можете создать собственную реализацию org.hibernate.tool.hbm2ddl.ImportSql-
CommandExtractor, если хотите обрабатывать сценарии SQL иным способом.
 Эта настройка определяет, когда выполняются сценарии создания и удаления. Ваши
сценарии SQL будут содержать инструкции создания доменов CREATE DOMAIN, которые
должны выполниться перед созданием таблиц, использующих эти домены. С такими
настройками генератор схемы выполнит сценарий создания, прежде чем начнет чтение
метаданных ORM (аннотаций, файлов XML) и создание таблиц. Сценарий удаления
выполнится после того, как Hibernate удалит таблицы, предоставляя вам возможность
удалить все, что было создано вами. Другими вариантами являются metadata (игнори-
ровать ваши сценарии) и script (использовать только ваши сценарии и игнорировать
метаданные ORM в аннотациях и файлах XML).
 Местоположение сценария SQL для создания схемы. Путь – это (а) местоположение
сценария в пути поиска классов; (б) местоположение сценария в виде указателя ресурса
URL со схемой file:// и (в) абсолютный или относительный путь в локальной файловой
системе. В данном примере используется вариант «а».
 Сценарий SQL для удаления схемы.
 Сценарий загрузки, который выполнится после создания всех таблиц.
Мы уже говорили, что инструкции DDL обычно сильно зависят от конкретной
базы данных. Если приложение должно работать с несколькими разновидностями
баз данных, вам может понадобиться несколько наборов со сценариями создания,
удаления и загрузки для настройки схемы под каждую конкретную разновидность
 Активирует механизм
многострочного извлечения
 Произвольный
сценарий SQL
для создания
схемы
 Произвольный сценарий SQL
для удаления схемы
250  Сложные и унаследованные схемы
базы данных. Эту проблему можно решить, используя несколько определений
единиц хранения в файле persistence.xml.
Также можно использовать собственные настройки Hibernate для модифика-
ции схемы в файле отображения hbm.xml.
Листинг 9.2  Генерация схемы с применением нестандартной конфигурации
Hibernate
<hibernate-mapping xmlns="http://www.hibernate.org/xsd/orm/hbm">
<database-object>
<create>
CREATE ...
</create>
<drop>
DROP ...
</drop>
<dialect-scope name="org.hibernate.dialect.H2Dialect"/>
<dialect-scope name="org.hibernate.dialect.PostgreSQL82Dialect"/>
</database-object>
</hibernate-mapping>
Особенности Hibernate
Поместите свои инструкции SQL внутрь элементов <create> и <drop>. А Hibernate
выполнит их после создания схемы для классов предметной модели, т. е. после
создания таблиц и до удаления автоматически сгенерированной части схемы. Это
поведение фиксировано, поэтому стандартные настройки генерации схемы JPA
часто
оказываются более гибкими.
Элемент <dialect-scope> ограничивает инструкции SQL определенным набо-
ром настроенных диалектов баз данных. Когда элемент <dialect-scope> отсутству-
ет, выражения SQL выполняются всегда.
Фреймворк Hibernate также поддерживает сценарии загрузки: обнаружив файл
с именем import.sql в корне каталога классов, он выполнит его по завершении соз-
дания схемы. Если у вас есть несколько файлов для импорта, укажите их имена
в виде списка, разделенного запятыми, в параметре hibernate.hbm2ddl.import_files,
в конфигурации единицы хранения.
Наконец, если потребуется программно управлять сгенерированной схемой,
реализуйте
интерфейс org.hibernate.mapping.AuxiliaryDatabaseObject. В Hibernate
уже есть готовая реализация для удобства наследования, поэтому можно соз-
дать свой подкласс, выборочно переопределив необходимые методы.
Листинг 9.3  Программное управление сгенерированной схемой
package org.jpwh.model.complexschemas;
import org.hibernate.dialect.Dialect;
import org.hibernate.boot.model.relational.AbstractAuxiliaryDatabaseObject;
public class CustomSchema
Улучшаем схему базы данных  251
extends AbstractAuxiliaryDatabaseObject {
public CustomSchema() {
addDialectScope("org.hibernate.dialect.Oracle9Dialect");
}
@Override
public String[] sqlCreateStrings(Dialect dialect) {
return new String[]{"[CREATE statement]"};
}
@Override
public String[] sqlDropStrings(Dialect dialect) {
return new String[]{"[DROP statement]"};
}
}
С помощью методов sqlCreateString() и sqlDropString() можно программно
добавлять используемые диалекты и даже получать доступ к некоторым данным
отображения. Этот класс следует объявить в файле hbm.xml:
<hibernate-mapping xmlns="http://www.hibernate.org/xsd/orm/hbm">
<database-object>
<definition class="org.jpwh.model.complexschemas.CustomSchema"/>
<dialect-scope name="org.hibernate.dialect.H2Dialect"/>
<dialect-scope name="org.hibernate.dialect.PostgreSQL82Dialect"/>
</database-object>
</hibernate-mapping>
Дополнительные диалекты суммируются; предыдущий пример добавляет три
диалекта.
Давайте напишем собственные сценарии создания, удаления и загрузки и реа-
лизуем дополнительные правила целостности, которые порекомендовал бы каж-
дый хороший администратор баз данных. Но сначала немного справочной инфор-
мации о правилах целостности и ограничениях SQL.
9.1.2. Ограничения SQL
Системы, проверяющие целостность данных лишь в коде приложения, могут при-
водить к повреждению данных и со временем снижают качество работы базы дан-
ных. Если хранилище данных не гарантирует выполнения правил, простейшая
незамеченная ошибка в приложении сможет вызвать такие проблемы, которые
нельзя будет исправить, например потерю или повреждение данных.
Вместо проверки целостности данных в коде процедурного (или объектно-ори-
ентированного) приложения СУБД позволяют декларативно реализовать пра-
вила целостности в схеме базы данных. Преимущества декларативных правил
заключаются в потенциальном уменьшении ошибок в коде и возможности для
СУБД оптимизировать доступ к данным.
252  Сложные и унаследованные схемы
В базах данных SQL мы различаем четыре типа правил:
 ограничения домена (domain constraints). Домен – это (грубо говоря, и толь-
ко в области баз данных) тип данных в базе. Следовательно, ограничение
домена определяет диапазон возможных значений конкретного типа дан-
ных. Например, тип данных INTEGER подходит для целочисленных значе-
ний. Тип данных CHAR может хранить строки символов: к примеру, всех сим-
волов, определенных в кодировке ASCII или какой-то другой. Используя
в основном встроенные типы данных СУБД, мы полагаемся на ограниче-
ния домена, определенные разработчиком СУБД. Если ваша база данных
обладает необходимой функциональностью, вы могли бы воспользоваться
(очень ограниченной) поддержкой пользовательских доменов, чтобы до-
бавить дополнительные ограничения к существующим типам данных или
создать собственные типы данных;
 ограничения столбца (column constraints). Ограничение области допусти-
мых значений столбца определенным доменом и типом формирует ограни-
чение столбца. Например, в схеме можно объявить столбец EMAIL, содержа-
щий значения типа VARCHAR. С другой стороны, можно создать новый домен
EMAIL_ADDRESS с собственными ограничениями и применить его для столбца
вместо типа VARCHAR. Специальным ограничением столбца в базе данных
SQL является NOT NULL;
 табличные ограничения (table constraints). Правило целостности, приме-
няемое к нескольким столбцам или нескольким строкам, является таблич-
ным ограничением. Типичным декларативным табличным ограничением
является UNIQUE: каждая строка проверяется на наличие повторяющихся
значений (например, все пользователи должны иметь различные электрон-
ные адреса). Примером может служить правило, влияющее лишь на одну
запись, но на несколько столбцов, которое гласит: «Время окончания аук-
циона должно быть позже времени его начала»;
 ограничение базы данных (database constraints). Если правило применяет-
ся более чем к одной таблице, оно действует на уровне всей базы данных.
Вы наверняка уже знакомы с самым распространенным ограничением базы
данных – внешним ключом. Это правило гарантирует ссылочную целост-
ность между записями, как правило, но не всегда, расположенными в раз-
ных таблицах (рекурсивные ограничения внешнего ключа встречаются не
так уж редко). Также нередко встречаются другие ограничения базы дан-
ных, включающие несколько таблиц. Например, ставка за товар может со-
храняться, только если еще не наступило время окончания аукциона для
данного товара.
Большинство (если не все) СУБД SQL поддерживает данные виды ограниче-
ний, а также наиболее важные их разновидности. В дополнение к таким ключевым
словам, как NOT NULL и UNIQUE, обычно можно объявлять более сложные правила,
используя ограничение CHECK с произвольным выражением SQL. Но ограничения
целостности по-прежнему являются слабым местом стандарта SQL, и решения,
предлагаемые разработчиками СУБД, могут значительно отличаться.
Улучшаем схему базы данных  253
Кроме того, с помощью триггеров в базе данных, перехватывающих операции
изменения данных, можно создавать недекларативные и процедурные ограниче-
ния. Триггер может реализовывать процедуру проверки ограничения непосред-
ственно или вызывать существующую хранимую процедуру.
Ограничения целостности могут проверяться сразу же, во время выполнения
инструкций, изменяющих данные, или откладываться до окончания транзакции.
Обычно на нарушение правил базы данных SQL отвечают отказом, без возмож-
ности изменения такого поведения. Внешние ключи занимают особое место, по-
скольку вы, как правило, можете определить, что должно происходить с зависи-
мыми строками при удалении (ON DELETE) или изменении (ON UPDATE).
Hibernate представляет нарушение ограничения базы данных в виде объекта
исключения; проверьте, не имеется ли в цепочке исключений объекта типа org.hibernate.
exception.ConstraintViolationException. Это исключение может сообщить
больше информации об ошибке, например имя нарушенного ограничения базы
данных.
Вывод сообщений об ошибках валидации
Это слишком хорошо, чтобы быть правдой: если уровень взаимодействия с базой
данных возбудит исключение типа ConstraintViolationException, то почему бы не по-
казать его пользователю? Пользователь сможет затем менять неправильное имя
на своем экране и отправлять форму заново до тех пор, пока не пройдет валида-
цию. К сожалению, это так не работает. Многие, кто пытался реализовать эту стра-
тегию, терпели поражение.
Во-первых, каждая СУБД определяет свои сообщения об ошибках, и Hibernate
не гарантирует корректного их анализа. Информация, предоставляемая объек-
том ConstraintViolationException, – это всего лишь лучшая из догадок; обычно она
неверна и подходит лишь для создателей сообщений, записываемых в журнал.
Должно ли это быть стандартизировано в SQL? Безусловно; но этого не проис-
ходит.
Во-вторых, приложение не должно передавать базе данных некорректную инфор-
мацию, проверяя, что подойдет, а что нет. СУБД – это последний рубеж обороны,
а не первая линия валидации. Вместо этого используйте на уровне приложения
Java механизм Bean Validation и возвращайте своим пользователям понятные со-
общения об ошибках на их родном языке.
Давайте поближе рассмотрим реализацию ограничений целостности.
Добавление ограничений доменов и столбцов
Стандарт SQL определяет домены, которые, к сожалению, достаточно ограниче-
ны и не всегда поддерживаются СУБД. Если ваша система поддерживает домены
SQL, можете воспользоваться ими для ограничнения типов данных.
Определим в SQL-сценарии создания домен EMAIL_ADDRESS на основе типа
VARCHAR:
254  Сложные и унаследованные схемы
Файл: /model/src/main/resources/complexschemas/CreateScript.sql.txt
create domain if not exists
EMAIL_ADDRESS as varchar
check (position(‘@’, value) > 1);
Дополнительным ограничением является проверка наличия символа @ в стро-
ке. Преимущество (относительно небольшое) такого домена в том, что общие огра-
ничения находятся в одном месте. Ограничения домена всегда проверяются сразу
же во время вставки и изменения данных.
Теперь вы можете применять этот домен в своих отображениях, как встроенный
тип данных:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/
User.java
@Entity
public class User {
@Column(
nullable = false, Ограничение столбца
unique = true, Табличное ограничение для нескольких строк
columnDefinition = "EMAIL_ADDRESS(255)" Применение ограничения домена
)
protected String email;
// ...
}
В этом отображении задействовано несколько ограничений. Ограничение NOT
NULL применяется повсеместно; вы уже многократно с ним встречались. Вторым
следует ограничение столбца UNIQUE; никакие два пользователя не могут иметь
одинаковых электронных адресов. На момент написания книги в Hibernate нель-
зя было поменять имя ограничения уникальности для одного столбца; в схеме
оно получало нечитаемое, автоматически сгенерированное имя. Последним идет
параметр columnDefinition, ссылающийся на домен, добавленный выше в сценарии
создания. Данное определение является фрагментом SQL, который экспортиру-
ется в схему напрямую, поэтому будьте внимательны с кодом SQL, зависящим от
конкретной базы данных.
Если нет желания определять домены заранее, используйте в качестве ограни-
чения для одного столбца ключевое слово CHECK:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/
User.java
@Entity
public class User {
@Column(columnDefinition =
"varchar(15) not null unique" +
" check (not substring(lower(USERNAME), 0, 5) = ‘admin’)"
)
Улучшаем схему базы данных  255
protected String username; Аннотация @org.hibernate.annotations.Check
// ...
пока не поддерживается для свойств классов
}
Данное определение ограничивает длину корректного имени пользователя
15 символами; также, во избежание путаницы, строка не может начинаться со
слова admin. Можно вызывать любую функцию SQL, поддерживаемую базой
данных; значение параметра columnDefinition всегда помещается в экспортируе-
мую схему.
Обратите внимание, что вам предоставлен выбор: создание и применение до-
мена окажут такой же эффект, как добавление ограничения для одного столбца.
Как правило, домены легче поддерживать, и они помогают избежать дублирова-
ния кода.
На момент написания этих строк Hibernate не поддерживал аннотацию @org.
hibernate.annotations.Check для отдельных свойств класса; используйте ее для
табличных
ограничений.
Особенности Hibernate
Ограничения уровня таблицы
Аукцион не может завершиться до своего начала. До сих пор ни в схеме SQL, ни
в предметной модели не было правила, реализующего данное ограничение. Нам
понадобится табличное ограничение для одной строки:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/
Item.java
@Entity
@org.hibernate.annotations.Check(
constraints = "AUCTIONSTART < AUCTIONEND"
)
public class Item {
@NotNull
protected Date auctionStart;
@NotNull
protected Date auctionEnd;
// ...
}
Hibernate добавляет табличные ограничения, которые могут содержать произ-
вольные выражения SQL, в сформированную инструкцию CREATE TABLE.
С помощью более сложных выражений можно реализовать многострочные табличные
ограничения. Для этой цели могут понадобиться подзапросы, которые
могут не поддерживаться вашей СУБД. Однако существуют распространенные
многострочные табличные ограничения, такие как UNIQUE, которые можно ис-
256  Сложные и унаследованные схемы
пользовать прямо в отображениях. Вы уже видели аннотацию @Column(unique =
true|false) в предыдущем разделе.
Если ограничение уникальности распространяется на несколько столбцов, ис-
пользуйте параметр uniqueConstraints аннотации @Table:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/
User.java
@Entity
@Table(
name = "USERS",
uniqueConstraints =
@UniqueConstraint(
name = "UNQ_USERNAME_EMAIL",
columnNames = { "USERNAME", "EMAIL" }
)
)
public class User {
// ...
}
Теперь каждая пара значений USERNAME и EMAIL должна быть уникальной для всех
записей в таблице USERS. Если не указать имя ограничения – как в данном случае
UNQ_USERNAME_EMAIL, оно будет сгенерировано автоматически и, возможно, будет не
таким удобочитаемым.
Последний вид ограничений, который мы рассмотрим, – ограничения базы дан-
ных, распространяющиеся на несколько таблиц.
Ограничения уровня базы данных
Пользователи могут делать ставки, пока аукцион не завершится. База данных
должна гарантировать сохранение только корректных ставок, чтобы при каждой
вставке строки в таблицу BID метка времени CREATEDON (когда ставка была создана)
сверялась со временем окончания аукциона. Данный тип ограничения затрагивает
две таблицы: BID и ITEM.
В любом SQL-выражении CHECK можно создать правило, распространяющееся
на несколько таблиц, используя соединение с подзапросом. Вместо того чтобы
ссылаться только на одну таблицу, в которой объявлено ограничение, можно на-
писать запрос (как правило, проверяющий наличие/отсутствие тех или иных дан-
ных) к другой таблице. Но проблема в том, что вы не можете использовать анно-
тацию @org.hibernate.annotations.Check ни в классе Bid, ни в классе Item. Потому
что неизвестно, какую таблицу Hibernate создаст первой.
Поэтому ограничение CHECK следует поместить в выражение ALTER TABLE, выпол-
няемое после создания всех таблиц. Для этого хорошо подходит сценарий загруз-
ки, поскольку он выполняется как раз в этот момент:
Улучшаем схему базы данных  257
Файл: /model/src/main/resources/complexschemas/LoadScript.sql.txt
alter table BID
add constraint AUCTION_BID_TIME
check(
CREATEDON <= (
select i.AUCTIONEND from ITEM i where i.ID = ITEM_ID
)
);
Запись в таблице BID теперь будет считаться корректной, только если значение
CREATEDON в ней будет меньше или равно значению времени окончания аукциона
в соответствующей записи таблицы ITEM.
Большинство встречавшихся нам до сих пор правил, распространяющихся на
несколько таблиц, было правилами ссылочной целостности. Они широко извест-
ны как внешние ключи, представляющие собой комбинацию двух элементов: ко-
пии ключа связанной строки и ограничения, гарантирующего существование свя-
занного значения. Hibernate автоматически создаст ограничение внешнего ключа
для каждого столбца внешнего ключа в отображении связи. Если посмотреть на
схему, сформированную Hibernate, вы заметите, что для этих ограничений авто-
матически созданы идентификаторы в базе данных, которые не очень легко чита-
ются, что может затруднять отладку. В сгенерированной схеме можно, например,
увидеть выражения такого вида:
alter table BID add constraint FKCFAEEDB471BF59FF
foreign key (ITEM_ID) references ITEM
Это выражение определяет ограничение внешнего ключа для столбца ITEM_ID
в таблице BID, ссылающегося на столбец первичного ключа в таблице ITEM. Вы мо-
жете поменять имя ограничения с помощью параметра foreignKey отображения
@JoinColumn:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/Bid.java
@Entity
public class Bid {
@ManyToOne
@JoinColumn(
name = "ITEM_ID",
nullable = false,
foreignKey = @ForeignKey(name = "FK_ITEM_ID")
)
protected Item item;
// ...
}
Атрибут foreignKey также поддерживается отображениями @PrimaryKeyJoinColumn,
@MapKeyJoinColumn, @JoinTable, @CollectionTable и @AssociationOverride.
258  Сложные и унаследованные схемы
Аннотация @ForeignKey имеет несколько редко используемых параметров, не
показанных ранее:
 вы можете задать собственное определение внешнего ключа, присвоив
параметру foreignKeyDefinition фрагмент SQL-кода в формате FOREIGN KEY
([column]) REFERENCES [table]([column]) ON UPDATE [action]. Hibernate будет
использовать этот фрагмент вместо того, который сформирует реализация
механизма хранения; данный фрагмент может быть написан на диалекте
SQL, поддерживаемом вашей СУБД;
 параметр ConstraintMode со значением NO_CONSTRAINT подойдет в случаях,
когда требуется полностью отказаться от создания внешнего ключа. Вы мо-
жете написать ограничение внешнего ключа самостоятельно, используя вы-
ражение ALTER TABLE, например поместив его в сценарий загрузки, как было
показано ранее.
Правильное именование ограничений не только является хорошим тоном, но
также может помочь при анализе сообщений об исключениях.
На этом мы завершаем обсуждение правил целостности в базе данных. Далее
мы рассмотрим некоторые оптимизации, которые вам, возможно, захочется до-
бавить в свою схему для улучшения производительности.
9.1.3. Создание индексов
Индексы – это ключевой аспект оптимизации производительности приложения,
работающего с базой данных. Оптимизатор запросов в СУБД может воспользо-
ваться индексом, чтобы избежать избыточного сканирования таблиц данных.
Поскольку индексы относятся к физической реализации базы данных, они не
являются частью стандарта SQL, а синтаксис DDL и доступные варианты индек-
сирования зависят от конкретного продукта. Тем не менее вы можете поместить
в метаданные отображения наиболее общие артефакты схемы для типичных ин-
дексов.
Многие запросы в приложении CaveatEmptor почти наверняка будут обращать-
ся к свойству username сущности User. Вы можете ускорить эти запросы, проиндек-
сировав соответствующий столбец. Другим кандидатом на индексацию является
комбинация столбцов USERNAME и EMAIL, которые также могут часто использоваться
в запросах. Объявить индексы для одного или нескольких столбцов можно в атри-
буте indexes аннотации @Table перед классом сущности.
Файл: /model/src/main/java/org/jpwh/model/complexschemas/custom/
User.java
@Entity
@Table(
name = "USERS",
indexes = {
@Index(
name = "IDX_USERNAME",
columnList = "USERNAME"
),
Унаследованные первичные ключи  259
@Index(
name = "IDX_USERNAME_EMAIL",
columnList = "USERNAME, EMAIL"
)
}
)
public class User {
// ...
}
Если имя индекса не указано, будет использоваться сгенерированное имя.
Мы не советуем добавлять индекс, если вам только кажется, будто он сможет
решить проблему производительности. Прочтите отличную книгу SQL Tuning Дэна
Тоу (Tow, 2003), где вы познакомитесь с эффективными приемами оптимизации
и особенно с тем, как индексы помогают приблизиться к самому производитель-
ному плану выполнения запросов.
Настройка схемы базы данных обычно возможна, только если вы работаете
с новой системой, не содержащей данных. При работе с существующей унаследо-
ванной схемой часто возникает проблема взаимодействия с естественными и со-
ставными ключами.
9.2. Унаследованные первичные ключи
В разделе 4.2.3 мы упоминали, что считаем использование естественных первич-
ных ключей плохой идеей. Естественные ключи затрудняют внесение изменений
в модель данных при изменении бизнес-требований. Иногда они могут даже сни-
жать производительность. К сожалению, во многих унаследованных схемах ин-
тенсивно используются (естественные) составные ключи; и как раз по причине,
по которой мы не поддерживаем их применения, вам может оказаться трудно по-
менять старую схему, чтобы использовать естественные несоставные или сурро-
гатные ключи. По этой причине JPA поддерживает естественные ключи, а также
составные первичные и внешние ключи.
9.2.1. Отображение естественных первичных ключей
Если в унаследованной схеме вы встретите таблицу USERS, вероятнее всего, ее пер-
вичным ключом будет столбец USERNAME. В таком случае у вас не будет суррогат-
ного идентификатора, который Hibernate мог бы сгенерировать автоматически.
Вместо этого само приложение должно присваивать значение идентификатора
при сохранении экземпляра класса User:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
NaturalPrimaryKey.java
User user = new User("johndoe");
em.persist(user);
260  Сложные и унаследованные схемы
Здесь единственным аргументом общедоступного конструктора класса User яв-
ляется имя пользователя:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/
naturalprimarykey/ User.java
@Entity
@Table(name = "USERS")
public class User {
@Id
protected String username;
protected User() {
}
public User(String username) {
this.username = username;
}
// ...
}
При загрузке экземпляра User из базы данных Hibernate вызовет защищенный
конструктор без аргументов, а затем напрямую присвоит значение полю username.
Создавая экземпляр класса User, вызовите общедоступный конструктор с аргу-
ментом username. Если вы не объявили генератор идентификаторов перед свой-
ством с аннотацией @Id, Hibernate будет полагать, что приложение само позабо-
тится о присваивании первичного ключа.
Составные (естественные) первичные ключи требуют больших затрат.
9.2.2. Отображение составных первичных ключей
Предположим, что первичный ключ таблицы USERS включает два столбца: USERNAME
и DEPARTMENTNR. Тогда нужно написать отдельный класс составного идентификато-
ра, объявляющего только ключевые поля, и назвать его UserId:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
embedded/UserId.java
@Embeddable  Встраиваемый (@Embeddable) и сериализуемый (Serializable) класс
public class UserId implements Serializable {
protected String username;  Автоматически генерируется ограничение NOT NULL
protected String departmentNr;
protected UserId() {  Защищенный конструктор
}
public UserId(String username, String departmentNr) {  Общедоступный конструктор
this.username = username;
this.departmentNr = departmentNr;
}
Унаследованные первичные ключи  261
@Override  Переопределение equals() и hashCode()
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
UserId userId = (UserId) o;
if (!departmentNr.equals(userId.departmentNr)) return false;
if (!username.equals(userId.username)) return false;
return true;
}
@Override  Переопределение equals() и hashCode()
public int hashCode() {
int result = username.hashCode();
result = 31 * result + departmentNr.hashCode();
return result;
}
// ...
}
 Этот класс должен быть встраиваемым (@Embeddable) и сериализуемым (Serializable)
– любой тип, используемый в JPA как идентификатор, должен быть сериализуе-
мым (Serializable).
 Не нужно отмечать свойства составного ключа аннотациями @NotNull; соответствую-
щие им столбцы в базе данных автоматически получат ограничение NOT NULL, поскольку
будут входить в состав первичного ключа сущности.
 Спецификация JPA требует наличия общедоступного конструктора без аргументов
у встраиваемого класса идентификатора. Hibernate допускает защищенную область ви-
димости.
 Единственный общедоступный конструктор должен получать значения ключа в виде
аргументов.
 Вы должны переопределить методы equals() и hashCode(), сохраняя ту же семантику
составного ключа, что и в базе данных. В данном случае это простое сравнение значений
username и departmentNr.
Все это – важные части класса UserId. Возможно, вы добавите несколько мето-
дов чтения для получения значений свойств.
Теперь осталось отобразить сущность User, используя этот тип идентификатора
и аннотацию @EmbeddedId:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
embedded/User.java
@Entity
@Table(name = "USERS")
public class User {
@EmbeddedId
protected UserId id; Можно добавить аннотацию @AttributeOverrides
public User(UserId id) {
262  Сложные и унаследованные схемы
this.id = id;
}
// ...
}
Так же, как для обычных встроенных компонентов, можно переопределять
отдельные атрибуты и отображаемые ими столбцы, как было показано в разде-
ле 5.2.3. Схема базы данных показана на рис. 9.1.
Любой общедоступный конструктор класса User должен требовать передачи эк-
земпляра UserId, вынуждая определять значение перед сохранением объекта User
(также в классе сущности должен быть определен конструктор без аргументов):
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyEmbeddedId.java
UserId id = new UserId("johndoe", "123");
User user = new User(id);
em.persist(user);
Вот так вы можете загрузить экземпляр класса User:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyEmbeddedId.java
UserId id = new UserId("johndoe", "123");
User user = em.find(User.class, id);
assertEquals(user.getId().getDepartmentNr(), "123");
USERNAME << PK >>
DEPARTMENTNR << PK >>
...
<< Table >>
USERS
Рис. 9.1  В таблице USERS
определен составной первичный ключ
Далее предположим, что столбец DEPARTMENTNR – это внешний ключ, ссылаю-
щийся на таблицу DEPARTMENT, и требуется представить эту связь в предметной мо-
дели на Java в виде связи многие к одному.
9.2.3. Внешние ключи внутри составных первичных ключей
Взгляните на схему на рис. 9.2.
USERNAME << PK >>
DEPARTMENTID << PK >> << FK >>
...
<< Table >>
USERS
ID << PK >>
NAME
...
<< Table >>
DEPARTMENT
Рис. 9.2  Часть составного первичного ключа в таблице USERS
также является внешним ключом
Унаследованные первичные ключи  263
Сначала попробуем реализовать отображение с помощью аннотации @MapsId,
разработанной специально для этой цели. Начнем с переименования поля departmentNr
в departmentId во встроенном классе идентификатора UserId, показанного
в предыдущем разделе:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
mapsid/UserId.java
@Embeddable
public class UserId implements Serializable {
protected String username;
protected Long departmentId;
// ...
}
Теперь свойство имеет тип Long, а не String. Далее в классе сущности User объ-
явим связь с помощью отображения @ManyToOne перед полем department:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
mapsid/User.java
@Entity
@Table(name = "USERS")
public class User {
@EmbeddedId
protected UserId id;
@ManyToOne
@MapsId("departmentId")
protected Department department;
public User(UserId id) {
this.id = id;
}
// ...
}
Аннотация @MapsId сообщает фреймворку Hibernate, что при сохранении экзем-
пляра User значение свойства UserId#departmentId должно игнорироваться. Вместо
этого при сохранении записи в таблицу USERS Hibernate возьмет идентификатор
объекта Department из свойства User#department:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyMapsId.java
Department department = new Department("Sales");
em.persist(department);
UserId id = new UserId("johndoe", null); Null?
User user = new User(id);
264  Сложные и унаследованные схемы
user.setDepartment(department); Обязательно
em.persist(user);
При сохранении Hibernate игнорирует любое значение, присвоенное UserId#
departmentId; даже null, присвоенное в данном примере. Это означает, что перед
сохранением объекта User у вас уже должен иметься экземпляр Department. В JPA
это называется косвенным отображением идентификатора.
При загрузке объекта User необходим только идентификатор объекта Department:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyMapsId.java
UserId id = new UserId("johndoe", DEPARTMENT_ID);
User user = em.find(User.class, id);
assertEquals(user.getDepartment().getName(), "Sales");
Нам не очень нравится эта стратегия отображения. Вот способ получше, не тре-
бующий аннотации @MapsId:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
readonly/User.java
@Entity
@Table(name = "USERS")
public class User {
@EmbeddedId
protected UserId id;
@ManyToOne
@JoinColumn(
name = "DEPARTMENTID", По умолчанию DEPARTMENT_ID
insertable = false, updatable = false Доступ только для чтения
)
protected Department department;
public User(UserId id) {
this.id = id;
}
// ...
}
С помощью обычных параметров insertable=false и updatable=false мы разре-
шаем доступ к свойству User#department только для чтения. Это значит, что можно
лишь запрашивать данные, делая вызов someUser.getDepartment(), а общедоступ-
ного метода setDepartment() просто нет. Теперь за изменение столбца DEPARTMENTID
в таблице USERS отвечает свойство UserId#departmentId.
Унаследованные первичные ключи  265
И перед сохранением нового пользователя (User) мы должны установить значе-
ние идентификатора подразделения:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyReadOnly.java
Department department = new Department("Sales");
em.persist(department); Присваивает первичный ключ
UserId id = new UserId("johndoe", department.getId()); Обязательно
User user = new User(id);
em.persist(user);
assertNull(user.getDepartment()); Осторожно!
Обратите внимание, что метод User#getDepartment() возвращает значение null,
потому что мы не присвоили значения этому свойству. Hibernate заполнит его
только при загрузке экземпляра User:
Файл: /examples/src/test/java/org/jpwh/test/complexschemas/
CompositeKeyReadOnly.java
UserId id = new UserId("johndoe", DEPARTMENT_ID);
User user = em.find(User.class, id);
assertEquals(user.getDepartment().getName(), "Sales");
Многие разработчики предпочитают инкапсулировать эти подробности в кон-
структоре:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
readonly/User.java
@Entity
@Table(name = "USERS")
public class User {
public User(String username, Department department) {
if (department.getId() == null)
throw new IllegalStateException(
"Department is transient: " + department
);
this.id = new UserId(username, department.getId());
this.department = department;
}
// ...
}
Такой конструктор гарантирует правильную инициализацию объекта User, кор-
ректно устанавливая значения идентификатора и свойств.
Если в таблице USERS определен составной первичный ключ, внешний ключ,
ссылающийся на нее, также должен быть составным.
266  Сложные и унаследованные схемы
9.2.4. Внешний ключ, ссылающийся на составной
первичный ключ
Например, связь от класса Item к классу User, представленная свойством seller,
может потребовать отображения составного внешнего ключа. Посмотрите на схе-
му на рис. 9.3.
USERNAME << PK >>
DEPARTMENTNR << PK >>
...
<< Table >>
ID << PK >> USERS
SELLER_USERNAME << FK >>
SELLER_DEPARTMENTNR << FK >>
...
<< Table >>
ITEM
Рис. 9.3  Продавец представлен в таблице ITEM
с помощью составного внешнего ключа
Hibernate может спрятать эти подробности внутри предметной модели на Java.
Например, вот как выглядит отображение поля Item#seller:
Файл: /model/src/main/java/org/jpwh/model/complexschemas/compositekey/
manytoone/Item.java
@Entity
public class Item {
@NotNull
@ManyToOne
@JoinColumns({
@JoinColumn(name = "SELLER_USERNAME",
referencedColumnName = "USERNAME"),
@JoinColumn(name = "SELLER_DEPARTMENTNR",
referencedColumnName = "DEPARTMENTNR")
})
protected User seller;
// ...
}
Возможно, вам не приходилось встречать аннотацию @JoinColumns раньше; она
определяет список столбцов составного внешнего ключа, реализующего данную
связь. Чтобы связать источник с целью внешнего ключа, обязательно нужно опре-
делить атрибут referencedColumnName. К сожалению, Hibernate ничего не сообщит,
если не сделать этого, в результате можно получить некорректный порядок столб-
цов в сгенерированной схеме.
В унаследованных схемах внешние ключи не всегда ссылаются на первичные
ключи.
Унаследованные первичные ключи  267
9.2.5. Внешние ключи, ссылающиеся на непервичные ключи
Ограничение внешнего ключа столбца SELLER в таблице ITEM гарантирует существование
продавца товара, требуя, чтобы один продавец был представлен в некото-
ром столбце некоторой записи некоторой таблицы. Других правил нет; целевой
столбец должен быть первичным ключом или иметь ограничение уникальности.
В качестве целевой может выступать любая таблица. Значение может быть чис-
ловым идентификатором продавца или строкой с номером клиента; единствен-
ное требование: тип столбца внешнего ключа должен совпадать с типом целевого
столбца, на который он ссылается.
Конечно, ограничение внешнего ключа обычно ссылается на столбец (столб-
цы) первичного ключа. Тем не менее в унаследованных базах данных иногда
можно найти такие ограничения внешнего ключа, которые не следуют это-
му простому правилу. Иногда ограничение внешнего ключа может ссылаться
на столбец с ограничением уникальности – естественный непервичный ключ.
Предположим, что в приложении CaveatEmptor требуется поддержка унасле-
дованного старого столбца естественного ключа CUSTOMERNR в таблице USERS, как
показано на рис. 9.4:
ID << PK >>
CUSTOMERNR << UNIQUE >>
...
<< Table >>
USERS
ID << PK >>
SELLER_CUSTOMERNR << FK >>
...
<< Table >>
ITEM
Рис. 9.4  Внешний ключ, представляющий продавца,
ссылается на неключевой столбец таблицы USERS
Файл: /model/src/main/java/org/jpwh/model/complexschemas/
naturalforeignkey/ User.java
@Entity
@Table(name = "USERS")
public class User implements Serializable {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull
@Column(unique = true)
protected String customerNr;
// ...
}
Пока ничего необычного; вы уже видели подобное простое отображение уни-
кального поля. Аспектом унаследованной схемы будет столбец SELLER_CUSTOMERNR
таблицы ITEM с ограничением внешнего ключа, ссылающимся на столбец CUSTOMERNR
в таблице USERS, а не на ID:
268  Сложные и унаследованные схемы
Файл: /model/src/main/java/org/jpwh/model/complexschemas/
naturalforeignkey/ Item.java
@Entity
public class Item {
@NotNull
@ManyToOne
@JoinColumn(
name = "SELLER_CUSTOMERNR",
referencedColumnName = "CUSTOMERNR"
)
protected User seller;
// ...
}
Для объявления этого отношения нужно указать значение атрибута referenced-
ColumnName в аннотации @JoinColumn. Теперь Hibernate будет знать, что целевой
столбец является естественным, а не первичным ключом, и управлять отношени-
ем внешнего ключа соответственно.
Если целевой естественный ключ является составным, используйте аннота-
цию @JoinColumns, как в предыдущем разделе. К счастью, такую схему всегда мож-
но просто привести в порядок, выполнив рефакторинг внешних ключей, чтобы
они ссылались на первичные ключи, если только у вас есть возможность вносить
изменения в базу данных, не мешая другим приложениям, использующим эти
данные.
На этом мы завершаем обсуждение проблем естественных, составных и внеш-
них ключей, с которыми вы можете столкнуться при отображении унаследо-
ванной схемы. Давайте перейдем к другой интересной специальной стратегии:
отображению свойств сущности простого или встраиваемого типа во вторичную
таблицу.
9.3. Отображение свойств во вторичные таблицы
Мы уже показывали аннотацию @SecondaryTable в отображении наследования,
в разделе 6.5. Она помогла нам вынести поля подкласса в отдельную таблицу. Эта
обобщенная функциональность имеет множество применений, но помните, что
число классов в системе должно быть больше, чем таблиц.
Представьте, что в унаследованной схеме платежный адрес пользователя хра-
нится в отдельной таблице, а не вместе с остальной информацией в главной таблице
сущности USERS. Эта схема показана на рис. 9.5. Домашний адрес пользова-
теля хранится в столбцах STREET, ZIPCODE и CITY таблицы USERS. Платежный адрес
пользователя хранится в таблице BILLING_ADDRESS со столбцом первичного ключа
USER_ID, имеющим также ограничение внешнего ключа, ссылающегося на столбец
первичного ключа ID в таблице USERS.
Отображение свойств во вторичные таблицы  269
USER_ID << PK >> << FK >>
STREET
ZIPCODE
CITY
<< Table >>
ID << PK >> BILLING_ADDRESS
STREET
ZIPCODE
CITY
<< Table >>
USERS
Рис. 9.5  Хранение данных о платежном адресе
в отдельной таблице
Для отображения этой схемы объявим вторичную таблицу для сущности User
и определим, как Hibernate должен соединить ее со вторичной таблицей (@SecondaryTable):
Файл: /model/src/main/java/org/jpwh/model/complexschemas/secondarytable/
User.java
@Entity
@Table(name = "USERS")
@SecondaryTable(
name = "BILLING_ADDRESS",
pkJoinColumns = @PrimaryKeyJoinColumn(name = "USER_ID")
)
public class User {
protected Address homeAddress;
@AttributeOverrides({
@AttributeOverride(name = "street",
column = @Column(table = "BILLING_ADDRESS",
nullable = false)),
@AttributeOverride(name = "zipcode",
column = @Column(table = "BILLING_ADDRESS",
length = 5,
nullable = false)),
@AttributeOverride(name = "city",
column = @Column(table = "BILLING_ADDRESS",
nullable = false))
})
protected Address billingAddress;
// ...
}
В классе User объявлены два свойства встраиваемого типа: homeAddress и billingAddress.
Первое представляет обычное встроенное отображение, а класс Address
является встраиваемым (@Embeddable).
Так же как в разделе 5.2.3, для переопределения отображений встраиваемых
свойств здесь можно использовать аннотацию @AttributeOverrides. Аннотация
@Column отображает отдельные свойства в таблицу BILLING_ADDRESS с помощью па-
раметра table. Помните, что аннотация @AttributeOverride замещает всю инфор-
270  Сложные и унаследованные схемы
мацию об отображении свойства: любые аннотации перед свойствами класса Address
будут игнорироваться при переопределении. Поэтому мы должны заново
указать возможность присваивания null и длину поля, используя переопределяющую
аннотацию @Column.
Мы показали вам отображение вторичной таблицы на примере встраиваемых
полей. Вы могли бы также вынести во вторичную таблицу свойства простых ти-
пов, такие как username. Но помните, что чтение и сопровождение этих отобра-
жений могут превратиться в проблему; использовать вторичные таблицы для
отображения
следует только в унаследованных неизменяемых старых схемах.
9.4. Резюме
 Сосредоточьтесь на схеме базы данных.
 Вы можете добавлять дополнительные ограничения целостности в схему базы
данных, сгенерированную Hibernate. Теперь вы знаете, как выполнять произ-
вольные SQL-сценарии создания, удаления и загрузки.
 Мы обсудили применение SQL-ограничений доменов, столбцов, таблиц и базы
данных.
 Также мы обсудили применение пользовательских SQL-типов данных и огра-
ничений уникальности, произвольной проверки и внешнего ключа.
 Вы познакомились с некоторыми типичными проблемами, которые приходит-
ся решать при работе с унаследованными схемами и особенно ключами.
 Вы узнали о нескольких типах отображений: естественных первичных клю-
чах, составных первичных ключах, внешних ключах внутри составных первич-
ных ключей, внешних ключах, ссылающихся на составные первичные ключи,
и внешних ключах, ссылающихся на непервичные ключи.
 Вы узнали, как переместить свойства сущности во вторичную таблицу.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
ADDRESS
ID << PK >> << FK >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
ID << PK >>
CC_OWNER
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table CREDITCARD
owner : String
BillingDetails
id : Long
cardNumber : String
expMonth : String
expYear : String
CreditCard
id : Long
account : String
bankname : String
swift : String
BankAccount
Часть III
ТРАНЗАКЦИОННАЯ
ОБРАБОТКА ДАННЫХ
В части III мы займемся загрузкой и сохранением данных с применением Hibernate
и Java Persistence. Мы рассмотрим программные интерфейсы, способы созда-
ния транзакционных приложений и как Hibernate может обеспечить более эффек-
тивную загрузку данных.
Начиная с главы 10, вы приступите к изучению наиболее важных стратегий ра-
боты с экземплярами сущностей в JPA-приложении. Познакомитесь с жизненным
циклом экземпляров сущностей и увидите, как они сохраняются, отсоединяют-
ся и удаляются. Именно в этой главе вы познакомитесь с наиболее важным JPA-
интерфейсом: EntityManager. Далее, в главе 11, будут описаны основы системных
транзакций и транзакций базы данных, а также управление параллельным досту-
пом с помощью Hibernate и JPA. Вы также познакомитесь с нетранзакционным до-
ступом к данным. В главе 12 мы рассмотрим отложенную и немедленную загрузки,
планы извлечения, стратегии и профили, а закончим оптимизацией выполнения
кода SQL. Наконец, в главе 13 будут рассмотрены каскадная передача изменений
состояния, ожидание и перехват событий, аудит и версионирование с помощью
Hibernate Envers, а также динамическая фильтрация данных.
К концу этой части вы будете знать, как с помощью программных интерфейсов
Hibernate и Java Persistence наиболее эффективно загружать, изменять и сохра-
нять объекты. Вы поймете, как работают транзакции и почему диалоговые взаимодействия
могут открыть новые подходы к проектированию приложений. Вы
будете готовы к оптимизации любого сценария модификации объектов и к при-
менению эффективных стратегий извлечения и кэширования для увеличения
производительности и масштабирования.
Глава 10
Управление данными
В этой главе:
 жизненный цикл и состояния объектов;
 работа с Java Persistence API;
 работа с отсоединенным состоянием.
Вы уже знаете, как Hibernate и ORM работают со статическими аспектами объектно-
реляционного рассогласования. Используя знания, полученные к настоящему
моменту, вы можете создавать отображения между Java-классами и SQL-схемами,
разрешая проблемы структурного несоответствия. Чтобы освежить в памяти све-
дения о разрешении таких проблем, можно еще раз просмотреть раздел 1.2.
Но для достижения высокой эффективности разрабатываемого приложения
этого недостаточно: требуется еще изучить стратегии управления данными во
время выполнения. Эти стратегии имеют решающее значение для высокой произ-
водительности и правильной работы приложений.
Данная глава будет посвящена жизненному циклу экземпляров сущностей,
процессу перехода их в хранимое состояние и процессу выхода их из хранимого
состояния, а также методам и операциям, осуществляющим эти переходы. Entity-
Manager является основным интерфейсом доступа к данным в JPA.
Прежде чем перейти к исследованию API, разберемся с экземплярами объектов,
их жизненным циклом и событиями, приводящими к изменению их состояния.
Хотя часть сведений является формальной, ясное понимание жизненного цикла
хранения имеет важное значение.
Главные нововведения в JPA 2
• Получить конкретную реализацию диспетчера хранения можно вызовом метода
EntityManager#unwrap(): например, API org.hibernate.Session. Используйте метод
EntityManagerFactory#unwrap() для получения экземпляра org.hibernate.SessionFactory.
• Новая операция detach() обеспечивает точное управление контекстом хранения,
вплоть до отсоединения отдельных экземпляров сущностей.
• Из существующего объекта EntityManager можно получить объект EntityManager-
Factory, используемый для создания контекста хранения с помощью getEntity-
ManagerFactory().
Жизненный цикл хранения  273
• Новые статические методы Persistence(Unit)Util позволяют определить, был ли
экземпляр объекта (или одно из его свойств) полностью загружен или является
неинициализированной ссылкой (прокси-объектом Hibernate или оберткой вы-
груженной коллекции).
10.1. Жизненный цикл хранения
Поскольку JPA является механизмом прозрачного хранения, классы ничего не зна-
ют о возможности собственного сохранения; можно написать такую логику прило-
жения, которой будет неизвестно, представляют ли данные, с которыми она работа-
ет, хранимое или временное состояние, существующее только в памяти. При вызове
методов экземпляра приложение не должно беспокоиться о том, является ли оно
хранимым. Вы можете, к примеру, вызвать бизнес-метод Item#calculateTotalPrice(),
вообще не задумываясь о хранении (например, в модульном тесте).
Любое приложение с хранимым состоянием должно взаимодействовать со
службой хранения, когда требуется перенести текущее состояние из памяти в базу
данных (и наоборот). Иначе говоря, для сохранения и загрузки данных вы должны
вызывать интерфейсы Java Persistence.
При такой организации работы с механизмом хранения приложение должно
учитывать не только факт хранения в базе данных, но и жизненный цикл экзем-
пляра сущности. Мы называем его жизненным циклом хранения, представляющим
набор состояний, через которые проходит экземпляр сущности за время своего
существования. Также мы будем использовать термин единица работы – набор
операций, меняющих (возможно) состояние, которые выполняются (обычно ато-
марно) как единое целое. Другой частью головоломки является контекст хра-
нения, предоставляемый службой хранения. Вы можете рассматривать контекст
хранения как службу, запоминающую все модификации и изменения состояния,
которые производятся над данными в рамках конкретной единицы работы (это
несколько упрощенное представление, но для начала вполне уместное).
Теперь разберемся со всеми этими терминами: состояниями сущностей, кон-
текстами хранения и управляемыми областями видимости. Вы, возможно, больше
привыкли думать о тех инструкциях SQL, которые нужно использовать для за-
грузки и сохранения данных в базу; но одним из решающих факторов для успеш-
ной работы с Java Persistence является понимание процесса управления состояни-
ем, поэтому задержитесь в этом разделе вместе с нами.
10.1.1. Состояния экземпляров сущностей
Различные механизмы ORM используют разную терминологию и определяют раз-
личные состояния и переходы между ними внутри персистентного жизненного
цикла. Более того, внутренние состояния могут отличаться от состояний, предо-
ставляемых клиентскому приложению. JPA определяет четыре состояния, скры-
вая сложность внутренней реализации Hibernate от клиентского кода. Эти состояния
и переходы между ними показаны на рис. 10.1.
274  Управление данными
Рис. 10.1  Состояния экземпляров сущностей и переходы между ними
На диаграмме состояний также показаны вызовы методов интерфейса Entity-
Manager (и Query), инициирующие переходы между состояниями. Мы обсудим дан-
ную диаграмму в этой главе; вы всегда можете обратиться к ней для получения об-
щей картины. Давайте более детально изучим состояния и переходы между ними.
Временное состояние
Объекты, созданные с помощью Java-оператора new, являются временными (transient),
т. е. их состояние будет потеряно и уничтожено сборщиком мусора, как толь-
ко исчезнут последние ссылки на них. Например, выражение new Item() создает вре-
менный экземпляр класса Item, подобно new Long() и new BigDecimal(). Hibernate не
поддерживает возможности отката изменений во временных экземплярах; изменив
цену временного товара (Item), вы не сможете автоматически отменить изменение.
Чтобы экземпляр сущности перешел из временного состояния в хранимое, т. е.
чтобы он стал управляемым, требуется либо вызвать метод EntityManager#persist(),
либо создать ссылку из хранимого экземпляра и настроить каскадную передачу
состояния для этой отображаемой связи.
Хранимое состояние
Экземпляр хранимой сущности имеет представление в базе данных. Он или уже
хранится в базе данных, или будет сохранен по окончании выполнения единицы
работы. Это экземпляр, обладающий идентичностью в базе данных, как показано
в разделе 4.2; его идентификатору присвоено значение первичного ключа пред-
ставления в базе данных.
Приложение может создавать экземпляры и делать их хранимыми, вызывая
метод EntityManager#persist(). Также могут существовать экземпляры, ставшие
хранимыми в результате создания ссылок на них из других, хранимых экземпля-
Жизненный цикл хранения  275
ров, которые уже управляются реализацией JPA. Экземпляр хранимой сущности
может представлять объект, извлеченный из базы данных с помощью запроса,
а также в результате поиска по идентификатору или навигации по графу объектов,
начиная с другого хранимого экземпляра.
Хранимые экземпляры всегда связаны с контекстом хранения. Совсем скоро вы
узнаете об этом больше.
Удаленное состояние
Удалить экземпляр хранимой сущности из базы даных можно несколькими
способами. Например, вызовом метода EntityManager#remove(). Экземпляр можно
также удалить, удалив ссылку на него из отображаемой коллекции с настроенным
удалением осиротевших объектов.
В результате подобных действий экземпляр сущности оказывается в удаленном
состоянии: реализация удалит его в конце выполнения единицы работы. Вы долж-
ны избавиться от всех ссылок на такой экземпляр после завершения работы с ним,
например после вывода на экран сообщения, подтверждающего удаление.
Отсоединенное состояние
Для понимания идеи отсоединенных экземпляров сущностей рассмотрим про-
цесс загрузки экземпляра. Чтобы получить экземпляр сущности по его (извест-
ному) идентификатору, вы вызываете метод EntityManager#find(). После этого вы
завершаете выполнение единицы работы и закрываете контекст хранения. В при-
ложении при этом остается дескриптор – ссылка на загруженный экземпляр. Он
теперь находится в отсоединенном состоянии, и его данные перестают быть актуальными.
Вы можете избавиться от ссылки, позволив сборщику мусора освобо-
дить занимаемую экземпляром память, или продолжить работу с данными в отсо-
единенном состоянии, а позже вызвать метод merge() для сохранения изменений
в рамках новой единицы работы. Мы снова вернемся к теме отсоединения и слия-
ния позже в этой главе, в специальном разделе.
У вас уже должно сложиться представление о состояниях экземпляров сущ-
ностей и переходах между ними. Нашей следующей темой станет контекст хране-
ния – ключевая служба для любой реализации Java Persistence.
10.1.2. Контекст хранения
В приложении, использующем Java Persistence, объект EntityManager обладает кон-
текстом хранения. Этот контекст создается вызовом метода EntityManagerFactory
#createEntityManager(). Закрытие контекста осуществляется при помощи метода
EntityManager#close(). В терминологии JPA это называется контекстом хранения,
управляемым приложением; приложение определяет область действия контекста
хранения, задавая рамки единицы работы.
Контекст хранения следит за всеми сущностями, находящимися в хранимом со-
стоянии, и управляет ими. Контекст хранения – это центральная часть практиче-
ски всех функций, предоставляемых реализацией JPA.
276  Управление данными
Контекст хранения позволяет механизму хранения выполнять автоматиче-
скую проверку состояний объектов (dirty checking), чтобы выявить экземпляры
сущностей, модифицированные приложением. Затем реализация механизма хра-
нения автоматически или по требованию синхронизирует с базой данных состояние
экземпляров, находящихся под наблюдением контекста хранения. Обычно
по завершении единицы работы реализация передает состояние из памяти в базу
данных, выполняя SQL-инструкции INSERT, UPDATE и DELETE, которые являются
частью языка управления данными DML (Data Modification Language). Проце-
дура выталкивания контекста может выполняться и в другое время. Например,
Hibernate может выполнять синхронизацию с базой данных перед выполнением
запроса. Это гарантирует получение запросами изменений, произведенных ранее
в рамках единицы работы.
Контекст хранения выступает в роли кэша первого уровня; он запоминает
все экземпляры, вовлеченные в конкретную единицу работы. Например, если
предложить Hibernate загрузить экземпляр сущности, используя значение пер-
вичного ключа (поиск по идентификатору), фреймворк может сначала прове-
рить текущую единицу работы в контексте хранения. Если экземпляр сущности
обнаружится в контексте хранения, никакого обращения к базе не будет – для
приложения это будет повторным чтением. Последовательные вызовы метода
em.find(Item.class, ITEM_ID) для одного контекста хранения будут возвращать
одинаковый результат.
Этот кэш также влияет на результаты произвольных запросов, например вы-
полняемых при помощи javax.persistence.Query. Hibernate читает результат
SQL-запроса и превращает его в набор экземпляров сущностей. Сначала он
пытается отыскать каждый экземпляр сущности в контексте хранения, исполь-
зуя поиск по идентификатору. И только если экземпляр с нужным значением
идентификатора не найден в текущем контексте, Hibernate прочитает оставшуюся
часть данных из набора, полученного в результате запроса. Если экземпляр
сущности уже находится в контексте хранения, Hibernate проигнорирует все по-
тенциально более новые данные из запроса из-за уровня изоляции транзакций
в базе данных, при котором возможно чтение только подтвержденных данных
(read commited).
Кэш контекста хранения работает всегда – его нельзя отключить. Он гаранти-
рует следующее:
 уровень хранения не подвержен переполнению стека при наличии цикличе-
ских ссылок в графе объектов;
 по окончании выполнения единицы работы не может существовать несколь-
ких конфликтующих представлений одной и той же записи в базе данных.
Реализация механизма хранения может спокойно записывать в базу данных
любые изменения в экземплярах сущностей;
 аналогично все изменения в конкретном контексте хранения сразу становят-
ся доступными всему коду, выполняемому внутри этой единицы работы и ее
контекста хранения. JPA гарантирует целостность экземпляров сущностей.
Интерфейс EntityManager  277
Контекст хранения имеет область гарантированной идентичности объектов;
в области действия контекста хранения строку базы данных может представлять
лишь один экземпляр. Рассмотрим сравнение ссылок entityA == entityB. Это вы-
ражение вернет true, только если обе ссылки будут указывать на один и тот же
Java-объект в куче. Теперь рассмотрим сравнение entityA.getId().equals(entityB.
getId()). Это выражение вернет true, если оба объекта будут иметь одинаковое
значение идентификатора в базе данных. Внутри одного контекста хранения Hibernate
гарантирует, что оба сравнения дадут одинаковый результат. Это решает
одну из фундаментальных проблем объектно-реляционного отображения, пред-
ставленную в разделе 1.2.3.
Не лучше ли использовать идентичность,
ограниченную областью видимости процесса?
Для типичного веб- или корпоративного приложения предпочтительнее исполь-
зовать идентичность, ограниченную областью видимости контекста хранения.
Идентичность, ограниченная областью видимости процесса, когда запись в базе
данных представляет только один экземпляр в памяти процесса (JVM), дает не-
которые потенциальные преимущества, касающиеся использования кэша. Однако
в многопоточном приложении стоимость синхронизации доступа к хранимым эк-
земплярам в глобальном словаре идентичностей будет слишком высокой. Более
простое и масштабируемое решение состоит в том, чтобы каждый поток работал
с отдельной копией данных в каждом контексте хранения.
Жизненный цикл экземпляров сущностей и служб, предоставляемых контек-
стом хранения, – сложная тема. Поэтому давайте рассмотрим несколько примеров
проверки состояния объектов, кэширования и как область гарантированной иден-
тичности работает на практике. Для этого нам понадобится диспетчер хранения
EntityManager.
10.2. Интерфейс EntityManager
Любой инструмент поддержки прозрачности хранения включает диспетчера хра-
нения. Этот диспетчер обычно предоставляет возможность выполнения базовых
операций CRUD (создание, чтение, изменение, удаление), запросов и управления
контекстом хранения. В приложении, использующем Java Persistence, основным
интерфейсом для создания единиц работы является EntityManager.
10.2.1. Каноническая форма единицы работы
В Java SE и некоторых EE-архитектурах (например, если вы используете обыч-
ные сервлеты) получить экземпляр EntityManager можно вызовом метода EntityM
anagerFactory#createEntityManager(). Код приложения использует единственный
экземпляр EntityManagerFactory, представляющий одну единицу хранения или
278  Управление данными
одну логическую базу данных. Большинство приложений использует лишь один
общий экземпляр EntityManagerFactory.
Объект EntityManager применяется для выполнения одной единицы работы
в одном потоке, и его создание является довольно дорогостоящей операцией. Листинг
10.1 демонстрирует типичную, каноническую форму единицы работы.
Листинг 10.1  Типичная форма единицы работы
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
EntityManager em = null;
UserTransaction tx = TM.getUserTransaction();
try {
tx.begin();
em = JPA.createEntityManager(); Управляется приложением
// ...
tx.commit(); Синхронизирует/выталкивает контекст хранения
} catch (Exception ex) {
// Откат транзакции, обработка исключения
// ...
} finally {
if (em != null && em.isOpen())
em.close(); Вы его создали – вы и закрывайте!
}
(Класс TM является вспомогательным классом и входит в состав примеров кода для
этой книги. Здесь он нужен для упрощения поиска стандартного интерфейса User-
Transaction в контексте JNDI. Класс JPA предоставляет удобный способ обращения
к общему экземпляру EntityManagerFactory.)
Весь код между вызовами tx.begin() и tx.commit() выполняется в рамках одной
транзакции. Пока что запомните, что все операции с базой данных в области дей-
ствия транзакции, такие как выполняемые Hibernate SQL-запросы, либо выпол-
няются успешно целиком, либо откатываются. Не думайте пока слишком много
о транзакционном коде; вы прочтете больше о многопоточности в следующей гла-
ве. Мы рассмотрим тот же пример снова, обращая внимание на транзакции и код
обработки ошибок. Не пишите пустых блоков catch в своем коде – вы должны
откатывать транзакции и обрабатывать исключения.
Создание экземпляра EntityManager запускает его контекст хранения. Hibernate
не будет обращаться к базе данных без необходимости; экземпляр EntityManager
не извлекает соединения JDBC Connection из пула, пока не потребуется выполнить
SQL-запрос. Вы можете создать и закрыть объект EntityManager, так и не выпол-
нив ни одной операции с базой данных. Hibernate выполняет выражения SQL,
когда вы ищите или запрашиваете данные или когда он записывает изменения,
обнаруженные в контексте хранения. В процессе создания объекта EntityManager
фреймворк Hibernate присоединяется к текущей системной транзакции и ожида-
ет ее подтверждения. Когда Hibernate получит уведомление (от механизма JTA)
о подтверждении транзакции, он выполнит проверку состояния объектов в кон-
Интерфейс EntityManager  279
тексте хранения и произведет синхронизацию с базой данных. Проверку состоя-
ния объектов и синхронизацию можно выполнить принудительно в любое время
в течение транзакции, с помощью метода EntityManager#flush().
Вы можете определять границы контекста хранения, выбирая момент вызова
метода close() объекта EntityManager. В какой-то момент вам придется закрыть
контекст, поэтому всегда помещайте вызов close() в блок finally.
Как долго контекст хранения может находиться открытым? Для последующих
примеров предположим, что мы пишем сервер и каждый клиентский запрос бу-
дет обрабатываться в отдельном контексте хранения и в рамках своей транзакции.
Если вы знакомы с сервлетами, представьте, что код в листинге 10.1 находится
внутри метода service(). В рамках этой единицы работы вы получаете доступ к эк-
земпляру EntityManager для загрузки и сохранения данных.
10.2.2. Сохранение данных
Давайте создадим новый экземпляр сущности и переведем его в хранимое состояние:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item item = new Item();
item.setName("Some Item"); Для поля Item#name определено ограничение NOT NULL
em.persist(item);
Long ITEM_ID = item.getId(); Уже присвоен
Эта единица работы и изменение состояния экземпляра Item изображены на
рис. 10.2.
Рис. 10.2  Переход экземпляра в хранимое состояние
в рамках единицы работы
Новый временный экземпляр Item создается как обычно. Конечно, его можно
было бы создать перед объектом EntityManager. Вызов метода persist() переводит
временный экземпляр Item в хранимое состояние. Теперь он стал управляемым
и связан с текущим контекстом хранения.
Для записи экземпляра Item в базу данных Hibernate должен выполнить SQL-
инструкцию INSERT. После подтверждения транзакция этой единицы работы Hibernate
вытолкнет контекст хранения, и в этот момент выполнится инструкция
280  Управление данными
INSERT. Hibernate может выполнять сразу несколько инструкций INSERT на уровне
JDBC. Вызов метода persist() лишь присвоит значение идентификатора объекту
Item. Иначе, если генератор идентификаторов не вызывается перед вставкой, вы-
ражение INSERT будет выполнено в момент вызова persist(). Возможно, вы захо-
тите заново просмотреть раздел 4.2.5.
Определение состояния сущности при помощи идентификатора
Иногда требуется узнать, является ли экземпляр сущности временным, храни-
мым или отсоединенным. Экземпляр находится в хранимом состоянии, если вы-
зов EntityManager#contains(e) возвращает true; во временном, если вызов Persiste
nceUnitUtil#getIdentifier(e) возвращает null, и в отсоединенном, если не является
хранимым и метод PersistenceUnitUtil#getIdentifier(e) возвращает значение поля
идентификатора сущности. Получить доступ к PersistenceUnitUtil можно из объек-
та EntityManagerFactory.
Обратите внимание на два момента. Во-первых, значение идентификатора может
быть не присвоено и недоступно до момента выталкивания контекста хранения.
Во-вторых, Hibernate (в отличие от некоторых других реализаций JPA) никогда не
вернет значения null из метода PersistenceUnitUtil#getIdentifier(), если поле иден-
тификатора имеет простой тип (например, long, а не Long).
Желательно (но необязательно) полностью инициализировать экземпляр Item
перед включением в контекст хранения. SQL-выражение INSERT содержит значе-
ния, которые находились в экземпляре в момент вызова persist(). Если не при-
своить значение полю name объекта Item, перед тем как сделать его хранимым,
может быть нарушено ограничение NOT NULL. Изменения в объекте Item, произве-
денные после вызова persist(), попадут в базу данных в результате выполнения
дополнительного SQL-выражения UPDATE.
Если одно из выражений – INSERT или UPDATE – приведет к ошибке во время со-
хранения контекста, Hibernate отменит изменения, сделанные в рамках данной
транзакции, на уровне базы данных, но не отменит изменений в памяти. Если по-
менять значение поля Item#name после вызова persist(), ошибка при подтверж-
дении транзакции не вернет прежнего значения. Это вполне логично, поскольку
восстановиться после ошибки в транзакции обычно невозможно, и вы должны не-
медленно избавиться от поврежденного контекста хранения и объекта EntityManager.
Мы обсудим обработку исключений в следующей главе.
Далее мы будем загружать и модифицировать сохраненные данные.
10.2.3. Извлечение и модификация хранимых данных
Извлекать хранимые экземпляры из базы данных можно с помощью объекта EntityManager.
В следующем примере предполагается, что где-то имеется значение
идентификатора объекта Item, сохраненного в предыдущем разделе, и теперь нуж-
но найти этот объект по идентификатору в рамках новой единицы работы:
Интерфейс EntityManager  281
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item item = em.find(Item.class, ITEM_ID);
if (item != null)
item.setName("New Name"); Изменение состояния
Рисунок 10.3 наглядно демонстрирует этот переход.
Рис. 10.3  Переход экземпляра в хранимое состояние
в рамках единицы работы
Значение, возвращаемое методом find(), не требует приведения типа; это пара-
метризованный метод, тип результата которого определяется первым параметром.
Возвращаемый экземпляр сущности находится в хранимом состоянии, и его мож-
но изменить в рамках единицы работы.
Если в контексте нет ни одного хранимого экземпляра с заданным идентифика-
тором, метод find() вернет null. Операция find() всегда обращается к базе данных,
если сущность требуемого типа с искомым идентификатором отсутствует в кэше
контекста хранения. Экземпляр сущности всегда инициализируется во время за-
грузки. Вы можете быть уверены в том, что все его значения будут доступны позже
в отсоединенном состоянии: например, при отображении на экране после закрытия
контекста хранения. (Hibernate может не обращаться к базе данных, если включен
необязательный кэш второго уровня; мы рассмотрим этот кэш в разделе 20.2.)
Вы можете изменить экземпляр Item, а контекст хранения автоматически об-
наружит эти изменения и запишет их в базу данных. Когда Hibernate выталки-
вает контекст хранения во время подтверждения транзакции, он выполняет не-
обходимые выражения SQL DML для синхронизации изменений с базой данных.
Hibernate старается передать изменения в базу данных как можно позже после
завершения транзакции. Инструкции DML обычно устанавливают в базе данных
блокировку, существующую до конца транзакции, так что Hibernate сводит про-
должительность блокировки к минимуму.
Hibernate запишет новое значение поля Item#name в базу данных, выполнив
SQL-выражение UPDATE. По умолчанию Hibernate включает в это выражение все
столбцы отображаемой таблицы ITEM, перезаписывая старые значения заново
в неизмененных столбцах. Если понадобится включать в SQL-инструкции только
измененные столбцы (или, в случае с INSERT, только столбцы, которые не могут
содержать null), можно настроить динамическую генерацию кода SQL, как было
показано в разделе 4.3.2.
Обратиться к базе данных,
если объект отсутствует
в контексте хранения
282  Управление данными
Hibernate обнаружит изменение в поле name, сравнивая объект Item с копией,
сделанной ранее, в момент загрузки объекта Item из базы данных. Если объект от-
личается от копии, значит, требуется выполнить операцию UPDATE. Копия состоя-
ния в контексте хранения расходует память. Проверка состояния объектов с ис-
пользованием копий также увеличивает накладные расходы, поскольку во время
выталкивания контекста Hibernate должен сравнить все экземпляры в контексте
с их копиями.
Вам может понадобиться настроить порядок выявления изменений, используя
механизм расширения. Укажите в параметре hibernate.entity_dirtiness_strategy
(в файле конфигурации persistence.xml) имя класса, реализующего интерфейс
org.hibernate.CustomEntityDirtinessStrategy. Чтобы узнать больше об этом интер-
фейсе, прочтите его документацию Javadoc. Интерфейс org.hibernate.Interceptor
представляет еще один механизм управления проверкой состояния объектов
путем реализации его метода findDirty(). Пример реализации этого обработчика
можно найти в разделе 13.2.2.
Ранее упоминалось, что контекст хранения позволяет повторно читать экзем-
пляры сущностей и предоставляет гарантию объектной идентичности:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item itemA = em.find(Item.class, ITEM_ID);
Item itemB = em.find(Item.class, ITEM_ID); Повторное чтение
assertTrue(itemA == itemB);
assertTrue(itemA.equals(itemB));
assertTrue(itemA.getId().equals(itemB.getId()));
Первый вызов find() обращается к базе данных и получает объект Item с помощью
выражения SELECT. Второй находит искомый экземпляр в контексте хране-
ния и возвращает кэшированный объект Item.
Иногда может потребоваться получить экземпляр сущности без обращения
к базе данных.
10.2.4. Получение ссылки на объект
Если вы не хотите обращаться к базе данных во время загрузки экземпляра сущ-
ности, поскольку не знаете, понадобится ли вам полностью инициализированный
экземпляр, можно попросить объект EntityManager загрузить пустой указатель –
прокси-объект:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item item = em.getReference(Item.class, ITEM_ID);  getReference()
PersistenceUnitUtil persistenceUtil =  Вспомогательный метод
JPA.getEntityManagerFactory().getPersistenceUnitUtil();
assertFalse(persistenceUtil.isLoaded(item));
// assertEquals(item.getName(), "Some Item");  Инициализация прокси-объекта
// Hibernate.initialize(item);  Загрузка данных из прокси-объекта
Интерфейс EntityManager  283
tx.commit();
em.close();
assertEquals(item.getName(), "Some Item");  Объект находится в отсоединенном состоянии
 Если контекст хранения уже содержит объект Item с заданным идентификатором, он
будет возвращен методом getReference() без обращения к базе данных. Если в данный
момент в управляемом состоянии нет ни одного хранимого экземпляра с таким иденти-
фикатором, Hibernate создаст прокси-объект. Это значит, что метод getReference() не
будет обращаться к базе данных, но и не вернет null, в отличие от метода find().
 JPA предоставляет в классе PersistenceUnitUtil вспомогательный метод isLoaded(), по-
могающий определить факт работы с неинициализированным прокси-объектом.
 Стоит только вызвать какой-нибудь метод прокси-объекта, например Item#getName(), как
тут же будет выполнена инструкция SELECT для его полной инициализации. Исключением
из правила является метод getId() получения отображаемого идентификатора из базы дан-
ных. Прокси-объект может выглядеть как настоящий объект, но это всего лишь пустышка,
в которой хранится значение идентификатора представляемого им экземпляра сущности.
Если во время инициализации прокси-объекта соответствующей записи в базе данных не
окажется, будет возбуждено исключение EntityNotFoundException. Обратите внимание, что
это исключение может быть возбуждено также при вызове метода Item#getName().
 В Hibernate имеется удобный статический метод initialize() для загрузки данных
прокси-объекта.
 После закрытия контекста хранения объект Item оказывается в отсоединенном состоя-
нии. Если прокси-объект не был инициализирован, пока контекст хранения был открыт,
при обращении к прокси-объекту будет возбуждено исключение LazyInitializationException.
Нельзя загружать данные по требованию после закрытия контекста. Но эта проблема
имеет простое решение – загружайте данные перед закрытием контекста хранения.
Мы еще многое вам расскажем о прокси-объектах, отложенной загрузке и из-
влечении данных по требованию в главе 12.
Чтобы удалить экземпляр сущности из базы данных, его нужно перевести во
временное состояние.
10.2.5. Переход данных во временное состояние
Чтобы перевести экземпляр сущности во временное состояние и удалить его из
базы данных, вызовите метод remove() объекта EntityManager:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item item = em.find(Item.class, ITEM_ID);  Вызвать find() или getReference()
// Item item = em.getReference(Item.class, ITEM_ID);
em.remove(item);  Поместить экземпляр в очередь на удаление
assertFalse(em.contains(item));  Проверка состояния сущности
// em.persist(item);  Отмена удаления
assertNull(item.getId());
tx.commit();
em.close();
Был включен параметр hibernate.use_identifier_rollback;
теперь этот экземпляр выглядит как временный
284  Управление данными
 Если вызвать метод find(), Hibernate выполнит выражение SELECT и загрузит объект Item.
Если вызвать метод getReference(), Hibernate попытается обойтись без инструкции SELECT
и вернет прокси-объект.
 Вызов метода remove() добавит экземпляр сущности в очередь на удаление по окончании
выполнения единицы работы; теперь он находится в удаленном состоянии. Если метод
remove() вызвать для прокси-объекта, Hibernate выполнит инструкцию SELECT, чтобы за-
грузить данные. Экземпляр сущности должен быть полностью инициализирован перед
переходом между состояниями жизненного цикла. У вас могут быть определены методы
обратных вызовов для событий жизненного цикла или настроены обработчики (см. раз-
дел 13.2), и экземпляр должен быть обработан каждым из них для завершения своего
жизненного цикла.
 Сущность в удаленном состоянии больше не является хранимой. Это можно проверить
вызовом contains().
 Отменив уделение, экземпляр можно снова сделать хранимым.
 После подтверждения транзакции Hibernate синхронизирует переходы между состоя-
ниями с базой данных и выполнит SQL-выражение DELETE. Сборщик мусора JVM обна-
ружит отсутствие ссылок на item и удалит последние остатки данных из памяти.
Этот процесс показан на рис. 10.4.
Рис. 10.4  Удаление экземпляра
в рамках единицы работы
По умолчанию Hibernate не меняет значения идентификатора удаляемого эк-
земпляра сущности. Это значит, что item.getId() по-прежнему будет возвращать
устаревшее значение идентификатора. Иногда бывает полезно продолжить ра-
ботать с «удаленными» данными и дальше – например, удаленный объект Item
можно сохранить на случай, если пользователь захочет отменить операцию. Как
показано в примере, можно вызвать метод persist() для удаленного экземпляра
и отменить удаление перед выталкиванием контекста. С другой стороны, если
присвоить параметру hibernate.use_identifier_rollback значение true в файле
конфигурации persistence.xml, Hibernate сбросит значение идентификатора после
удаления экземпляра сущности. В предыдущем примере идентификатору было
присвоено значение по умолчанию null (поскольку он имеет тип Long). Теперь
объект Item оказывается во временном состоянии, и его можно снова сохранить
в новом контексте хранения.
Java Persistence также предоставляет массовые операции, транслирующиеся не-
посредственно в SQL-выражения DELETE, не вовлекающие в работу обработчиков
событий жизненного цикла. Мы обсудим эти операции в разделе 20.1.
Интерфейс EntityManager  285
Предположим, что вы загрузили экземпляр сущности из базы данных и работаете
с его данными. Каким-то образом вам стало известно, что другое приложение
или другой поток вашего приложения изменил соответствующую запись в базе
данных. Давайте теперь посмотрим, как обновить данные, загруженные в память.
10.2.6. Изменение данных в памяти
Следующий пример демонстрирует изменение экземпляра хранимой сущности:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
Item item = em.find(Item.class, ITEM_ID);
item.setName("Some Name");
// Кто-то обновил эту запись в базе данных
String oldName = item.getName();
em.refresh(item);
assertNotEquals(item.getName(), oldName);
После загрузки экземпляра сущности вы поняли (не важно, как), что кто-то из-
менил запись в базе данных. После вызова refresh() Hibernate выполнит выраже-
ние SELECT, чтобы прочитать и загрузить результаты запроса, замещая все измене-
ния, произведенные в хранимой сущности в памяти. Если запись в базе данных
больше не существует (кто-то ее удалил), при вызове refresh() Hibernate возбудит
исключение EntityNotFoundException.
Большинству приложений не требуется обновлять состояние в памяти вруч-
ную; конфликты, вызванные изменениями в многопоточной среде, обычно раз-
решаются во время подтверждения транзакции. А операцию обновления лучше
использовать с расширенным контекстом хранения, который может оставаться от-
крытым на протяжении нескольких циклов запрос/ответ и/или системных тран-
закций. Пока вы ожидаете ввода данных пользователем с открытым контекстом
хранения, данные могут устареть, и может понадобиться выборочное обновление,
в зависимости от длительности диалогового взаимодействия между пользовате-
лем и системой. Обновление может оказаться полезным для отмены изменений,
сделанных в памяти в процессе диалогового взаимодействия, например если поль-
зователь его прервет. Мы еще вернемся к теме обновления в процессе диалогового
взаимодействия с пользователем в разделе 18.3.
Другой нечасто используемой операцией является репликация экземпляра
сущности.
10.2.7. Репликация данных
Репликация полезна, когда нужно извлечь данные из одной базы данных и сохра-
нить в другую. Процесс репликации получает отсоединенные экземпляры, загру-
женные в один контекст хранения, и сохраняет их в другом контексте. Обычно
контексты открываются с помощью двух конфигураций EntityManagerFactory,
описывающих две логические базы данных. Вы должны отобразить сущность
в каждой из конфигураций.
286  Управление данными
Операция replicate() доступна только в Hibernate-интерфейсе Session. Следующий
пример загружает экземпляр Item из одной базы данных и копирует
в другую:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
tx.begin();
EntityManager emA = getDatabaseA().createEntityManager();
Item item = emA.find(Item.class, ITEM_ID);
EntityManager emB = getDatabaseB().createEntityManager();
emB.unwrap(Session.class)
.replicate(item, org.hibernate.ReplicationMode.LATEST_VERSION);
tx.commit();
emA.close();
emB.close();
Соединения с обеими базами данных могут участвовать в одной системной
транзакции.
Выполнением процедуры репликации управляет перечисление ReplicationMode:
 IGNORE. Игнорировать экземпляр, если в базе данных уже есть запись с та-
ким же идентификатором;
 OVERWRITE. Перезаписать существующую запись с таким же идентификато-
ром;
 EXCEPTION. Возбудить исключение, если в целевой базе данных найдется
записьс
таким же идентификатором;
 LATEST_VERSION. Перезаписать существующую запись, если ее версия стар-
ше версии данного экземпляра сущности, иначе игнорировать экземпляр.
Требует использования оптимистического управления конкурентным до-
ступом с версионированием сущностей (см. раздел 11.2.2).
Репликация может понадобиться, например, для приведения в соответствие
данных в различных базах данных. Типичным примером может служить обнов-
ление программы: если новая версия приложения требует новой (схемы) базы
данных, вам могут понадобиться одновременная миграция и репликация данных.
Контекст хранения многое сделает за вас: автоматическую проверку состояния
объектов, обеспечение гарантированной области идентичности объектов и т. д.
Но также важно, чтобы вы знали некоторые подробности управления им и могли
иногда
влиять на происходящее за кулисами.
10.2.8. Кэширование в контексте хранения
Контекст хранения служит кэшем хранимых экземпляров. Каждый экземпляр
сущности в хранимом состоянии связан с контекстом хранения.
Большинство пользователей Hibernate, игнорирующих этот простой факт, по-
лучает исключение OutOfMemoryException. Обычно это происходит при попытке за-
грузить тысячи экземпляров сущностей в рамках единицы работы, которые никог-
Интерфейс EntityManager  287
да не меняются. Для каждого экземпляра Hibernate должен сделать копию в кэше
контекста хранения, что может привести к исчерпанию памяти (очевидно, что для
изменения тысяч записей нужно использовать массовые операции; мы вернемся
к подобному типу единицы работы в разделе 20.1).
Кэш контекста хранения никогда не уменьшается автоматически. Поэтому
удерживайте его размер на минимально необходимом уровне. Как правило, боль-
шинство хранимых экземпляров оказывается в контексте случайно, например
если требовалось несколько объектов, а вы запросили больше. Чрезмерно боль-
шие графы могут сильно влиять на производительность и требовать значительно-
го расхода памяти для хранения копий. Убедитесь, что ваши запросы возвращают
только необходимые данные, и обратите внимание на следующие способы управ-
ления поведением кэша Hibernate.
Вы можете вызвать метод EntityManager#detach(i) для удаления хранимого эк-
земпляра из контекста вручную. Также можно вызвать EntityManager#clear() для
отсоединения всех хранимых экземпляров, оставляя контекст хранения пустым.
Оригинальный интерфейс Session предоставляет несколько полезных опера-
ций. Например, весь контекст хранения можно перевести в режим доступа только
на чтение. Это предотвратит создание копий и отключит проверку состояния объ-
ектов, и Hibernate не будет записывать изменений в базу данных:
Файл: /examples/src/test/java/org/jpwh/test/fetching/ReadOnly.java
em.unwrap(Session.class).setDefaultReadOnly(true);
Item item = em.find(Item.class, ITEM_ID);
item.setName("New Name");
em.flush(); Никакой операции UPDATE
Можно отключить проверку состояния для единственного экземпляра сущно-
сти:
Файл: /examples/src/test/java/org/jpwh/test/fetching/ReadOnly.java
Item item = em.find(Item.class, ITEM_ID);
em.unwrap(Session.class).setReadOnly(item, true);
item.setName("New Name");
em.flush(); Никакой операции UPDATE
Запрос, выполненный интерфейсом org.hibernate.Query, может возвращать ре-
зультаты, доступные только для чтения, изменения которых не будут проверяться:
Файл: /examples/src/test/java/org/jpwh/test/fetching/ReadOnly.java
org.hibernate.Query query = em.unwrap(Session.class)
.createQuery("select i from Item i");
query.setReadOnly(true).list();
List<Item> result = query.list();
288  Управление данными
for (Item item : result)
item.setName("New Name");
em.flush(); Никакой операции UPDATE
С помощью подсказок в запросах можно также отключить проверку состояния
объектов для экземпляров, полученных с помощью стандартного JPA-интерфейса
javax.persistence.Query:
Query query = em.createQuery(queryString)
.setHint(
org.hibernate.annotations.QueryHints.READ_ONLY,
true
);
Будьте осторожны при работе с экземплярами сущностей, доступными толь-
ко для чтения, – их по-прежнему можно удалять, а модификации коллекций мо-
гут преподносить сюрпризы! Руководство Hibernate содержит длинный список
особых случаев, который нужно прочитать перед использованием этих настроек
с отображаемыми коллекциями. Вы увидите больше примеров запросов в главе 14.
До сих пор выталкивание контекста хранения и синхронизация происходили
автоматически, во время подтверждения транзакции. В некоторых ситуациях мо-
жет понадобиться получить более полный контроль над процессом синхрониза-
ции.
10.2.9. Выталкивание контекста хранения
По умолчанию Hibernate выталкивает контекст хранения объекта EntityManager
и синхронизирует изменения с базой данных, как только происходит подтверж-
дение присоединенной транзакции. Эту стратегию использовали все предыдущие
примеры, кроме некоторых в предыдущем разделе. JPA позволяет реализациям
выполнять синхронизацию контекста хранения в другие моменты, если они того
желают.
Hibernate как реализация JPA выполняет синхронизацию:
 во время подтверждения присоединенной системной транзакции JTA;
 перед выполнением запроса; мы не имеем в виду поиск с помощью find(),
а запрос, выполненный с помощью интерфейса javax.persistence.Query или
другого подобного Hibernate API;
 во время явного вызова flush() приложением.
Это поведение нельзя изменить с помощью настройки FlushModeType объекта
EntityManager:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);  Загрузка экземпляра Item
item.setName("New Name");  Изменение имени экземпляра
Интерфейс EntityManager  289
em.setFlushMode(FlushModeType.COMMIT);
assertEquals(
em.createQuery("select i.name from Item i where i.id = :id")
.setParameter("id", ITEM_ID).getSingleResult(),
"Original Name"
);
tx.commit(); Выталкивание контекста!
em.close();
Этот пример загружает товар (Item)  и меняет его имя . После этого вы-
полняется запрос к базе данных и извлекается имя товара . Обычно Hibernate
определяет факт изменения данных в памяти и синхронизирует изменения с ба-
зой данных перед выполнением запроса. Такое поведение соответствует значению
FlushModeType.
AUTO, которое используется по умолчанию во время присоединения
объекта EntityManager к транзакции. Используя значение FlushModeType.COMMIT,
можно отключить выталкивание контекста перед выполнением запроса и, следова-
тельно, наблюдать различия между данными в памяти и полученными в результате
запроса. Синхронизация произойдет только во время подтверждения транзакции.
Вызывая EntityManager#flush(), пока выполняется транзакция, можно в любой
момент инициировать проверку состояния объектов и синхронизацию с базой
данных.
На этом мы завершим обсуждение временного, хранимого и удаленного состоя-
ний сущностей, а также основных применений интерфейса EntityManager. Пони-
мание переходов между состояниями и методов API очень важно; ни одно JPA-
приложение не обходится без этих операций.
Далее мы рассмотрим отсоединенное состояние сущности. Мы уже касались не-
которых проблем, возникающих при удалении связи между экземплярами сущно-
стей с контекстом хранения, таких как отключение отложенной инициализации.
Давайте рассмотрим отсоединенное состояние на нескольких примерах, чтобы вы
знали, чего ожидать во время работы с данными вне контекста хранения.
10.3. Работа с отсоединенным состоянием
Ссылку, покинувшую область гарантированной идентичности, мы называем ссыл-
кой на экземпляр отсоединенной сущности. После закрытия контекст хранения
больше не обеспечивает отображения идентичности. При работе с отсоединенны-
ми экземплярами сущностей вы столкнетесь с проблемой псевдонимов (aliasing),
поэтому вы должны понимать, как работать с идентичностями отсоединенных эк-
земпляров.
10.3.1. Идентичность отсоединенных экземпляров
Если выполнить поиск данных, используя один и тот же идентификатор в базе
данных в одном контексте хранения, в результате получатся две ссылки на один
объект в памяти JVM. Далее показано выполнение двух единиц работы.
Отключение сохранения контекста
перед выполнением запроса
 Получение имени
экземпляра
290  Управление данными
Листинг 10.2  Области гарантированной идентичности объектов в Java
Persistence
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
tx.begin();  Создание контекста хранения
em = JPA.createEntityManager();  Загрузка экземпляров сущностей
Item a = em.find(Item.class, ITEM_ID);
Item b = em.find(Item.class, ITEM_ID);
assertTrue(a == b);  Объекты a и b идентичны
assertTrue(a.equals(b));  Ссылки a и b равны
assertEquals(a.getId(), b.getId());  a и b обладают одной идентичностью в базе данных
tx.commit();  Подтверждение транзакции
em.close();  Закрытие контекста хранения
tx.begin();
em = JPA.createEntityManager();
Item c = em.find(Item.class, ITEM_ID);
assertTrue(a != c);  Ссылки a и c не идентичны
assertFalse(a.equals(c));  Ссылки a и c не равны
assertEquals(a.getId(), c.getId());  Идентичность в базе данных остается истинной
tx.commit();
em.close();
В первой единице работы, начинающейся с вызова begin() , создается контекст
хранения  и загружается несколько экземпляров сущностей. Поскольку ссылки a
и b получены из одного контекста, в Java они будут идентичными . Они также будут
равны , так как по умолчнию метод equals() полагается на сравнение идентично-
стей в Java. Очевидно, что у них одна идентичность в базе данных . Они ссылаются
на один хранимый экземпляр Item, управляемый контекстом хранения в рамках этой
единицы работы. Первая часть этого примера завершается подтверждением транзакции
 и закрытием контекста хранения . После закрытия первого контекста
ссылки a и b будут находиться в отсоединенном состоянии. Работа продолжится с эк-
земплярами, существующими вне области гарантированной идентичности объектов.
Легко видеть, что ссылки a и c, загруженные в разных контекстах хранения, не-
идентичны . Проверка на равенство с помощью a.equals(c) дает результат false
. Проверка на идентичность в базе данных по-прежнему возвращает true . Та-
кое поведение может создавать проблемы, если рассматривать экземпляры сущно-
стей в отсоединенном состоянии как равные. Рассмотрим, к примеру, следующий
фрагмент, добавленный после окончания второй единицы работы:
em.close();
Set<Item> allItems = new HashSet<>();
allItems.add(a);
allItems.add(b);
allItems.add(c);
assertEquals(allItems.size(), 2); Выглядит как произвольный и неверный результат
Интерфейс EntityManager  291
В этом примере все три ссылки помещаются в коллекцию Set. Все они ссыла-
ются на отсоединенные экземпляры. Если теперь проверить размер коллекции –
количество элементов, какой будет результат?
Множество Set не позволяет хранить повторяющиеся элементы. Они обнару-
живаются коллекцией Set; при попытке добавить ссылку тут же автоматически
выполнится метод Item#equals() для сравнения со всеми элементами в коллек-
ции. Если для какого-нибудь элемента equals() вернет true, добавления не про-
изойдет.
По умолчанию все классы Java наследуют реализацию метода equals() от java.
lang.Object. Для проверки ссылок на экземпляры в Java-куче эта реализация ис-
пользует оператор равенства (==).
Можно догадаться, что в коллекции окажутся два элемента. Все-таки a и b
ссылаются на один экземпляр в памяти; они были загружены в один контекст
хранения. Ссылка c получена из другого контекста; она указывает на другой
экземпляр в куче. Всего в примере имеются три ссылки на два экземпляра, но
мы знаем это лишь потому, что видели код загрузки данных. В реальном при-
ложении может быть неизвестно, что a и b загружены в контекст, отличный от
контекста c. Кроме того, кто-то из вас мог бы ожидать, что в коллекции окажется
один элемент, поскольку a, b и c представляют одну запись в базе данных, один
экземпляр Item.
Каждый раз, когда приходится работать с экземплярами в отсоединенном со-
стоянии и проверять их равенство (обычно в коллекциях, основанных на значениях
хэша), определяйте свою реализацию методов equals() и hashCode() для отображаемых
классов сущностей. Это важный нюанс: если не приходится работать
с экземплярами сущностей в отсоединенном состоянии, никаких действий пред-
принимать не нужно, и реализация equals() по умолчанию в классе java.lang.Object
вполне подойдет. Вы полагаетесь на область гарантированной идентичности
объектов внутри контекста хранения, предоставляемую Hibernate. Даже если вы
работаете с отсоединенными экземплярами, но не проверяете их равенство, не по-
мещаете в коллекцию Set и не используете как ключи словаря Map, вам не о чем
беспокоиться. Если вы просто отображаете экземпляр Item на экране, он не будет
ни с чем сравниваться.
Большинство разработчиков, только начинающих работу с JPA, считает, что
они должны определить собственную реализацию проверки на равенство для
каждого класса сущности, но это не так. В разделе 18.3 мы покажем проект при-
ложения, использующий стратегию работы с расширенным контекстом хранения.
Эта стратегия также расширяет область гарантированной идентичности объектов,
распространяя ее на весь процесс диалогового взаимодействия с пользователем
и несколько системных транзакций. Заметьте, что по-прежнему не следует срав-
нивать отсоединенные экземпляры, полученные в контексте разных диалоговых
взаимодействий!
Предположим, что вы хотите использовать отсоединенные экземпляры и про-
верять их равенство, используя собственный метод.
292  Управление данными
10.3.2. Реализация метода проверки равенства
Реализовать методы equals() и hashCode() можно разными способами. Но помни-
те, что, переопределяя equals(), обязательно следует переопределить hashCode(),
чтобы они вели себя согласованно. Если два экземпляра равны, они должны иметь
одинаковые значения хэша.
Кажется, что в equals() достаточно было бы сравнивать только свойства идентифи-
каторов в базе данных, как правило, представляющих суррогатные первичные клю-
чи. По сути, если два экземпляра Item имеют одинаковое значение идентификатора,
возвращаемое методом getId(), они представляют одну сущность. Если метод getId()
возвращает null, это временный экземпляр Item, который еще не был сохранен.
К сожалению, это решение имеет один большой недостаток – Hibernate не при-
сваивает идентификаторов, пока экземпляры не станут хранимыми. Если перед
сохранением добавить временный экземпляр в коллекцию Set, после сохранения
его хэш изменится, пока он все еще будет находиться в коллекции Set. Это про-
тиворечит контракту коллекции java.util.Set и нарушит ее работу. В частности,
из-за этой проблемы становится бесполезным использование каскадной передачи
хранимого состояния в отображаемых связях на основе множеств. Мы выступаем
решительно против использования равенства идентификаторов в базе данных.
Чтобы подобраться к решению, мы советуем познакомиться с понятием бизнес-
ключа. Бизнес-ключ – это свойство или их комбинация, уникальное для каждого
экземпляра с одинаковым идентификатором в базе данных. По сути, это естествен-
ный ключ, который можно было бы использовать взамен суррогатного первичного
ключа. В отличие от естественного первичного ключа, к бизнес-ключу не предъяв-
ляется требование его неизменности – достаточно и того, чтобы он изменялся редко.
Мы утверждаем, что практически каждый класс сущности должен обладать
бизнес-ключом, даже если он включает в себя все свойства этого класса (что впол-
не подходит для некоторых неизменяемых классов). По каким признакам ваши
пользователи будут различать A, B и C в списке товаров на экране? Это свойство
или их комбинация и будет вашим бизнес-ключом. Бизнес-ключ – это то, что по
мнению пользователя уникально идентифицирует конкретную запись, тогда как
суррогатный ключ – это то, на что полагаются приложение и СУБД. Наиболее
вероятно, что свойство или свойства, составляющие бизнес-ключ, будут иметь
в схеме базы данных ограничение UNIQUE.
Давайте создадим собственные методы проверки равенства для класса сущ-
ности User; это проще, чем сравнение экземпляров Item. В случае класса User на
роль бизнес-ключа идеально подходит свойство username. Это обязательное поле,
имеющее ограничение уникальности в базе данных, которое меняется редко (если
меняется вообще).
Листинг 10.3  Собственный метод определения равенства объектов User
@Entity
@Table(name = "USERS",
uniqueConstraints =
@UniqueConstraint(columnNames = "USERNAME"))
Интерфейс EntityManager  293
public class User {
@Override
public boolean equals(Object other) {
if (this == other) return true;
if (other == null) return false;
if (!(other instanceof User)) return false; Используйте оператор instanceof
User that = (User) other;
return
this.getUsername().equals(that.getUsername()); Используйте методы чтения
}
@Override
public int hashCode() {
return getUsername().hashCode();
}
// ...
}
Вы, должно быть, заметили, что метод equals() всегда обращается к полям
«другого» объекта с помощью методов чтения. Это чрезвычайно важно, посколь-
ку ссылка other может оказаться прокси-объектом, а не обычным экземпляром,
несущим свое хранимое состояние. Нельзя напрямую обратиться к полю username
класса User через прокси-объект. Чтобы инициализировать прокси-объект для по-
лучения значения свойства, нужно обратиться к нему, используя метод чтения.
Это одна из ситуаций, когда применение Hibernate не является абсолютно про-
зрачным, но тем не менее использование методов чтения вместо непосредственно-
го обращения к переменным экземпляра является хорошей практикой.
Тип ссылки other следует проверять с помощью оператора instanceof, а не срав-
нением значений, возвращаемых методом getClass(). Опять же, ссылка other мо-
жет оказаться прокси-объектом, представляющим экземпляр сгенерированного
во время выполнения подкласса User, поэтому типы this и other могут оказать-
ся разными, но при этом находиться в отношении супертип/подтип. Вы можете
узнатьбольше
о прокси-объектах в разделе 12.1.1.
Теперь вы можете без проблем сравнивать объекты User, находящиеся в храни-
мом состоянии:
tx.begin();
em = JPA.createEntityManager();
User a = em.find(User.class, USER_ID);
User b = em.find(User.class, USER_ID);
assertTrue(a == b);
assertTrue(a.equals(b));
assertEquals(a.getId(), b.getId());
tx.commit();
em.close();
294  Управление данными
Кроме того, вы получаете корректное поведение при сравнении ссылок на хра-
нимые и отсоединенные экземпляры:
tx.begin();
em = JPA.createEntityManager();
User c = em.find(User.class, USER_ID);
assertFalse(a == c); Значение, конечно же, все еще false
assertTrue(a.equals(c)); Теперь true
assertEquals(a.getId(), c.getId());
tx.commit();
em.close();
Set<User> allUsers = new HashSet();
allUsers.add(a);
allUsers.add(b);
allUsers.add(c);
assertEquals(allUsers.size(), 1); Правильно!
Для других сущностей бизнес-ключ может быть более сложным и состоять из
комбинации свойств. Вот несколько советов, которые помогут вам в выявлении
бизнес-ключей классов предметной модели.
 Посмотрите, по каким атрибутам пользователи вашего приложения иден-
тифицируют объекты (в реальном мире). Как пользователи отличают один
элемент от другого, когда они отображаются на экране? Возможно, это и бу-
дет искомым бизнес-ключом.
 Каждый неизменяемый атрибут является потенциальным кандидатом на
роль бизнес-ключа. Изменяемые атрибуты тоже могут быть хорошими кан-
дидатами, если они редко изменяются или если их изменение находится под
вашим контролем и вы можете гарантировать, что в момент изменения ни
один экземпляр не находится в коллекции Set.
 Каждый атрибут, имеющий в базе данных ограничение UNIQUE, является
потенциальным кандидатом на роль бизнес-ключа. Помните, что точность
бизнес-ключа должна быть достаточной для предотвращения коллизий.
 Любой атрибут, основанный на значении времени, такой как метка времени
создания записи, обычно является хорошим компонентом бизнес-ключа,
но погрешность метода System.currentTimeMillis() зависит от виртуальной
машины и операционной системы. Мы рекомендуем буфер безопасности
длиной в 50 миллисекунд, что может быть недостаточно точным, если атри-
бут, основанный на значении времени, является единственным атрибутом
бизнес-ключа.
 Как часть бизнес-ключа можно использовать идентификатор в базе данных.
Кажется, что это противоречит нашему предыдущему утверждению, но мы
говорим не о значении идентификатора данной сущности, а об идентифика-
торе связанного экземпляра сущности. Например, потенциальным бизнес-
ключом класса Bid (ставка) является идентификатор объекта Item (товар),
Интерфейс EntityManager  295
связанного со ставкой. Вы даже можете добавить ограничение уникаль-
ности, представляющее этот составной бизнес-ключ в схеме базы данных.
Идентификатор связанного объекта Item никогда не изменится в течение
жизненного цикла объекта Bid: конструктор класса Bid может требовать
передачи объекта Item, уже находящегося в хранимом состоянии.
Если вы последуете нашему совету, у вас не должно возникнуть сложностей
в выявлении хороших бизнес-ключей для всех классов, относящихся к бизнес-ло-
гике. Если вы столкнетесь со сложным случаем, попробуйте решить проблему без
Hibernate. В конце концов, это лишь объектно-ориентированная проблема. Об-
ратите внимание, что практически всегда будет ошибкой переопределять метод
equals() в подклассах и добавлять в процедуру сравнения другие свойства. В по-
добном случае будет непросто удовлетворить требования к идентичности клас-
са Object и равенству, которое должно быть в данном случае и симметричным,
и транзитивным; и что важнее, на роль бизнес-ключа может не подойти ни один
из кандидатов на естественные ключи в базе данных (свойства подкласса могут
отображаться в другую таблицу). Чтобы узнать больше о реализации собственных
методов сравнения, прочтите книгу Джошуа Блоха Effective Java, 2-е издание1,
обязательную для каждого программиста на Java.
Теперь класс User подготовлен для работы в отсоединенном состоянии: вы мо-
жете спокойно помещать в коллекцию Set экземпляры, загруженные в разных
контекстах хранения. Далее мы рассмотрим несколько примеров, связанных с от-
соединенным состоянием, и вы увидите несколько преимуществ этой идеи.
Иногда может понадобиться вручную отсоединить экземпляр сущности от кон-
текста хранения.
10.3.3. Отсоединение экземпляров сущностей
Не обязательно ждать закрытия контекста хранения. Экземпляры сущности мож-
но отсоединять вручную:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
User user = em.find(User.class, USER_ID);
em.detach(user);
assertFalse(em.contains(user));
Этот пример также демонстрирует операцию EntityManager#contains(), возвра-
щающую true, если данный экземпляр находится в хранимом состоянии и управ-
ляется данным контекстом хранения.
Теперь можно работать со ссылкой user в отсоединенном состоянии. Многие
приложения только читают данные и выводят их на экран после закрытия контекста
хранения.
1 Блох Д. Java. Эффективное программирование. 2-е изд. ISBN: 978-5-85582-348-6. Лори,
2016. – Прим. ред.
296  Управление данными
Модификация загруженного пользователя (user) после закрытия контекста
хранения не окажет никакого влияния на его представление в базе данных. Тем не
менее JPA позволяет перенести изменения в базу данных уже в новом контексте
хранения.
10.3.4. Слияние экземпляров сущностей
Предположим, что вы извлекли экземпляр User в предыдущем контексте хране-
ния, а теперь хотите его изменить и сохранить:
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
detachedUser.setUsername("johndoe");
tx.begin();
em = JPA.createEntityManager();
User mergedUser = em.merge(detachedUser);
mergedUser.setUsername("doejohn");
tx.commit(); Выполнение операции UPDATE в базе данных
em.close();
Рассмотрим графическое представление этого процесса (рис. 10.5). Это не так
сложно, как кажется.
Рис. 10.5  Перемещение экземпляра в хранимое состояние
в рамках единицы работы
Цель состоит в том, чтобы записать новое значение свойства username отсоеди-
ненного экземпляра User. Сначала, во время вызова merge(), Hibernate сравнит
идентификаторы хранимого экземпляра из контекста хранения и отсоединенного
экземпляра, с которым выполняется слияние.
В этом примере контекст хранения пуст; из базы данных ничего не было за-
гружено. Поэтому Hibernate загрузит экземпляр с этим идентификатором из базы
данных. Затем метод merge() скопирует отсоединенный экземпляр сущности по-
верх загруженного хранимого экземпляра. Другими словами, новое значение поля
username, присвоенное отсоединенному объекту User, так же будет присвоено хра-
нимому объекту User, который вернет метод merge() после слияния.
Ссылка detachedUser после слияния
больше не нужна. mergedUser
находится в хранимом состоянии
Интерфейс EntityManager  297
Теперь избавьтесь от ссылки на устаревшее и неактуальное отсоединенное со-
стояние; ссылка detachedUser больше не представляет актуального состояния. Вы
можете продолжить модификацию полученного объекта mergedUser; Hibernate вы-
полнит единственную инструкцию UPDATE, когда будет выталкивать контекст хра-
нения во время подтверждения транзакции.
Если в контексте хранения не будет найден ни один хранимый экземпляр с та-
ким же идентификатором и поиск в базе данных по идентификатору не даст ре-
зультатов, Hibernate создаст новый объект User. Затем выполнит копирование от-
соединенного экземпляра поверх нового экземпляра и поместит его в базу данных
при синхронизации контекста хранения с базой данных.
Если экземпляр, переданный в метод merge(), является не отсоединенным,
а временным (у него отсутствует значение идентификатора), Hibernate создаст
новый объект User, скопирует поверх временный объект User, сделает его храни-
мым и вернет обратно. Проще говоря, операция merge() может работать с отсоеди-
ненными и временными экземплярами сущностей. Hibernate всегда возвращает
в результате хранимый экземпляр.
В архитектуре приложения, основанной на отсоединении и слиянии, можно не
вызывать операцию persist(). Для сохранения данных можно выполнять слияние
новых и отсоединенных экземпляров сущностей. Важное отличие заключается
в возвращаемом текущем состоянии и способе переключения ссылок в коде при-
ложения. Вы должны избавиться от ссылки detachedUser и после этого использо-
вать только ссылку на текущее состояние mergedUser. Все остальные компоненты
приложения, работающие со ссылкой detachedUser, должны переключиться на ис-
пользование ссылки mergedUser.
Можно ли переподключить отсоединенный экземпляр?
В Hibernate-интерфейсе Session имеется метод для повторного присоединения
saveOrUpdate(). Он принимает временный или отсоединенный экземпляр и ничего
не возвращает. После выполнения операции переданный экземпляр будет нахо-
диться в хранимом состоянии, поэтому переключать ссылки не нужно. Hibernate
выполнит инструкцию INSERT, если переданный экземпляр находился во времен-
ном состоянии, и UPDATE, если тот был отсоединен. Но вместо этого мы советуем
полагаться на операцию слияния, поскольку она стандартизована и поэтому легче
интегрируется с другими фреймворками. Кроме того, если отсоединенный экзем-
пляр не был изменен, вместо UPDATE операция слияния выполнит только инструк-
цию SELECT. Если вам интересно, метод saveOrUpdateCopy() интерфейса Session дела-
ет то же самое, что и merge() в EntityManager.
Если понадобится удалить отсоединенный экземпляр, сначала нужно выпол-
нить для него операцию слияния. Затем вызвать remove() для хранимого экзем-
пляра, возвращаемого методом merge().
Мы снова вернемся к обсуждению отсоединенного состояния и слияния в гла-
ве 18 и реализуем более сложное диалоговое взаимодействие между пользовате-
лем и системой, использующей эту стратегию.
298  Управление данными
10.4. Резюме
 Мы обсудили наиболее важные и некоторые дополнительные стратегии рабо-
ты с экземплярами сущностей в JPA-приложениях.
 Вы познакомились с жизненным циклом экземпляров сущностей и узнали,
как они становятся хранимыми, отсоединенными и удаленными.
 Самый важный интерфейс в JPA – это EntityManager.
 В большинстве приложений данные не сохраняются и не загружаются неза-
висимо. Как правило, Hibernate интегрируется в многопользовательское при-
ложение с конкурентным доступом к базе данных в нескольких потоках.
Глава 11
Транзакции
и многопоточность
В этой главе:
 основы определения системных транзакций и транзакций в базе данных;
 управление конкурентным доступом с помощью Hibernate и JPA;
 доступ к данным вне транзакции.
В этой главе мы, наконец, поговорим о транзакциях: как создавать единицы ра-
боты и управлять ими в многопоточном приложении. Единица работы – это ато-
марная группа операций. Транзакции позволяют определять границы единицы
работы и помогают изолировать одну единицу работы от другой. В многополь-
зовательском приложении также можно осуществлять параллельное выполнение
нескольких единиц работы.
Прежде чем приступить к обсуждению поддержки многопоточности, мы сна-
чала рассмотрим единицы работы на самом низком уровне – уровне системных
транзакций и транзакций в базе данных. Познакомимся с API разграничения
транзакций и способами определения единиц работы в коде на языке Java. По-
говорим об изолированности и управлении параллельным доступом с помощью
пессимистической и оптимистической стратегий.
В заключение мы рассмотрим некоторые специальные случаи и особенности
JPA, связанные с доступом к базе данных без явного применения транзакций. Но
для начала немного справочной информации.
Главные нововведения в JPA 2
• Добавлены новые режимы и исключения для работы с пессимистическими бло-
кировками.
• Возможность выбора пессимистического или оптимистического режима блоки-
ровки с помощью интерфейса Query.
• Возможность выбора режима блокировки в вызове EntityManager#find(), refresh()
или lock(). Также стандартизована подсказка о времени ожидания для режима
пессимистической блокировки.
300  Транзакции и многопоточность
• При возбуждении одного из новых исключений – QueryTimeoutException или LockTimeoutException
– можно не откатывать транзакцию.
• Контекст хранения теперь может находиться в рассинхронизированном состоя-
нии с отключенным автоматическим сохранением контекста. Это позволяет до-
бавлять изменения в очередь до присоединения к транзакции и отделить работу
с EntityManager от транзакций.
11.1. Основы транзакций
Приложения часто требуют, чтобы несколько операций выполнялось как единое
целое. Например, после завершения аукциона приложение CaveatEmptor должно
выполнить три разные операции:
1) найти самую большую ставку для продаваемого товара;
2) взыскать с продавца стоимость проведения аукциона;
3) оповестить продавца и выигравшего покупателя.
Что случится, если не получится оплатить стоимость аукциона из-за ошибки во
внешней системе для работы с кредитными картами? В бизнес-требованиях мо-
жет быть указано, что либо все указанные действия должны завершиться успеш-
но, либо ни одно из них. В таком случае эту совокупность задач можно назвать
транзакцией, или единицей работы. Если хоть одна задача не выполнится, выпол-
нение всей единицы работы должно окончиться неудачей.
11.1.1. Атрибуты ACID
Аббревиатура ACID расшифровывется как atomicity (атомарность), consistency (не-
противоречивость), isolation (изолированность), durability (долговечность). Ато-
марность означает, что все операции в рамках транзакции выполняются как единое
целое. Более того, транзакции позволяют нескольким пользователям параллельно
работать с одними и теми же данными, не нарушая требования непротиворечиво-
сти данных (соответствующих правилам целостности в базе данных). Конкрет-
ная транзакция не должна быть видима для других транзакций, выполняющихся
в это же время; они должны выполняться изолированно друг от друга. Изменения,
сделанные в рамках транзакции, должны стать постоянными, даже если в системе
произойдет сбой после успешного завершения транзакции.
Кроме того, транзакция должна быть корректной. Например, бизнес-правила
определяют, что приложение должно взимать оплату с продавца только один раз,
а не два. Это предположение разумно, но его невозможно выразить с помощью
ограничений базы данных. Поэтому за корректность транзакции отвечает прило-
жение, в то время как за непротиворечивость – база данных. Все вместе эти атри-
буты определяют критерий ACID.
11.1.2. Транзакции в базе данных и системные транзакции
Мы уже упоминали о транзакциях в системе и в базе данных. Посмотрите еще раз на
последний пример: во время выполнения единицы работы, завершающей аукцион,
Основы транзакций  301
мы можем определить самую большую ставку в базе данных. Затем, в рамках той же
самой единицы работы, обратиться к внешней системе для списания платы с кре-
дитной карты продавца. Эта транзакция охватывает несколько (под)систем с управ-
ляемыми подчиненными транзакциями, возможно охватывающими несколько ре-
сурсов, таких как соединение с базой данных и внешняя платежная служба.
Транзакции в базах данных должны быть короткими, поскольку открытые
транзакции
потребляют ресурсы базы данных и потенциально могут ограничивать
параллельный доступ из-за монопольных блокировок данных. Одна транзакция
в базе данных, как правило, включает только один набор операций с базой данных.
Для выполнения всех операций в базе данных внутри системной транзакции
необходимо определить границы конкретной единицы работы. Вы должны за-
пустить транзакцию, а затем в какой-то момент подвердить изменения. Если
произойдет ошибка (во время выполнения операции с базой данных или под-
тверждения транзакции), изменения следует откатить, чтобы данные остались
в непротиворечивом состоянии. Этот процесс называется определением границ
транзакции и в зависимости от используемого подхода может потребовать ручно-
го управления. В целом границы, отмечающие начало и конец транзакции, могут
задаваться как программно, так и декларативно.
11.1.3. Программные транзакции с JTA
В окружении Java SE границы транзакций определяются с помощью JDBC API.
Транзакция начинается с вызова метода setAutoCommit(false) JDBC-объекта Connection,
а завершается вызовом commit(). Все изменения можно откатить в любой
момент вызовом метода rollback().
В приложении, управляющем данными из нескольких систем, конкретная еди-
ница работы может обращаться к нескольким транзакционным ресурсам. В таком
случае нельзя обеспечить атомарность только с помощью JDBC. Вам потребуется
диспетчер транзакций, способный взаимодействовать с несколькими ресурсами
в рамках одной системной транзакции. JTA стандартизирует управление систем-
ными и распределенными транзакциями, поэтому вам не нужно сильно бес-
покоиться о низкоуровневых деталях. Главным в JTA является интерфейс User-
Transaction с методами begin() и commit(), запускающими и подтверждающими
транзакции соответственно.
Прочие интерфейсы для определения границ транзакции
JTA поддерживает прекрасную абстракцию системы транзакций основных ресур-
сов, включающую также управление распределенными системными транзакциями.
Большинство разработчиков полагает, что JTA можно применять только при
работе с компонентами, работающими на сервере приложений Java EE. На сегод-
няшний день доступны независимые высококачественные реализации JTA, такие
как Bitronix (используется в коде примеров) и Atomikos, которые легко устанавли-
ваются в любом окружении Java. Эти решения можно считать пулами соединений
с базой данных, работающими с JTA.
302  Транзакции и многопоточность
Вы должны использовать JTA, когда только возможно, и избегать нестандартных
транзакционных API, таких как org.hibernate.Transaction, или очень ограниченного
javax.persistence.EntityTransaction. Эти интерфейсы создавались во времена, ког-
да JTA не мог полноценно работать вне среды выполнения контейнера EJB.
В разделе 10.2.1 мы обещали снова вернуться к транзакциям, уделив особое
внимание обработке исключений. Ниже представлен полный код, включающий
откат транзакций и обработку исключений.
Листинг 11.1  Типичная единица работы с границами транзакции
Файл: /examples/src/test/java/org/jpwh/test/simple/SimpleTransitions.java
EntityManager em = null;
UserTransaction tx = TM.getUserTransaction();
try {
tx.begin();
em = JPA.createEntityManager(); Управляется приложением
// ...
tx.commit(); Синхронизирует/выталкивает контекст хранения
} catch (Exception ex) {
try { Откат транзакции; обработка исключений
if (tx.getStatus() == Status.STATUS_ACTIVE
|| tx.getStatus() == Status.STATUS_MARKED_ROLLBACK)
tx.rollback();
} catch (Exception rbEx) {
System.err.println("Rollback of transaction failed, trace follows!");
rbEx.printStackTrace(System.err);
}
throw new RuntimeException(ex);
} finally {
if (em != null && em.isOpen())
em.close(); Вы его создали, вы и закрывайте!
}
Самым сложным в этом примере является код обработки исключений; мы об-
судим его чуть ниже, а сейчас разберемся, как взаимодействуют механизм управ-
ления транзакциями и EntityManager.
EntityManager использует стратегию отложенного выполнения; в предыдущей
главе мы упоминали, что он не получает ни одного соединения с базой данных,
пока не потребуется выполнить выражение SQL. То же самое верно для JTA: стоимость
запуска и подтверждения транзакции окажется невысокой, если не об-
ращаться ни к одному транзакционному ресурсу. Например, на сервере можно
выполнить пустую единицу работы для каждого клиента, не потребляя никаких
ресурсов и не удерживая блокировок в базе данных.
В момент создания объект EntityManager ищет внутри текущего потока выпол-
нения незавершенную системную транзакцию JTA. Обнаружив ее, он присоеди-
Основы транзакций  303
няется к ней и начинает отслеживать события транзакции. Это означает, что вы
всегда должны вызывать UserTransaction#begin() и EntityManagerFactory#createE
ntityManager() в одном потоке, если хотите, чтобы они соединились. Как мы уже
объяснили в главе 10, по умолчанию Hibernate автоматически выталкивает кон-
текст хранения во время подтверждения транзакции.
Если во время создания EntityManager не смог найти незавершенную транзак-
цию в том же потоке, он окажется в особом рассинхронизированном режиме. В этом
режиме JPA не будет выталкивать контекст хранения автоматически. Позже мы
еще поговорим об этом поведении; данная особенность JPA удобна для проектиро-
вания более сложных диалоговых взаимодействий.
Часто задаваемые вопросы: Правда ли, что транзакция с доступом
только на чтение откатывается быстрее?
Если код в транзакции читает данные, но не изменяет их, можно ли просто отка-
тить транзакцию вместо ее подтверждения? Будет ли такой код выполняться быстрее?
Действительно, некоторые разработчики обнаружили, что при определен-
ных условиях такой прием работает быстрее, и это убеждение распространилось
среди сообщества. Мы проверяли это поведение на наиболее популярных СУБД
и не нашли отличий. Также мы не нашли ни одного источника, подтверждающего
различие в производительности. Нет причин использовать в СУБД неоптимальную
реализацию операции завершения, которые требовали бы использовать не самый
быстрый механизм завершения транзакции.
Всегда подтверждайте транзакции, а если подтверждение завершилось неудачей,
откатывайте. Тем не менее в стандарте SQL есть выражение SET TRANSACTION READ
ONLY. Мы советуем сначала узнать, поддерживает ли его ваша база данных и есть
ли хоть какие-то преимущества с точки зрения производительности.
Диспетчер транзакций прервет транзакцию, если она выполняется слишком
долго. Помните, что в нагруженной системе OLTP (оперативной обработки транзакций)
длительность транзакции в базе данных должна быть минимальной. Время
ожидания по умолчанию зависит от реализации JTA, например в Bitronix это 60 се-
кунд. Это значение можно изменить перед началом транзакции вызовом UserTran
saction#setTransactionTimeout().
Мы должны еще обсудить обработку исключений, показанную в предыдущем
примере.
11.1.4. Обработка исключений
Если обращение к экземпляру EntityManager или выталкивание контекста хра-
нения во время подтверждения транзакции вызовет исключение, проверьте те-
кущее состояние системной транзакции. В случае ошибки Hibernate отметит
транзакцию как требующую отмены. Это означает, что единственным результа-
том этой транзакции будет отмена всех сделанных изменений. Поскольку запустили
транзакцию вы, вы и должны проверить состояние STATUS_MARKED_ROLLBACK.
304  Транзакции и многопоточность
Транзакция также может находиться в состоянии STATUS_ACTIVE, если Hibernate
не смог отметить ее как требующую отмены. В обоих случаях нужно вызвать
UserTransaction#rollback(), чтобы предотвратить выполнение любых инструкций
SQL, которые могли быть отправлены в базу данных в рамках данной единицы
работы.
Любая операция JPA, включая выталкивание контекста хранения, способна воз-
будить исключение RuntimeException. Но такие методы, как UserTransaction#begin(),
commit() и даже rollback(), возбуждают контролируемое исключение Exception.
Исключение, возбуждаемое в случае отката транзакции, требует особого обраще-
ния: его нужно перехватить и записать в журнал; в противном случае исходное
исключение, вызвавшее откат, окажется потерянным. После отката транзакции
нужно повторно возбудить исходное исключение. Обычно в системе существует
другой уровень перехватчиков, который в итоге обработает исключение, отобра-
зив, например, экран с ошибкой или отправив сообщение команде технических
специалистов. Гораздо труднее правильно обработать ошибку, возникшую во
время отката транзакции; мы предлагаем записать ее в журнал и распространить
дальше, поскольку ошибка при откате транзакции указывает на серьезную систем-
ную проблему.
Особенности Hibernate
Hibernate возбуждает типизированные исключения, наследующие RuntimeException,
которые могут помочь в определении ошибки:
 наиболее общим типом является HibernateException. Нужно либо проверить
сообщение об ошибке, либо выяснить причину, вызвав метод getCause()
объекта-исключения;
 JDBCException представляет исключения, возбуждаемые внутренним слоем
JDBC в Hibernate. Этот тип исключения всегда возникает из-за конкретного
выражения SQL и позволяет получить выражение, вызвавшее ошибку, с по-
мощью getSQL(). Информацию о внутреннем исключении, возбуждаемом
соединением JDBC (драйвером JDBC), можно получить с помощью методов
getSQLException() или getCause(), а код ошибки, характерный для базы дан-
ных и реализации, – с помощью getErrorCode();
 Hibernate включает подтипы JDBCException и внутренний конвертер для пре-
образования кодов ошибок конкретной реализации, возвращаемых драйве-
ром базы данных, в что-то более информативное. Встроенный конвертер
может создавать экземпляры JDBCConnectionException, SQLGrammarException,
LockAcquisitionException, DataException и ConstraintViolationException для
наиболее важных диалектов баз данных, поддерживаемых Hibernate. Вы
можете управлять диалектом своей базы данных или расширять его, а так-
же подключать SQLExceptionConverterFactory для настройки этого преобра-
зования.
Некоторые разработчики приходят в восторг от разнообразия хорошо дета-
лизированных типов исключений, поддерживаемых в Hibernate. Но это может
Основы транзакций  305
направить вас по ложному пути. К примеру, для целей валидации у вас может по-
явиться желание перехватить ConstraintViolationException. Если вы забыли при-
своить значение свойству Item#name, а его отображаемый столбец имеет ограниче-
ние NOT NULL, то при попытке вытолкнуть контекст хранения Hibernate возбудит
это исключение. Почему бы не перехватить его, показать сообщение об ошибке
(в зависимости от кода ошибки и текста сообщения) пользователям приложения
и дать им возможность исправить ошибку? Такой подход имеет два больших не-
достатка.
Во-первых, отправка непроверенных данных в базу, чтобы узнать, какие ока-
жутся неподходящими, является неверной стратегией для масштабируемых при-
ложений. Приложение должно обеспечивать хотя бы минимальную валидацию
данных. Во-вторых, исключения прерывают текущую единицу работы. Но это не
соответствует тому, как пользователи будут интерпретировать ошибку валида-
ции: они полагают, что все еще находятся внутри единицы работы. Обходить это
несоответствие в коде трудно и неудобно. Мы советуем использовать детализи-
рованные типы исключений для отображения более информативных сообщений
о (фатальных) ошибках, а не для валидации. Например, можно перехватить ConstraintViolationException
и вернуть экран с сообщением: «Ошибка приложения:
кто-то забыл проверить данные перед отправкой в базу. Пожалуйста, сообщите об
этом программистам». Для других исключений можно показывать общий экран
для отображения ошибок.
Подобное решение поможет вам во время разработки, а также любому инжене-
ру службы поддержки, который должен быстро определить, является ли это ошиб-
кой приложения (нарушение ограничений, выполнение неправильного кода SQL),
или же СУБД находится под нагрузкой (невозможно получить блокировки). Для
валидации у вас имеется универсальный фреймворк Bean Validation. Следуя еди-
ному набору правил, заданному с помощью аннотаций, Hibernate сможет прове-
рить все ограничения предметной области и для конкретных записей на уровне
пользовательского интерфейса, а также автоматически сгенерировать правила
SQL DDL.
Теперь вы знаете, какие исключения перехватывать и где их ожидать. Возможно,
вы задаете себе вопрос: что делать после перехвата исключения и отката системной
транзакции? Исключения, возбуждаемые фреймворком Hibernate, фатальны. Это
значит, что текущий контекст хранения нужно закрыть. Вам запрещается рабо-
тать с экземпляром EntityManager, возбудившим исключение. Отобразите экран
с ошибкой и/или запишите ошибку в журнал, а затем дайте пользователю возмож-
ность повторно начать диалоговое взаимодействие с системой, используя новую
транзакцию и контекст хранения.
Но, как обычно, это еще не полная картина. Некоторые стандартизованные ис-
ключения не являются фатальными:
 javax.persistence.NoResultException – возбуждается, когда Query (запрос)
или TypedQuery (типизированный запрос) выполняется вызовом метода
getSingleResult(), а база данных не возвращает никаких результатов. Вызов
306  Транзакции и многопоточность
метода можно завернуть в код обработки исключений и продолжить работу
с контекстом хранения. Текущая транзакция не будет отмечена как требующая
отмены;
 javax.persistence.NonUniqueResultException – возбуждается, когда Query
или TypedQuery выполняется вызовом getSingleResult(), а база данных воз-
вращает несколько результатов. Вызов метода можно завернуть в код обра-
ботки исключений и продолжить работу с контекстом хранения. Hibernate
не будет отмечать текущую транзакцию как требующую отмены;
 javax.persistence.QueryTimeoutException – возбуждается, когда запрос Query
или TypedQuery выполняется слишком долго. Текущая транзакция не отме-
чается как требующая отмены. Можно попробовать снова выполнить за-
прос, если это уместно;
 javax.persistence.LockTimeoutException – возбуждается, когда пессимисти-
ческая блокировка не может быть получена. Это может произойти во время
выталкивания контекста или явной установки блокировки (подробнее об
этом рассказывается далее). Транзакция не отмечается как требующая отме-
ны, и можно попытаться повторить операцию. Но помните, что частые обра-
щения к базе данных, которая и так не справляется с нагрузкой, не улучшат
ситуацию.
В этом списке отсутствует javax.persistence.EntityNotFoundException. Это ис-
ключение могут возбуждать методы EntityManager#getReference() и refresh(),
а также lock(), с которыми вы познакомитесь далее в этой главе. Hibernate может
возбудить его при попытке обратиться к ссылке (прокси-объекту) на экземпляр
сущности, когда соответствующая запись в базе данных более недоступна. Это
фатальное исключение: оно отмечает текущую транзакцию как требующую отме-
ны – вы должны закрыть контекст хранения и избавиться от него.
Для программного определения границ транзакции требуется написать код,
использующий специализированный интерфейс, такой как UserTransaction из
JTA. Декларативное определение границ, напротив, не требует дополнительного
кода.