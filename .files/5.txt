5.1.1. Переопределение настроек по умолчанию
для свойств основных типов
Иногда не требуется делать хранимыми все свойства класса сущности. Например,
определенно имеет смысл сделать хранимым свойство Item#initialPrice, но свой-
ство Item#totalPriceIncludingTax не должно быть хранимым, потому что его зна-
чение вычисляется и используется только во время выполнения и, следовательно,
не должно сохраняться в базе данных.
Отображение полей основных типов  113
Чтобы исключить свойство, отметьте поле или его метод чтения аннотацией
@java.persistence.Transient или используйте ключевое слово transient. Обычно
ключевое слово transient исключает поля только при сериализации в Java, но оно
также распознается реализациями JPA.
Мы вернемся к аннотированию полей классов или методов чтения через ми-
нуту. А пока давайте, как и ранее, предположим, что Hibernate будет обращать-
ся к полям класса напрямую из-за наличия аннотации @Id над некоторым полем
класса. То есть все остальные аннотации отображения JPA и Hibernate также рас-
полагаются над полями класса.
Если вы не хотите полагаться на отображение свойств по умолчанию, примени-
те к конкретному свойству аннотацию @Basic – например, к свойству InitialPrice
класса Item:
@Basic(optional = false)
BigDecimal initialPrice;
Следует признать, что от этой аннотации мало пользы. У нее только два па-
раметра: тот, что показан здесь, optional, отмечает свойство как необязательное
на уровне Java-объекта. По умолчанию все хранимые свойства необязательны
и могут иметь значение null: у товара (Item) может быть неизвестна начальная
цена (initialPrice). Отображение свойства initialPrice как обязательного имеет
смысл, если столбец INITIALPRICE имеет ограничение NOT NULL в схеме SQL. При
создании SQL-схемы Hibernate автоматически добавит ограничение NOT NULL для
каждого обязательного поля.
Если теперь попробовать сохранить экземпляр Item, забыв присвоить зна-
чение свойству initialPrice, Hibernate возбудит исключение еще до того, как
попытается выполнить SQL-запрос в базе данных. Hibernate знает, что для вы-
полнения операций INSERT или UPDATE требуется значение. Если вы не отметили
поле как обязательное и попробуете сохранить NULL, база данных отклонит SQL-
инструкцию и Hibernate возбудит исключение нарушения ограничений. Разница
в конечном итоге несущественная, но лучше избегать обращения к базе данных
с инструкцией, которая заведомо не сработает. Другой параметр аннотации @Basic
– fetch – мы обсудим позже, когда будем разбирать стратегии оптимизации
в разделе 12.1.
Чтобы объявить о возможности присвоить значение null, большинство инжене-
ров вместо аннотации @Basic использует более универсальную аннотацию @Column:
@Column(nullable = false)
BigDecimal initialPrice;
Мы показали вам три способа объявления обязательного наличия значения
в свойстве: с использованием аннотации @Basic, аннотации @Column и при помощи
аннотации @NotNull из спецификации Bean Validation, представленной в разде-
ле 3.3.2. Все они влияют на реализацию JPA одинаково: Hibernate делает проверку
на null при сохранении и генерирует ограничение NOT NULL в схеме базы данных.
Мы рекомендуем использовать аннотацию @NotNull из спецификации Bean Valida114
 Отображение типов-значений
tion, чтобы можно было вручную проверять экземпляр класса Item и/или чтобы
код интерфейса на уровне представления мог автоматически осуществлять вали-
дацию.
С помощью аннотации @Column также можно переопределить имя столбца в базе
данных:
@Column(name = "START_PRICE", nullable = false)
BigDecimal initialPrice;
Аннотация @Column имеет еще несколько параметров, большинство из которых
управляет такими аспектами уровня SQL, как имя каталога и схемы. Они редко ис-
пользуются, и мы будем демонстрировать их только при необходимости.
Аннотации свойств не всегда располагаются над полями, и вам, возможно, не
хочется, чтобы Hibernate обращался к полям напрямую.
5.1.2. Настройка доступа к свойствам
Механизм хранения обращается к свойствам класса либо напрямую, через поля,
либо косвенно, через методы доступа. Для аннотированной сущности использует-
ся доступ по умолчанию, в зависимости от местоположения обязательной анно-
тации @Id. Например, если поместить @Id над полем, а не над методом чтения, все
остальные аннотации отображения в этой сущности должны применяться к по-
лям. Аннотации никогда не размещаются над методами записи.
Стратегия доступа по умолчанию может применяться не только к единствен-
ному классу сущности. Любой встроенный класс, отмеченный аннотацией @Embedded,
наследует либо стратегию доступа по умолчанию, либо определенную явно
стратегию корневого класса-владельца. Мы рассмотрим встроенные компоненты
далее в этой главе. Кроме того, Hibernate обращается к любым свойствам с анно-
тацией @MappedSuperclass, используя либо стратегию доступа по умолчанию, либо
определенную явно стратегию отображаемого класса сущности. Наследование бу-
дет темой главы 6.
Спецификация JPA определяет аннотацию @Access для переопределения пове-
дения по умолчанию при помощи параметров AccessType.FIELD и AccessType.PROPERTY.
Если поместить аннотацию @Access на уровне класса/сущности, Hibernate
будет обращаться ко всем свойствам класса в соответствии с выбранной страте-
гией. После этого все аннотации отображения, включая @Id, должны помещаться
либо надо полями, либо над методами чтения соответственно.
Для переопределения стратегии доступа к отдельным свойствам можно исполь-
зовать аннотацию @Access. Давайте рассмотрим это на примере.
Листинг 5.1  Переопределение стратегии доступа для свойства name
Файл: /model/src/main/java/org/jpwh/model/advanced/Item.java
@Entity
public class Item {
@Id  Аннотация @Id находится над полем
Отображение полей основных типов  115
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@Access(AccessType.PROPERTY)  Переключает способ доступа к свойству во время выполнения
@Column(name = "ITEM_NAME") Аннотации должны находиться здесь!
protected String name;
public String getName() {  Вызывается при загрузке/сохранении
return name;
}
public void setName(String name) {
this.name =
!name.startsWith("AUCTION: ") ? "AUCTION: " + name : name;
}
}
 Для сущности Item по умолчанию используется прямой доступ к полям. Аннотация @Id
расположена над полем. (Чреватая опечатками строка ID_GENERATOR стала константой.)
 Параметр @Access(AccessType.PROPERTY) над полем name включает режим доступа к этому
конкретному свойству через методы чтения/записи.
 Во время загрузки и сохранения объектов Hibernate будет вызывать методы getName()
и setName().
Обратите внимание, что расположение других аннотаций отображения, таких
как @Column, не изменилось – изменился лишь способ доступа к экземплярам во
время выполнения.
Можно посмотреть на это с другой стороны: если для сущности по умолча-
нию (или явно) задан доступ к свойствам через методы чтения/записи, аннота-
ция @Access(AccessType.FIELD) над методом чтения заставит Hibernate обращать-
ся к полю напрямую. Вся остальная информация об отображении по-прежнему
должна располагаться над методом чтения, а не над полем.
Особенности Hibernate
Hibernate включает редко используемое расширение: тип доступа к свойству под
названием noop («no operations»). Звучит странно, но это позволяет ссылаться на
виртуальные свойства в запросах. Это может пригодиться, когда в базе данных
есть столбец, который хотелось бы использовать только в запросах JPA. Напри-
мер, предположим, что в таблице ITEM есть столбец VALIDATED и ваше Hibernate-
приложение не должно обращаться к этому столбцу посредством предметной
модели. Это может быть столбец из унаследованной схемы или управляемый дру-
гим приложением или триггером в базе данных. Вам требуется, чтобы обращение
к этому столбцу было возможно только в JPA-запросах, таких как select i from Item
i where i.validated = true или select i.id, i.validated from Item i. В Java-классе Item
подобное поле отсутствует, как следствие для аннотации нет подходящего места.
Единственная возможность отображения такого виртуального поля – с помощью
оригинального файла метаданных hbm.xml:
116  Отображение типов-значений
<hibernate-mapping>
<class name="Item">
<id name="id">
...
</id>
<property name="validated"
column="VALIDATED"
access="noop"/>
</class>
</hibernate-mapping>
Это отображение сообщает Hibernate, что в запросах вы хотели бы получать
доступ к виртуальному полю Item#validated, отображаемому в столбец VALIDATED,
но чтобы во время выполнения операций с экземпляром Item не выполня-
лось никаких операций чтений/записи этого значения. В классе этот атрибут
отсутствует. Помните, что такой файл должен целиком и полностью определять
все параметры отображения – любые аннотации в классе Item будут игнориро-
ваться!
Если ни одна из встроенных стратегий доступа не подходит, можно определить
собственную, модифицированную стратегию доступа к свойствам, реализуя ин-
терфейс org.hibernate.property.PropertyAccessor. Включите настраиваемый до-
ступ с помощью квалифицированного имени в аннотации Hibernate: @org.hibernate.
annotations.AttributeAccessor("my.custom.Accessor"). Обратите внимание,
что аннотация AttributeAccessor появилась в Hibernate 4.3 как замена устарев-
шей org.hibernate.annotations.AccessType, которую было легко перепутать с JPA-
перечислением javax.persistence.AccessType.
Некоторые свойства не отображаются в столбцы. В частности, вычисляемым
свойствам присваиваются значения, получаемые из SQL-выражений.
Особенности Hibernate
5.1.3. Работа с вычисляемыми полями
Значение вычисляемого свойства – это результат SQL-выражения, объявленного
при помощи аннотации @org.hibernate.annotations.Formula; см. листинг 5.2.
Листинг 5.2  Два вычисляемых поля, доступных только для чтения
@org.hibernate.annotations.Formula(
"substr(DESCRIPTION, 1, 12) || ‘...’"
)
protected String shortDescription;
@org.hibernate.annotations.Formula(
"(select avg(b.AMOUNT) from BID b where b.ITEM_ID = ID)"
)
protected BigDecimal averageBidAmount;
Отображение полей основных типов  117
Приведенные SQL-формулы вычисляются каждый раз при загрузке сущности
Item из базы данных и ни в какое другое время, поэтому результат может оказаться
устаревшим, если другие поля изменятся. Эти поля никогда не участвуют в SQL-
операциях INSERT или UPDATE, только в SELECT. Вычисление происходит в базе дан-
ных; Hibernate добавляет SQL-формулу в предложение SELECT при загрузке эк-
земпляра.
Формулы могут ссылаться на столбцы таблицы базы данных, вызывать функ-
ции SQL и даже содержать подзапросы SQL. В предыдущем примере вызывается
функция SUBSTR(), а также используется оператор конкатенации ||. Выражение
SQL передается в базу данных как есть; не проявив должной осторожности, поло-
жившись на операторы или ключевые слова конкретной реализации, вы свяжете
отображение метаданных с конкретной базой данных. Обратите внимание, что не-
квалифицированные имена ссылаются на таблицу класса, которому принадлежит
вычисляемое поле.
База данных вычисляет SQL-выражения в формулах, только когда Hibernate
извлекает экземпляр сущности из базы данных. Hibernate также поддерживает
разновидность формул, называемую преобразователями столбцов (column transformers),
которые позволяют использовать произвольное SQL-выражение для
чтения и записи значения свойства.
Особенности Hibernate
5.1.4. Преобразование значений столбцов
Предположим, что в базе данных есть столбец с именем IMPERIALWEIGHT, в кото-
ром хранится вес товара (Item) в фунтах. В приложении, однако, имеется свойство
Item#metricWeight, отражающее вес в килограммах, поэтому приходится преобра-
зовывать значение столбца базы данных при чтении и при записи строки в табли-
цу ITEM. Эту операцию можно реализовать с помощью расширения Hibernate – ан-
нотации @org.hibernate.annotations.ColumnTransformer.
Листинг 5.3  Преобразование значений столбца с помощью SQL-выражений
@Column(name = "IMPERIALWEIGHT")
@org.hibernate.annotations.ColumnTransformer(
read = "IMPERIALWEIGHT / 2.20462",
write = "? * 2.20462"
)
protected double metricWeight;
При чтении записи из таблицы ITEM Hibernate использует выражение IMPERIALWEIGHT
/ 2.20462, следовательно, вычисление будет выполнено в базе данных,
и в итоге Hibernate вернет уровню приложения значение в метрической систе-
ме. Перед записью в столбец Hibernate подставит метрическое значение на место
единственного обязательного параметра (знака вопроса), и выражение SQL вы-
числит действительное значение для вставки или изменения.
118  Отображение типов-значений
Hibernate также применяет преобразователи столбцов в ограничениях запросов.
К примеру, следующий запрос извлекает все объекты с весом в два килограмма:
List<Item> result =
em.createQuery("select i from Item i where i.metricWeight = :w")
.setParameter("w", 2.0)
.getResultList();
В действительности SQL, который Hibernate применит для этого запроса, будет
содержать следующее ограничение в предложении WHERE:
// ...
where
i.IMPERIALWEIGHT / 2.20462=?
Обратите внимание, что для этого ограничения база данных, скорее всего, не
сможет использовать индекс, в результате произойдет полное сканирование таблицы,
потому что для проверки ограничения вес должен быть рассчитан в каждой
записи таблицы ITEM.
Есть другой, особый тип поля, который полагается на значения, сформирован-
ные базой данных.
Особенности Hibernate
5.1.5. Значения свойств, генерируемые по умолчанию
Иногда значения свойств генерирует база данных – как правило, при вставке стро-
ки. Примерами таких значений являются отметки времени создания, цена товара
по умолчанию, а также триггер, срабатывающий при каждом изменении.
Обычно приложения Hiberante должны обновлять экземпляры, содержащие
любые свойства, которым база данных присваивает значения после сохранения. То
есть чтобы прочитать значение после вставки или изменения записи, необходимо
повторно обратиться к базе данных. Но если отметить свойства как генерируемые
базой данных, приложение переложит эту работу на Hibernate. По сути, каждый
раз, когда Hibernate выполняет SQL-выражение INSERT или UPDATE для сущности
с генерируемыми свойствами, он тотчас же после этого выполняет SELECT для по-
лучения их значений.
Генерируемые свойства отмечаются аннотацией @org.hibernate.annotations.
Generated.
Листинг 5.4  Генерирование значений свойств на уровне базы данных
@Temporal(TemporalType.TIMESTAMP)
@Column(insertable = false, updatable = false)
@org.hibernate.annotations.Generated(
org.hibernate.annotations.GenerationTime.ALWAYS
)
protected Date lastModified;
Отображение полей основных типов  119
@Column(insertable = false)
@org.hibernate.annotations.ColumnDefault("1.00")
@org.hibernate.annotations.Generated(
org.hibernate.annotations.GenerationTime.INSERT
)
protected BigDecimal initialPrice;
Аннотация GenerationTime имеет всего два параметра: ALWAYS и INSERT.
При выборе параметра ALWAYS Hibernate будет обновлять экземпляр сущности
после каждой SQL-операции UPDATE или INSERT. В примере предполагается, что
триггер базы данных поддерживает свойство lastModified в актуальном состоянии.
Свойство также должно быть отмечено как доступное только для чтения при по-
мощи параметров updatable и insertable аннотации @Column. Если обоим присвое-
но значение false, столбец, соответствующий этому свойству, никогда не появится
в выражениях INSERT и UPDATE: генерировать значение будет база данных.
При выборе GenerationTime.INSERT изменение производится только после SQL-
операции INSERT, чтобы извлечь из базы данных значение по умолчанию. Hibernate
также отобразит это поле как недоступное для операции вставки. Аннотация Hibernate
@ColumnDefault устанавливает значение столбца по умолчанию, когда Hibernate
экспортирует или формирует DDL схемы SQL.
Отметки времени, как правило, генерируются автоматически базой данных
или, как в предыдущем примере, приложением. Давайте поближе познакомимся
с аннотацией @Temporal, представленной в листинге 5.4.
5.1.6. Свойства для представления времени
Свойство lastModified в последнем примере имеет тип java.util.Date, и его значе-
ние генерируется триггером в базе данных при выполнении SQL-операции INSERT.
Спецификация JPA требует, чтобы свойства, представляющие время, отмечались
аннотацией @Temporal для более точного определения SQL-типов данных столбцов,
в которые происходит отображение. В Java для представления времени использу-
ются типы java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Time и java.
sql.Timestamp. Hibernate также поддерживает классы из пакета java.time, доступно-
го в JDK 8. (На самом деле аннотации не нужны, если к свойству применяется или
может применяться конвертер. Вы встретитесь с конвертерами позже в этой главе.)
В листинге 5.5 показан совместимый с JPA пример – типичное свойство с от-
меткой времени – «этот объект был создан тогда-то», – которое сохраняется еди-
ножды и больше не обновляется никогда.
Листинг 5.5  Свойство для представления времени, которое нужно отметить
аннотацией @Temporal
@Temporal(TemporalType.TIMESTAMP)
@Column(updatable = false)
@org.hibernate.annotations.CreationTimestamp
protected Date createdOn;
Спецификация JPA требует использовать
аннотацию @Temporal. Без нее Hibernate будет
использовать тип по умолчанию TIMESTAMP
120  Отображение типов-значений
// Java 8 API
// protected Instant reviewedOn;
Доступными вариантами TemporalType являются DATE, TIME и TIMESTAMP, указывающие,
какую часть значения времени следует сохранять в базе данных.
Особенности Hibernate
По умолчанию Hibernate выбирает TemporalType.TIMESTAMP, если аннотация @Temporal
отсутствует. Кроме того, мы отметили свойство Hibernate-аннотацией @CreationTimestamp.
Она напоминает аннотацию @Generated из предыдущего раздела,
вынуждая Hibernate автоматически генерировать значение поля. В этом случае
Hibernate присвоит свойству значение текущего времени перед вставкой экзем-
пляра сущности в базу данных. Еще одна похожая встроенная аннотация – @Update-
Timestamp. Кроме того, имеется возможность создавать и настраивать собственные
генераторы значений, работающие в приложении или базе данных. Ознакомьтесь
с аннотациями org.hibernate.annotations.GeneratorType и ValueGenerationType.
Другим особым типом свойств являются перечисления.
5.1.7. Отображение перечислений
Тип перечисления – это известная в языке Java идиома представления класса с по-
стоянным (небольшим) количеством неизменяемых экземпляров. В приложении
CaveatEmptor, например, можно было бы использовать следующее перечисление:
public enum AuctionType {
HIGHEST_BID,
LOWEST_BID,
FIXED_PRICE
}
Теперь каждому товару (Item) можно присвоить свой тип auctionType:
@NotNull
@Enumerated(EnumType.STRING) По умолчанию – ORDINAL
protected AuctionType auctionType = AuctionType.HIGHEST_BID;
В отсутствие аннотации @Enumerated Hibernate будет сохранять порядковый
(ORDINAL) номер значения. Таким образом, он сохранит 1 для HIGHEST_BID, 2 для
LOWEST_BID и 3 для FIXED_PRICE. Это довольно опасное поведение по умолчанию –
если вы внесете изменения в перечисление AuctionType, существующие значения
больше не будут отображаться на те же позиции. Следовательно, лучше выбрать
вариант EnumType.STRING – Hibernate сохранит строковое представление значения
перечисления.
На этом мы завершим обзор свойств основных типов и вариантов их отображе-
ния. К данному моменту мы рассмотрели типы свойств, предоставляемые JDK, та-
кие как String, Date и BigDecimal. В вашей модели предметной области могут быть
свои классы типов-значений, изображаемые на UML-диаграмме как композиции.
Отображение полей основных типов  121
5.2. Отображение встраиваемых компонентов
До сих пор все отображаемые классы предметной модели были классами сущно-
стей – каждый обладал собственной идентичностью и жизненным циклом. Тем
не менее между классами User и Address установлен особый вид ассоциации, как
показано на рис. 5.1.
username : String
lastname : String
User
street : String
zipcode : String
city : String
home Address
firstname : String billing
Рис. 5.1  Композиция классов User и Address
В терминах объектного моделирования эта ассоциация является разновидно-
стью агрегации – отношением часть целого. Агрегация – это жесткая форма ассо-
циации, обладающая дополнительной семантикой, касающейся жизненного цикла
объектов. В данном случае имеет место еще более жесткая форма – композиция,
когда жизненный цикл части полностью зависит от жизненного цикла целого.
Обычно класс, представляющий часть композиции в UML, такой как Address, ста-
новится потенциальным типом-значением в объектно-реляционном отображении.
5.2.1. Схема базы данных
При таком композиционном отношении мы отобразим класс Address как тип-
значение, с той же семантикой, что и у классов String или BigDecimlal, а класс User
отобразим как сущность. Сначала посмотрим на целевую SQL-схему, изображен-
ную на рис. 5.2.
Рис. 5.2  Столбцы компонентов
встроены в таблицу сущности
Здесь имеется лишь одна таблица, USERS, для отображения сущности User.
В этой таблице хранятся все данные компонентов, и каждая запись представля-
ет конкретного пользователя (User), а также его домашний адрес (homeAddress)
и адрес оплаты (billingAddress). Если другая сущность будет ссылаться на адрес
(Address) – например, Shipment#deliveryAddress, в таблице отправки (SHIPMENT)
также появятся столбцы для хранения адреса (Address).
122  Отображение типов-значений
Такая схема отражает семантику типа-значения: конкретный адрес (Address) не мо-
жет быть разделяемым, потому что у него отсутствует идентичность. Его первичным
ключом является отображенный в базе данных идентификатор сущности-владельца.
Встроенный компонент обладает зависимым жизненным циклом: при сохранении эк-
земпляра сущности-владельца сохраняется экземпляр компонента. Экземпляр ком-
понента удаляется при удалении экземпляра сущности-владельца. Hibernate не нуж-
но даже выполнять специальный SQL-код – все данные находятся в одной записи.
Hibernate поддерживает хорошо детализированные модели предметных об-
ластей, когда количество классов превышает количество существующих таблиц.
Давайте создадим классы и отображения для такого варианта.
5.2.2. Встраиваемые классы
В Java отсутствует понятие композиции – класс или свойство не может быть отме-
чено как компонент или иметь соответствующий жизненный цикл. Единственное
отличие от сущности – это идентификатор в базе данных: у класса компонента нет
собственной идентичности, и, следовательно, ему не требуется поле идентификатора
или его отображение. Это обыкновенный POJO, как можно понять из листинга 5.6.
Листинг 5.6  Класс Address – встраиваемый компонент
Файл: /model/src/main/java/org/jpwh/model/simple/Address.java
@Embeddable  @Embeddable вместо аннотации @Entity
public class Address {
@NotNull Игнорируется при генерации DDL
@Column(nullable = false) Используется при генерации DDL
protected String street;
@NotNull
@Column(nullable = false, length = 5) Переопределяет VARCHAR(255)
protected String zipcode;
@NotNull
@Column(nullable = false)
protected String city;
protected Address() {  Конструктор без аргументов
}
public Address(String street, String zipcode, String city) {  Вспомогательный
this.street = street; конструктор
this.zipcode = zipcode;
this.city = city;
}
public String getStreet() {
return street;
}
public void setStreet(String street) {
Отображение полей основных типов  123
this.street = street;
}
public String getZipcode() {
return zipcode;
}
public void setZipcode(String zipcode) {
this.zipcode = zipcode;
}
public String getCity() {
return city;
}
public void setCity(String city) {
this.city = city;
}
}
 Вместо @Entity этот компонент POJO отмечен аннотацией @Embeddable. Идентификатор
отсутствует.
 Hibernate вызывает этот конструктор без аргументов для создания экземпляра и затем
напрямую устанавливает значения полей.
 Для удобства можно создать дополнительные (общедоступные) конструкторы.
Все свойства встраиваемого класса по умолчанию сохраняются точно так же,
как свойства хранимой сущности. Отображение свойств можно настраивать с по-
мощью тех же аннотаций: @Column или @Basic. Свойства класса Address отобража-
ются в столбцы STREET, ZIPCODE и CITY с ограничением NOT NULL.
Проблема: Hibernate Validator не генерирует ограничения NOT NULL
На момент написания книги в Hibernate Validator имеется нерешенная проблема:
Hibernate не отображает аннотацию ограничения @NotNull, расположенную над
свойствами встраиваемых компонентов, в ограничение NOT NULL, когда создает
схему базы данных. Аннотация @NotNull над свойствами компонентов использует-
ся лишь для валидации с помощью Bean Validation во время выполнения. Чтобы
сгенерировать ограничение в схеме, нужно отобразить свойство, используя анно-
тацию @Column(nullable = false). В базе данных Hibernate эту проблему можно от-
слеживать по номеру HVAL-3.
Ниже приводится полное отображение. В определении сущности User нет ни-
чего необычного:
Файл: /model/src/main/java/org/jpwh/model/simple/User.java
@Entity
@Table(name = "USERS")
public class User implements Serializable {
124  Отображение типов-значений
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
public Long getId() {
return id;
}
protected Address homeAddress;
public Address getHomeAddress() {
return homeAddress;
}
public void setHomeAddress(Address homeAddress) {
this.homeAddress = homeAddress;
}
// ...
}
Обнаружив аннотацию @Embeddable перед классом Address, Hibernate отобразит
столбцы STREET, ZIPCODE и CITY в таблицу сущности-владельца USERS. Обсуждая
виды доступа к свойствам, мы отметили, что встраиваемые компоненты наследуют
стратегию доступа от сущности-владельца. Это значит, что Hibernate будет обра-
щаться к полям класса Address, используя ту же стратегию, что и для полей класса
User. Это наследование также влияет на местоположение аннотаций отображения
в классах встраиваемых компонентов:
 если сущность-владелец (@Entity) встроенного компонента отобража-
ется с использованием стратегии прямого доступа к полям, либо неявно,
с помощью аннотации @Id перед полем, либо явно, с помощью аннотации
@Access(AccessType.FIELD) перед классом, все аннотации отображения клас-
са во встроенном компоненте должны располагаться над полями класса. То
есть аннотации в классе Address должны находиться над полями, и Hibernate
будет обращаться к ним во время выполнения напрямую. Наличие ме-
тодов доступа в классе Address не обязательно;
 если сущность-владелец (@Entity) встроенного компонента отображается
с использованием стратегии доступа к свойствам, либо неявно, с помощью
аннотации @Id перед методом чтения, либо явно, с помощью аннотации
@Access(AccessType.PROPERTY) перед классом, все аннотации отображения
в классе встроенного компонента должны располагаться перед методами
чтения. В этом случае Hibernate будет использовать методы доступа во
встроенном компоненте;
 если встроенное свойство класса сущности-владельца – User#homeAddress
в предыдущем примере – отметить аннотацией @Access(AccessType.FIELD),
Hibernate будет ожидать появления аннотаций перед полями класса Address
и обращаться к ним во время выполнения напрямую;
 если встроенное свойство класса сущности-владельца – User#homeAddress
в предыдущем примере – отметить аннотацией @Access(AccessType.PROPER-
Адрес (Address) является встраиваемым
(@Embeddable) – аннотация не требуется
Отображение полей основных типов  125
TY), Hibernate будет ожидать появления аннотаций перед методами чтения
в классе Address и обращаться к свойствам во время выполнения посред-
ством методов доступа;
 если отметить аннотацией @Access сам встраиваемый класс, Hibernate будет
использовать выбранную стратегию для чтения аннотаций отображения
встраиваемого класса и соответствующий режим доступа к свойствам во
время выполнения.
Особенности Hibernate
Важно помнить, что не существует способа изящно представить ссылку на эк-
земпляр Address со значением null. Представьте, что бы получилось, если бы зна-
чения столбцов STREET, ZIPCOD и CITY могли отсутствовать. Что должен вернуть
метод someUser.getHomeAddress(), когда Hibernate загружает пользователя (User)
без адреса? В этом случае Hibernate вернет null. Кроме того, Hibernate сохраняет
встроенные поля со значением null как NULL в столбцах, в которые отображается
компонент. Следовательно, если сохранить пользователя (User) с «пустым» адре-
сом (Address), когда экземпляр Address существует, но все его поля равны null,
при загрузке пользователя (User) экземпляр Address возвращен не будет. Это мо-
жет оказаться неожиданным, но, с другой стороны, вам в любом случае не следует
использовать столбцы, в которых могут отсутствовать значения, а также следует
избегать троичной логики.
Вам следует переопределить методы equals() и hashCode() класса Address и срав-
нивать экземпляры по значению. Это не особенно важно, пока не нужно сравни-
вать экземпляры: например, при добавлении их в HashSet. Мы будем обсуждать это
позже, когда речь пойдет о коллекциях; см. раздел 7.2.1.
В более реалистичном сценарии у пользователя, возможно, будет несколько
адресов для различных целей. На рис. 5.1 показано дополнительное отношение
композиции между классами User и Address: поле billingAddress.
5.2.3. Переопределение встроенных атрибутов
В классе User имеется еще одно свойство-компонент – billingAddress. То есть
в таблицу
USERS должен сохраняться еще один экземпляр Address. Это создает
конфликт
отображения – на данный момент в схеме предусмотрены столбцы для
хранения лишь одного экземпляра Address: STREET, ZIPCODE и CITY.
Для хранения еще одного экземпляра Address в каждой строке таблицы USERS
понадобятся дополнительные столбцы. При отображении billingAddress придет-
ся переопределить имена столбцов.
Файл: /model/src/main/java/org/jpwh/model/simple/User.java
@Entity
@Table(name = "USERS")
public class User implements Serializable {
@Embedded Необязательная аннотация
126  Отображение типов-значений
@AttributeOverrides({
@AttributeOverride(name = "street",
column = @Column(name = "BILLING_STREET")), Может быть NULL!
@AttributeOverride(name = "zipcode",
column = @Column(name = "BILLING_ZIPCODE", length = 5)),
@AttributeOverride(name = "city",
column = @Column(name = "BILLING_CITY"))
})
protected Address billingAddress;
public Address getBillingAddress() {
return billingAddress;
}
public void setBillingAddress(Address billingAddress) {
this.billingAddress = billingAddress;
}
// ...
}
На самом деле аннотацию @Embedded можно опустить. Это альтернатива аннота-
ции @Embeddable – достаточно отметить что-то одно: либо класс компонента, либо
свойство класса-владельца (можно отметить и то, и другое, но это не даст никаких
преимуществ). Аннотация @Embedded может пригодиться для отображения сторон-
него класса компонента, когда исходный код недоступен и нет возможности до-
бавить аннотации, но используются правильные методы доступа (как в обычном
классе JavaBeans).
Аннотация @AttributeOverrides выборочно переопределяет отображение
свойств встроенного класса; в данном примере для всех трех свойств переопреде-
ляются имена столбцов. Теперь в таблице USERS можно хранить два экземпляра Address
– каждому экземпляру соответствует свой набор столбцов (взгляните снова
на схему на рис. 5.2).
Каждая аннотация @AttributeOverride перед свойством-компонентом является
«конечной»: любые аннотации JPA или Hibernate над переопределяемым свой-
ством будут игнорироваться. Это значит, что аннотации @Column в классе Address
будут проигнорированы: все столбцы с префиксом BILLING_* смогут хранить зна-
чение NULL! (Однако Bean Validation по-прежнему будет распознавать аннотацию
@NotNull перед свойством-компонентом; Hibernate лишь переопределит аннота-
ции, связанные с хранением.)
Вы можете улучшить степень повторного использования предметной модели
и сделать ее еще более детализированной, вкладывая встроенные компоненты
друг в друга.
5.2.4. Отображение вложенных встраиваемых компонентов
Рассмотрим класс Address и то, как он инкапсулирует свои данные: вместо простой
строки city можно было бы перенести данные во встраиваемый класс City. По-
смотрите на модифицированную диаграмму предметной модели на рис. 5.3. Схема
Отображение полей основных типов  127
SQL, которую мы будем использовать для отображения, содержит только одну
таблицу USERS, как показано на рис. 5.4.
username : String
lastname : String
User
street : String
Address zipcode : String
name : String
country: String
City
firstname : String
Рис. 5.3  Вложенная композиция классов Address и City
Рис. 5.4  Встроенные столбцы
хранят данные из классов Address и City
Встраиваемый класс может иметь встроенное свойство. Класс Address теперь
имеет свойство city:
Файл: /model/src/main/java/org/jpwh/model/advanced/Address.java
@Embeddable
public class Address {
@NotNull
@Column(nullable = false)
protected String street;
@NotNull
@AttributeOverrides(
@AttributeOverride(
name = "name",
column = @Column(name = "CITY", nullable = false)
)
)
protected City city;
// ...
}
Встраиваемый класс City имеет только свойства основных типов:
Файл: /model/src/main/java/org/jpwh/model/advanced/City.java
@Embeddable
public class City {
128  Отображение типов-значений
@NotNull
@Column(nullable = false, length = 5) Переопределяет VARCHAR(255)
protected String zipcode;
@NotNull
@Column(nullable = false)
protected String name;
@NotNull
@Column(nullable = false)
protected String country;
// ...
}
Можно и дальше продолжить создание вложенных компонентов, выделив,
например, класс Country. Независимо от того, насколько глубоко они находятся
в композиции, все встроенные поля отображаются в столбцы таблицы сущности-
владельца, в данном случае – таблицы USERS.
Вы можете размещать аннотации @AttributeOverride на любом уровне, как
в случае со свойством name в классе City, когда оно отображается в столбец CITY.
Этого можно добиться, либо (как показано) добавив аннотацию @AttributeOverride
в класс Address, либо переопределив отображение в корневом классе сущно-
сти User. К вложенным полям можно обращаться через точку. Например, аннота-
ция @AttributeOveride(name = "city.name") перед свойством User#address ссылается
на атрибут Address#City#name.
Мы еще вернемся к встроенным компонентам в разделе 7.2. Вы можете также
отображать коллекции компонентов или ссылаться из компонентов на сущности.
В начале этой главы мы говорили о свойствах основных типов и о том, как Hibernate
отображает типы из JDK, такие как java.lang.String, в соответствующие
типы SQL. Давайте узнаем больше об этой системе типов и преобразовании зна-
чений на более низком уровне.
5.3. Отображение типов Java и SQL
с применением конвертеров
До этого момента предполагалось, что, когда отображается свойство типа java.
lang.String, Hibernate сам выберет правильный SQL-тип. Но какое отображение
между типами Java и SQL является корректным и как можно управлять выбором?
5.3.1. Встроенные типы
Каждая реализация JPA должна поддерживать минимальный набор преобразо-
ваний типов между Java и SQL; вы видели этот список в начале текущей главы,
в разделе 5.1. Hiberante поддерживает все эти отображения, а также некоторые
нестандартные, но полезные на практике адаптеры. Сначала рассмотрим простые
типы Java и их SQL-эквиваленты.
Отображение типов Java и SQL с применением конвертеров  129
Простые и числовые типы
Встроенные типы, перечисленные в табл. 5.1, отображают примитивные типы
Java и их обертки в соответствующие стандартные типы SQL. Мы также включи-
ли несколько других числовых типов.
Таблица 5.1. Простые типы Java, отображаемые в стандартные типы SQL
Имя Тип Java Тип ANSI SQL
integer int, java.lang.Integer INTEGER
long long, java.lang.Long BIGINT
short short, java.lang.Short SMALLINT
float float, java.lang.Float FLOAT
double double, java.lang.Double DOUBLE
byte byte, java.lang.Byte TINYINT
boolean boolean, java.lang.Boolean BOOLEAN
big_decimal java.math.BigDecimal NUMERIC
big_integer java.math.BigInteger NUMERIC
Эти имена относятся только к Hibernate и потребуются далее для управления
отображением типов.
Вы наверняка заметили, что ваша СУБД не поддерживает некоторых из упомя-
нутых SQL-типов. Эти имена типов SQL являются именами стандартных типов
ANSI. Большинство производителей СУБД игнорирует эту часть стандарта SQL,
как правило, потому, что их устаревшая система типов возникла раньше стандар-
та. Но JDBC частично абстрагирует предоставляемые производителем типы дан-
ных, позволяя Hibernate работать со стандартными типами ANSI при выполнении
таких DML-операций, как INSERT и UPDATE. При генерации схемы для конкретной
системы Hibernate транслирует стандартные типы ANSI в соответствующие типы
базы данных, используя настроенный диалект SQL. Это означает, что обычно нет
причин беспокоиться о типах данных SQL, когда схема генерируется фреймвор-
ком Hibernate.
Если у вас уже есть готовая схема и/или вам нужно узнать, какие собствен-
ные типы данных имеются в СУБД, загляните в исходный код настроенного
диалекта SQL. Например, диалект H2Dialect, поставляемый с Hibernate, содер-
жит следующее отображение из ANSI-типа NUMERIC в тип базы данных DECIMAL:
registerColumnType(Types.NUMERIC, "decimal($p,$s)").
SQL-тип NUMERIC поддерживает настройку точности и масштаба числа. Точность
и масштаб для поля типа BigDecimal, например, по умолчанию будут определены
как NUMERIC(19, 2). Чтобы изменить эти параметры при генерации схемы, помести-
те перед свойством аннотацию @Column и задайте значения параметров precision
и scale.
Далее показаны типы, отображаемые в базу данных как строки.
130  Отображение типов-значений
Символьные типы
В табл. 5.2 показаны типы, отображающие символьные и строковые значения.
Таблица 5.2. Адаптеры для символьных и строковых значений
Имя Тип java Тип ANSI SQL
string java.lang.String VARCHAR
character char[], Character[], java.lang.String CHAR
yes_no boolean, java.lang.Boolean CHAR(1), ‘Y’ или ‘N’
true_false boolean, java.lang.Boolean CHAR(1), ‘T’ или ‘F’
class java.lang.Class VARCHAR
locale java.util.Locale VARCHAR
timezone java.util.TimeZone VARCHAR
currency java.util.Currency VARCHAR
Система типов Hibernate выбирает тип данных SQL в зависимости от объяв-
ленной длины строкового значения: если поле типа String снабжено аннотацией
@Column(length = ...) или @Length из Bean Validation, Hibernate выберет правиль-
ный тип данных SQL для заданной длины строки. На выбор также влияет настро-
енный диалект SQL. Например, для MySQL длина до 65 535 символов будет со-
ответствовать столбцу обычного типа VARCHAR(length), когда схема генерируется
фреймворком Hibernate. Длина до 16 777 215 соответствует собственному типу
MySQL – MEDIUMTEXT, а большие длины соответствуют типу LONGTEXT. Для всех
свойств типа java.lang.String Hibernate устанавливает длину 255, поэтому без
дополнительной настройки поле типа String будет отображаться в столбец VARCHAR(
255). Вы можете поменять логику выбора типов путем расширения класса
вашего SQL-диалекта; читайте документацию с описанием диалекта и его исход-
ный код, чтобы больше узнать о вашей СУБД.
Обычно база данных поддерживает интернационализацию текста, по умолча-
нию выбирая разумную (UTF-8) кодировку для всей базы данных или, по крайней
мере, для целых таблиц. Эта настройка зависит от СУБД. Если вам потребует-
ся явно управлять выбором кодировки или поменять типы столбцов на NVARCHAR,
NCHAR или NCLOB, отметьте отображаемое свойство аннотацией @org.hibernate.annotations.
Nationalized.
Для устаревших баз данных или СУБД с ограниченной системой типов, таких как
Oracle, имеются встроенные конвертеры. СУБД Oracle не имеет даже логического
типа – единственного типа данных, которого требует реляционная модель. Поэто-
му в большинстве существующих схем Oracle значения логического типа представ-
лены как символы Y/N или T/F. Другим вариантом, который по умолчанию приме-
няется диалектом Oracle в Hibernate, являются создание и использование столбца
типа NUMBER(1,0). И снова, если вам захочется узнать, как отображаются ANSI-типы
в типы базы данных, обращайтесь к описанию диалекта SQL вашей СУБД.
Далее рассказывается о типах, которые в базе данных отображаются в типы
даты и времени.
Отображение типов Java и SQL с применением конвертеров  131
Типы даты и времени
В табл. 5.3 перечислены типы даты, времени и отметки времени.
Таблица 5.3. Типы даты и времени
Имя Тип java Тип ANSI SQL
date java.util.Date, java.sql.Date DATE
time java.util.Date, java.sql.Time TIME
timestamp java.util.Date, java.sql.Timestamp TIMESTAMP
calendar java.util.Calendar TIMESTAMP
calendar_date java.util.Calendar DATE
duration java.time.Duration BIGINT
instant java.time.Instant TIMESTAMP
localdatetime java.time.LocalDateTime TIMESTAMP
localdate java.time.LocalDate DATE
localtime java.time.LocalTime TIME
offsetdatetime java.time.OffsetDateTime TIMESTAMP
offsettime java.time.OffsetTime TIME
zoneddatetime java.time.ZonedDateTime TIMESTAMP
В своей предметной модели вы можете представлять дату и время при помощи
java.util.Date, java.util.Calendar или подклассов java.util.Date из пакета java.
sql. Это дело вкуса, и мы оставляем выбор за вами, но будьте последовательны.
Возможно, вы не захотите привязывать классы предметной модели к типам из па-
кета JDBC.
Вы также можете использовать классы из пакета java.time в Java 8. Обратите
внимание, что это относится только к Hibernate и не стандартизовано в JPA 2.1.
Поведение Hibernate, касающееся свойств типа java.util.Date, первое время
может озадачивать: если сохранить свойство типа java.util.Date, Hibernate не
вернет вам значение типа java.util.Date после загрузки из базы данных. Он вер-
нет java.sql.Date, java.sql.Time или java.sql.Timestamp, в зависимости от того, ка-
кой параметр использовался в описании отображения свойства: TemporalType.DATE,
TemporalType.TIME или TemporalType.TIMESTAMP.
При извлечении даты из базы данных Hibernate использует подкласс JDBC,
потому что типы базы данных более точные, чем java.util.Date. Тип java.util.
Date обеспечивает точность до миллисекунды, тогда как тип java.sql.Timestamp
включает информацию о наносекундах, которые могут храниться в базе данных.
Hibernate не будет отсекать эту информацию, чтобы вместить значение в java.
util.Date. Такое поведение может привести к проблемам, если попытаться срав-
нить значения типа java.util.Date, используя метод equals() – он не симметричен
с методом equals() подкласса java.sql.Timestamp.
Решается эта проблема просто, причем независимо от Hibernate, – не вызывай-
те aDate.equals(bDate). Всегда сравнивайте значения времени и даты, используя
значения времени Unix в миллисекундах (если точность до наносекунд не нуж-
132  Отображение типов-значений
на): выражение aDate.getTime() > bDate.getTime(), например, будет истинным
(true) в том случае, когда aDate наступает позже bDate. Будьте бдительны: такие
коллекции, как HashSet, тоже вызывают метод equals(). В подобных коллекциях не
следует смешивать значения типов java.util.Date и java.sql.Date|Time|Timestamp.
С полем типа Calendar такой проблемы не возникнет. Если вы сохранили значение
типа Calendar, Hiberante всегда будет возвращать экземпляр Calendar, созданный
при помощи метода Calendar.getInstance() (настоящий тип зависит от региональ-
ных настроек и часового пояса).
С другой стороны, можно написать свой конвертер, как будет показано далее
в этой главе, и преобразовывать экземпляр любого типа java.sql.Date|Time|Timestamp,
возвращаемый Hibernate, в обычный объект java.util.Date. Если при за-
грузке экземпляра Calendar из базы данных потребуется устанавливать часовой
пояс, отличный от часового пояса по умолчанию, создание собственного конвер-
тера может стать хорошей отправной точкой.
Далее представлены типы, сохраняемые в базе данных в двоичном виде.
Двоичные типы и типы для представления больших значений
В табл. 5.4 перечислены типы для работы с двоичными данными и большими
значениями. Обратите внимание, что только тип binary может выступать в качестве
типа свойств-идентификаторов.
Сначала нужно решить, как потенциально большое значение будет представле-
но в Hibernate: в двоичном виде или в виде текста.
Таблица 5.4. Двоичные типы и типы для представления больших значений
Имя Тип java Тип ANSI SQL
binary byte[], java.lang.Byte[] VARBINARY
text java.lang.String CLOB
clob java.sql.Clob CLOB
blob java.sql.Blob BLOB
serializable java.io.Serializable VARBINARY
Если свойство хранимого класса имеет тип byte[], Hibernate отобразит его
в столбец типа VARBINARY. Настоящий тип SQL будет зависеть от диалекта – на-
пример, в PostgresSQL это будет тип BYTEA, а в Oracle – RAW. В некоторых диалектах
параметр length аннотации @Column также может повлиять на выбор типа в базе
данных – например, в Oracle для длины 2000 и более будет выбран тип LONG RAW.
Свойство типа java.lang.String отображается в столбец типа SQL VARCHAR, и это
поведение аналогично char[] и Character[]. Мы уже говорили, что некоторые диа-
лекты выбирают разные типы, в зависимости от объявленной длины.
В обоих случаях Hibernate инициализирует значение свойства сразу же при за-
грузке экземпляра сущности, в котором есть это поле. Это может быть неудоб-
но, когда приходится иметь дело с потенциально большими значениями, поэтому
Отображение типов Java и SQL с применением конвертеров  133
обычно хочется переопределить отображение по умолчанию. В спецификации JPA
для этой цели есть удобная аннотация @Lob:
@Entity
public class Item {
@Lob
protected byte[] image;
@Lob
protected String description;
// ...
}
В данном случае тип byte[] будет отображаться в SQL-тип BLOB, а тип String –
в CLOB. К сожалению, даже такая настройка не обеспечивает отложенную загрузку.
Hibernate придется перехватывать доступ к полю и, например, загружать байты
для поля image в момент вызова метода someItem.getImage(). Подобный подход
требует внедрения дополнительного кода в байт-код классов после компиляции.
Мы обсудим реализацию отложенной загрузки таким способом в разделе 12.1.3.
С другой стороны, можно поменять тип поля в Java-классе. JDBC напрямую
поддерживает объекты логических указателей (LOB). Если для свойства в Java
выбрать тип java.sql.Clob или java.sql.Blob, это обеспечит отложенную загрузку
без внедрения в байт-код.
@Entity
public class Item {
@Lob
protected java.sql.Blob imageBlob;
@Lob
protected java.sql.Clob description;
// ...
}
Эти классы JDBC поддерживают загрузку значений по требованию. В момент
загрузки сущности владельца свойство получает значение указателя, а настоящие
данные не загружаются сразу же. Если в рамках той же транзакции происходит
обращение к свойству, данные загружаются или даже передаются напрямую (кли-
енту), не занимая временную память:
Файл: /examples/src/test/java/org/jpwh/test/advanced/LazyProperties.java
Item item = em.find(Item.class, ITEM_ID);
InputStream imageDataStream = item.getImageBlob().getBinaryStream();
ByteArrayOutputStream outStream = new ByteArrayOutputStream();
StreamUtils.copy(imageDataStream, outStream);
byte[] imageBytes = outStream.toByteArray();
Можно передавать поток байтов напрямую...
... или загружать их в память.
134  Отображение типов-значений
Недостаток заключается в том, что в этом случае предметная модель окажется
связанной с JDBC; в модульных тестах обращение к свойствам типа LOB будет
невозможно без подключения к базе данных.
Особенности Hibernate
В Hibernate имеются удобные методы для создания и установки значений типа
Blob или Clob. В этом примере продемонстрированы чтение и пересылка byte-
Length байтов напрямую из потока InputStream в базу данных без сохранения во
временной памяти:
Session session = em.unwrap(Session.class); Нужен оригинальный Hibernate API
Blob blob = session.getLobHelper()
.createBlob(imageInputStream, byteLength);
someItem.setImageBlob(blob);
em.persist(someItem);
Наконец, Hibernate предоставляет запасной механизм сериализации, работаю-
щий с полем любого типа, реализующего java.io.Serializable. Это отображение
преобразует значение поля в поток байтов, сохраняемый в столбце типа VARBINARY.
Сериализация и десериализация происходят при загрузке и сохранении сущно-
сти-владельца. Конечно, эту стратегию следует использовать с осторожностью,
потому что данные будут существовать дольше, чем приложение. В один прекрас-
ный день уже никто не сможет понять значения этих байтов в базе данных. Сериа-
лизация иногда полезна для хранения временных данных, таких как предпочтения
пользователя, данные сеанса пользователя и т. д.
Hibernate выберет правильный вид адаптера в зависимости от Java-типа свой-
ства. Если вам не нравится отображение по умолчанию, читайте дальше, чтобы
узнать, как его переопределить.
Особенности Hibernate
Выбор типа адаптера
В предыдущих разделах вы уже видели многие адаптеры и их названия в Hibernate.
Чтобы переопределить выбор типа по умолчанию, явно укажите имя кон-
кретного адаптера:
@Entity
public class Item {
@org.hibernate.annotations.Type(type = "yes_no")
protected boolean verified = false;
}
Теперь вместо типа BIT это булево значение будет отображаться в столбец типа
CHAR со значениями Y и N.
Необходимо знать количество байтов,
которое нужно прочитать из потока
Отображение типов Java и SQL с применением конвертеров  135
Также можно переопределить адаптер глобально в конфигурации загрузки Hibernate
и указать собственный тип адаптера, о создании которого вы узнаете далее
в этой главе:
metaBuilder.applyBasicType(new MyUserType(), new String[]{"date"});
Эта настройка переопределит встроенный тип адаптера с именем date и пере-
даст управление преобразованиями полей типа java.util.Date вашей собственной
реализации.
Мы рассматриваем такую расширяемую систему типов как одну из главных
особенностей Hibernate и как главную причину его гибкости. Далее мы более подробно
исследуем систему типов и пользовательские конвертеры JPA.
5.3.2. Создание собственных конвертеров JPA
Новым требованием к системе онлайн-аукциона является применение несколь-
ких валют. Воплощение подобного требования может оказаться сложной задачей.
Необходимо модифицировать схему базы данных, может понадобиться перенос
данных из старой схемы в новую, а также придется обновить все приложения,
имеющие доступ к базе данных. В этом разделе мы покажем, как JPA-конвертеры
и расширяемая система типов Hibernate могут помочь в этом процессе, предостав-
ляя гибкую дополнительную прослойку между приложением и базой данных.
Для работы с несколькими валютами мы добавим новый класс в предметную
модель приложения CaveatEmptor – это MonetaryAmount, показанный в листин-
ге 5.7.
Листинг 5.7  Неизменяемый класс типа-значения MonetaryAmount
Файл: /model/src/main/java/org/jpwh/model/advanced/MonetaryAmount.java
public class MonetaryAmount implements Serializable {
protected final BigDecimal value;  Специальный конструктор не нужен
protected final Currency currency;
public MonetaryAmount(BigDecimal value, Currency currency) {
this.value = value;
this.currency = currency;
}
public BigDecimal getValue() {
return value;
}
public Currency getCurrency() {
return currency;
}
public boolean equals(Object o) {  Реализация методов equals() и hashcode()
if (this == o) return true;
 Класс типа-значения реализует
интерфейс java.io.Serializable
136  Отображение типов-значений
if (!(o instanceof MonetaryAmount)) return false;
final MonetaryAmount monetaryAmount = (MonetaryAmount) o;
if (!value.equals(monetaryAmount.value)) return false;
if (!currency.equals(monetaryAmount.currency)) return false;
return true;
}
public int hashCode() {  Реализация методов equals() и hashcode()
int result;
result = value.hashCode();
result = 29 * result + currency.hashCode();
return result;
}
public String toString() {  Создает экземпляр MonetaryAmount из объекта String
return getValue() + " " + getCurrency();
}
public static MonetaryAmount fromString(String s) {
String[] split = s.split(" ");
return new MonetaryAmount(
new BigDecimal(split[0]),
Currency.getInstance(split[1])
);
}
}
 Данный класс типа-значения должен реализовать интерфейс java.io.Serializable: когда
Hibernate сохраняет данные экземпляра сущности в разделяемом кэше второго уровня
(см. раздел 20.2), то он разбирает состояние сущности на составляющие. Если сущность
имеет свойство типа MonetaryAmount, сериализованное представление значения поля со-
храняется в кэше второго уровня. При загрузке данных сущности из кэша значение поля
десериализуется и собирается обратно.
 Классу не требуется специальный конструктор. Его можно сделать неизменяемым даже
при наличии полей с модификатором final, потому что ваш код – единственное место, где
создаются его экземпляры.
 Вы должны реализовать методы equals() и hashCode() и сравнивать объекты, представ-
ляющие денежную сумму, «по значению».
 Вам понадобится строковое представление денежной суммы в виде экземпляра String.
Реализуйте метод toString(), а также статический метод создания экземпляров из объ-
ектов String.
Далее следует обновить остальные части модели, задействовав класс MonetaryAmount
для всех свойств, связанных с деньгами, таких как Item#buyNowPrice
и Bid#amount.
Конвертация значений свойств основных типов
Как это обычно бывает, специалисты, отвечающие за базу данных, не могут реа-
лизовать поддержку нескольких валют прямо сейчас – им нужно больше времени.
Отображение типов Java и SQL с применением конвертеров  137
Самое быстрое, что они могут сделать, – это изменить тип данных столбца. Они
предложили хранить значение BUYNOWPRICE в таблице ITEM, в столбце типа VARCHAR,
и добавлять код валюты в виде суффикса строкового представления денежной
суммы. К примеру, хранимое значение может иметь вид 11.23 USD или 99 EUR.
При сохранении данных экземпляр MonetaryAmount необходимо преобразовать
в объект String с подобным представлением. При загрузке данных объект String
нужно преобразовать обратно в экземпляр MonetaryAmount.
Простейшее решение заключается в использовании javax.persistence.AttributeConverter
– стандартного механизма расширения в JPA, – как показано в листинге
5.8.
Листинг 5.8  Преобразование строк в экземпляры MonetaryValue
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountConverter.java
@Converter(autoApply = true) Автоматически применяется к полям типа MonetaryAmount
public class MonetaryAmountConverter
implements AttributeConverter<MonetaryAmount, String> {
@Override
public String convertToDatabaseColumn(MonetaryAmount monetaryAmount) {
return monetaryAmount.toString();
}
@Override
public MonetaryAmount convertToEntityAttribute(String s) {
return MonetaryAmount.fromString(s);
}
}
Конвертер должен реализовать интерфейс AttributeConverter; два аргумента
определяют тип свойства Java и тип столбца в схеме базы данных соответственно.
Java-тип в данном случае – это MonetaryAmount, а тип базы данных – String, отобра-
жаемый, как обычно, в SQL-тип VARCHAR. Класс должен быть отмечен аннотацией
@Converter или объявлен конвертером в файле метаданных orm.xml. Если пара-
метр autoApply включен, любое свойство типа MonetaryAmount в предметной моде-
ли (в классе-сущности или во встраиваемом классе) будет обрабатываться кон-
вертером автоматически. (Пусть вас не вводит в заблуждение название метода
convertToEntityAttribute() интерфейса AttributeConverter; имя выбрано не самое
удачное.)
Примером свойства с типом MonetaryAmount в модели предметной области мо-
жет послужить Item#buyNowPrice:
Файл: /model/src/main/java/org/jpwh/model/advanced/converter/Item.java
@Entity
public class Item {
@NotNull
@Convert( Необязательная аннотация, т. к. активен параметр autoApply
138  Отображение типов-значений
converter = MonetaryAmountConverter.class,
disableConversion = false)
@Column(name = "PRICE", length = 63)
protected MonetaryAmount buyNowPrice;
// ...
}
Аннотацию @Convert можно опустить: она применяется для переопределения
или отключения конвертера для конкретного свойства. Аннотация @Column пере-
именовывает столбец базы в PRICE; по умолчанию он получил бы имя BUYNOWPRICE.
Для автоматического создания схемы его тип определяется как VARCHAR с длиной
в 63 символа.
Позже, когда администраторы базы данных обновят схему и предоставят вам
столбцы для хранения денежной суммы и валюты, вам придется внести изменения
в нескольких местах в программе: удалить класс MonetaryAmountConverter из про-
екта и сделать класс MonetaryAmount встраиваемым с помощью аннотации @Embeddable
– после этого он автоматически будет отображаться в два столбца базы дан-
ных. Также можно с легкостью выборочно подключать и отключать конвертеры,
если некоторые таблицы в схеме еще не обновились.
Только что созданный конвертер работает с классом MonetaryAmount – новым
классом в предметной модели. Но применение конвертеров не ограничивается
пользовательскими классами – можно также переопределять встроенные адапте-
ры типов Hibernate. Например, можно создать собственный конвертер для некото-
рых или даже для всех свойств типа java.util.Date в предметной модели.
Конвертеры можно применять к свойствам классов сущностей, таких как
Item#buyNowPrice из предыдущего примера. Но их также можно применять к свой-
ствам встраиваемых классов.
Преобразование значений полей компонентов
В этой главе мы разрабатывали пример хорошо детализированной предмет-
ной модели. Ранее вы изолировали информацию об адресе пользователя (User)
и отобразили
встраиваемый класс Address. Давайте продолжим этот процесс и до-
бавим наследование, используя абстрактный класс Zipcode, как показано на рис. 5.5.
street : String
city : String
Address
value : String
Zipcode
GermanZipcode SwissZipcode
Рис. 5.5  Абстрактный класс Zipcode
имеет два конкретных подкласса
Класс Zipcode тривиально прост, но не забудьте реализовать определение равен-
ства по значению:
Отображение типов Java и SQL с применением конвертеров  139
Файл: /model/src/main/java/org/jpwh/model/advanced/converter/Zipcode.java
abstract public class Zipcode {
protected String value;
public Zipcode(String value) {
this.value = value;
}
public String getValue() {
return value;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Zipcode zipcode = (Zipcode) o;
return value.equals(zipcode.value);
}
@Override
public int hashCode() {
return value.hashCode();
}
}
Теперь можно инкапсулировать различие между немецкими и швейцарскими
почтовыми индексами и их обработку в подклассах предметной модели:
Файл: /model/src/main/java/org/jpwh/model/advanced/converter/
GermanZipcode.java
public class GermanZipcode extends Zipcode {
public GermanZipcode(String value) {
super(value);
}
}
В подклассе пока не реализовано никакой особенной функциональности. Нач-
нем с наиболее очевидного различия: немецкие почтовые индексы имеют длину
в пять символов, швейцарские – четыре. Об этом позаботится наш специальный
конвертер:
Файл: /model/src/main/java/org/jpwh/converter/ZipcodeConverter.java
@Converter
public class ZipcodeConverter
implements AttributeConverter<Zipcode, String> {
@Override
public String convertToDatabaseColumn(Zipcode attribute) {
140  Отображение типов-значений
return attribute.getValue();
}
@Override
public Zipcode convertToEntityAttribute(String s) {
if (s.length() == 5)
return new GermanZipcode(s);
else if (s.length() == 4)
return new SwissZipcode(s);
throw new IllegalArgumentException(
"Unsupported zipcode in database: " + s
);
}
}
При сохранении значения свойства Hibernate вызывает метод convertToDatabaseColumn()
конвертера, который возвращает строковое представление в виде
объекта String. Тип столбца в схеме – VARCHAR. При загрузке значения нужно про-
верить его длину и создать экземпляр класса GermanZipcode или SwissZipcode. Это
ваша собственная процедура определения типа, и вам решать, какой тип Java вы-
брать для данного значения.
Теперь применим конвертер к какому-нибудь свойству типа Zipcode – напри-
мер, к свойству homeAddress класса User:
Файл: /model/src/main/java/org/jpwh/model/advanced/converter/User.java
@Entity
@Table(name = "USERS")
public class User implements Serializable {
@Convert( Под одной аннотацией @Convert можно объединить преобразование нескольких атрибутов
converter = ZipcodeConverter.class,
attributeName = "zipcode" Или «city.zipcode» для вложенных встраиваемых компонентов
)
protected Address homeAddress;
// ...
}
Параметр attributeName объявляет атрибут zipcode встраиваемого класса Address.
Можно использовать точечную нотацию для указания пути к атрибуту –
если zipcode является не свойством класса Address, а свойством встраиваемого
класса City (как было показано ранее в этой главе), путь к нему можно указать
так: city.zipcode.
Если к одному встроенному свойству требуется применить несколько аннота-
ций @Convert – например, чтобы преобразовать несколько атрибутов класса Address,
– их можно объединить в одну аннотацию @Converts. Конвертеры можно
также применять к значениям коллекций и словарей, если их значения и/или
ключи имеют основной или встраиваемый тип. К примеру, можно добавить анно-
Если вы оказались тут,
то подумайте о чистке базы данных...
или создайте подкласс InvalidZipCode
и возвращайте его в этом месте
Отображение типов Java и SQL с применением конвертеров  141
тацию @Convert перед хранимым свойством типа Set<Zipcode>. Позже, в главе 7, мы
покажем, как отображать хранимые коллекции при помощи аннотации @Element-
Collection.
Для хранимых словарей параметр attributeName аннотации @Convert имеет спе-
циальный синтаксис:
 если свойство zipcode имеет тип Map<Address, String>, применить конвертер
к каждому ключу в словаре можно при помощи атрибута key.zipcode;
 если свойство zipcode имеет тип Map<String, Address>, применить конвертер
к каждому значению в словаре можно при помощи аттрибута value.zipcode;
 если свойство zipcode имеет тип Map<Zipcode, String>, применить конвертер
к ключу каждой записи в словаре можно при помощи атрибута key;
 если свойство zipcode имеет тип Map<String, Zipcode>, применить конвертер
к значению каждой записи в словаре можно при помощи атрибута attributeName.
Как и прежде, если встраиваемые классы вложены, в качестве имен атрибу-
тов могут указываться пути, записанные в точечной нотации; можно написать
key.city.zipcode, чтобы сослаться на свойство zipcode класса City в композиции
с классом Address.
Конвертеры JPA имеют следующие ограничения:
 их нельзя применять к свойству-идентификатору или свойству с версией
сущности;
 не следует применять конвертеры к свойствам, отмеченным аннотациями
@Enumerated или @Temporal, потому что эти аннотации уже определяют необ-
ходимые преобразования. Если потребуется применить собственный кон-
вертер к перечислениям или свойствам с датой/временем, не отмечайте их
аннотацией @Enumerated или @Temporal;
 конвертер можно применить к свойству, отображение которого опи-
сывается в файле hbm.xml, но тогда к имени следует добавить префикс:
type="converter:qualified.ConverterName".
Вернемся к поддержке нескольких валют в приложении CaveatEmptor. Адми-
нистраторы базы данных в очередной раз обновили схему и попросили вас обно-
вить приложение.
Особенности Hibernate
5.3.3. Расширение Hibernate
с помощью пользовательских типов
Наконец мы добавили в схему базы данных новые столбцы для поддержки не-
скольких валют. Теперь в таблице ITEM есть столбец BUYNOWPRICE_AMOUNT и отдель-
ный столбец BUYNOWPRICE_CURRENCY, представляющий валюту. Также имеются два
столбца INITIALPRICE_AMOUNT и INITIALPRICE_CURRENCY. Эти столбцы требуется
отобразить в свойства buyNowPrice и initialPrice типа MonetaryAmount в классе
Item.
142  Отображение типов-значений
В идеале хотелось бы избежать необходимости изменять предметную модель;
свойства уже используют класс MonetaryAmount. К сожалению, стандартизирован-
ные конвертеры JPA не поддерживают преобразования значений в несколько или
из нескольких столбцов. Другое ограничение конвертеров JPA – интеграция с ме-
ханизмом запросов. Невозможно написать следующий запрос: select i from Item
i where i.buyNowPrice.amount > 100. Благодаря конвертеру из предыдущего раздела
Hibernate знает, как преобразовать класс MonetaryAmount в строку и обратно. Но
ему неизвестно о существовании атрибута amount в классе MonetaryAmount, поэтому
он не сможет разобрать подобного запроса.
Эту проблему легко решить, отобразив класс MonetaryAmount как встраиваемый
(@Embeddable), подобно классу Address, который мы обсудили ранее в этой главе.
Каждое поле класса MonetaryAmount – amount и currency – будет отображаться в со-
ответствующий столбец базы данных.
Однако администраторы базы данных добавили к требованиям поправку: по-
скольку другое, более старое приложение также обращается к базе данных, не-
обходимо преобразовывать каждую сумму в целевую валюту перед сохранением
в базу данных. К примеру, значение Item#buyNowPrice должно храниться в долла-
рах США, а значение Item#initialPrice должно храниться в евро. (Если этот при-
мер показался вам притянутым за уши, можем вас уверить, что в реальном мире
встречаются куда худшие примеры. Эволюция используемой совместно схемы
базы данных может оказаться затратной, но она тем не менее необходима, потому
что данные всегда существуют дольше приложений.) Hibernate имеет собствен-
ный API для конвертера – точку расширения для доступа на более низком уровне.
Точки расширения
Интерфейсы для расширения системы типов Hibernate определены в пакете
org.hibernate.usertype и включают:
 UserType – позволяет преобразовывать значения посредством взаимодей-
ствий с обычными классами JDBC: PreparedStatement при сохранении и ResultSet
при загрузке. Реализовав этот интерфейс, вы сможете контроли-
ровать порядок кэширования значений и проверки изменений состояний
объектов в Hibernate. Адаптер для класса MonetaryAmount должен реализо-
вать этот интерфейс;
 CompositeUserType – расширяет UserType, предоставляя фреймворку Hibernate
больше подробностей об адаптируемом классе. Вы можете указать, что
компонент типа MonetaryAmount имеет два поля: amount и currency, – и затем
обращаться к этим полям в запросах, используя точечную нотацию, напри-
мер: select avg(i.buyNowPrice.amount) from Item i;
 ParameterizedUserType – добавляет настройки отображений в класс адапте-
ра. Вы должны реализовать этот интерфейс для преобразования объектов
MonetaryAmount, потому что в некоторых отображениях нужно конвертиро-
вать сумму в доллары США, а в других – в евро. Вам придется написать все-
го один адаптер, а затем вы сможете настраивать его поведение для отображения
полей;
Отображение типов Java и SQL с применением конвертеров  143
 DynamicParameterizedType – более мощный API управления настройками, от-
крывающий доступ к динамической информации адаптера, такой как имена
таблиц и столбцов, в которые выполняется отображение. Вы можете запросто
выбрать его вместо ParameterizedUserType – это не повлечет дополнитель-
ных затрат и не увеличит сложности;
 EnhancedUserType – необязательный интерфейс для адаптеров свойств-
идентификаторов и селекторов. В отличие от конвертеров JPA, класс User-
Type в Hibernate может служить адаптером свойства сущности любого типа.
Но поскольку класс MonetaryAmount не является типом свойства-идентифи-
катора или селектора, вам этот интерфейс не понадобится;
 UserVersionType – необязательный интерфейс для адаптеров свойств, храня-
щих номера версий объектов;
 UserCollectionType – этот редко используемый интерфейс применяется для
реализации собственных коллекций. Его нужно реализовать при работе
с коллекциями, имеющими типы не из JDK, а также для сохранения допол-
нительной семантики.
В адаптере для класса MonetaryAmount мы реализуем некоторые из этих интер-
фейсов.
Реализация интерфейса UserType
Класс MonetaryAmountUserType довольно обширный, поэтому мы будем изучать
его в несколько этапов. Ниже перечислены интерфейсы, которые он реализует:
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountUserType.java
public class MonetaryAmountUserType
implements CompositeUserType, DynamicParameterizedType {
// ...
}
Сначала реализуем интерфейс DynamicParameterizedType. Выбор целевой валю-
ты для конвертации производится путем анализа параметра отображения:
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountUserType.java
protected Currency convertTo;
public void setParameterValues(Properties parameters) {
ParameterType parameterType =  Обращение к динамическим параметрам
(ParameterType) parameters.get(PARAMETER_TYPE);
String[] columns = parameterType.getColumns();
String table = parameterType.getTable();
Annotation[] annotations = parameterType.getAnnotationsMethod();
String convertToParameter = parameters.getProperty("convertTo");
this.convertTo = Currency.getInstance(
convertToParameter != null ? convertToParameter : "USD"
);
}
 Определение
целевой валюты
144  Отображение типов-значений
 Здесь можно получить доступ к некоторым динамическим параметрам, таким как имена
столбцов, в которые производится отображение, таблицы (сущности) или даже анно-
тации поля или метода чтения отображаемого свойства. Хотя в этом примере они и не
потребуются.
 Для определения целевой валюты при сохранении значения в базу данных потребует-
ся только параметр convertTo. Если параметр не установлен, по умолчанию выбираются
доллары США.
Далее следует вспомогательный код, реализующий интерфейс UserType:
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountUserType.java
public Class returnedClass() {  Адаптируемый класс
return MonetaryAmount.class;
}
public boolean isMutable() {  Позволяет включить оптимизацию
return false;
}
public Object deepCopy(Object value) {  Копирует значение
return value;
}
public Serializable disassemble(Object value,  Возвращает сериализованное представление
SessionImplementor session) {
return value.toString();
}
public Object assemble(Serializable cached,  Создает экземпляр MonetaryAmount
SessionImplementor session, Object owner) {
return MonetaryAmount.fromString((String) cached);
}
public Object replace(Object original, Object target,  Возвращает копию оригинала
SessionImplementor session, Object owner) {
return original;
}
public boolean equals(Object x, Object y) {  Определяет, поменялось ли значение
return x == y || !(x == null || y == null) && x.equals(y);
}
public int hashCode(Object x) {
return x.hashCode();
}
 Метод returnedClass возвращает адаптируемый класс – в данном случае MonetaryAmount.
 Если известно, что класс MonetaryAmount неизменяемый, Hibernate может применять не-
которые оптимизации.
 Если фреймворку Hibernate потребуется скопировать значение, он вызовет этот метод.
В случае неизменяемых классов, таких как MonetaryAmount, можно возвращать передан-
ное значение.
Отображение типов Java и SQL с применением конвертеров  145
 Hiberante вызывает disassemble, когда сохраняет значение в глобальном разделяемом
кэше второго уровня. Метод должен вернуть сериализованное значение в виде экзем-
пляра Serializable. В случае с классом MonetaryAmount проще всего вернуть представле-
ние в виде объекта String. Или, поскольку класс MonetaryAmount сам реализует интерфейс
Serializable, можно вернуть его экземпляр непосредственно.
 Hibernate вызывает этот метод, когда читает сериализованное представление из глобаль-
ного разделяемого кэша второго уровня. Экземпляр MonetaryAmount создается из строко-
вого представления в виде объекта String. Если бы в кэше хранился сериализованный
экземпляр MonetaryAmount, можно было бы вернуть его непосредственно.
 Этот метод вызывается во время операций слияния, выполняемых методом EntityManager#
merge(). Он должен вернуть копию оригинала. Или, если тип-значение является
неизменяемым, как MonetaryAmount, можно вернуть оригинал.
 Чтобы определить факт изменения и необходимость записи в базу данных, Hibernate
использует проверку на равенство по значению. Можно положиться на процедуру опре-
деления равенства, уже написанную для класса MonetaryAmount.
Настоящую работу адаптер выполняет в моменты загрузки и сохранения значе-
ний, как показано в реализациях следующих методов:
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountUserType.java
public Object nullSafeGet(ResultSet resultSet,  Читает экземпляр ResultSet
String[] names,
SessionImplementor session,
Object owner) throws SQLException {
BigDecimal amount = resultSet.getBigDecimal(names[0]);
if (resultSet.wasNull())
return null;
Currency currency =
Currency.getInstance(resultSet.getString(names[1]));
return new MonetaryAmount(amount, currency);
}
public void nullSafeSet(PreparedStatement statement,  Сохраняет экземпляр
Object value,
int index,
SessionImplementor session) throws SQLException {
if (value == null) {
statement.setNull(
index,
StandardBasicTypes.BIG_DECIMAL.sqlType());
statement.setNull(
index + 1,
StandardBasicTypes.CURRENCY.sqlType());
} else {
MonetaryAmount amount = (MonetaryAmount) value;
MonetaryAmount dbAmount = convert(amount, convertTo);
statement.setBigDecimal(index, dbAmount.getValue());
Конвертировать в целевую валюту
при сохранении MonetaryAmount
146  Отображение типов-значений
statement.setString(index + 1, convertTo.getCurrencyCode());
}
}
protected MonetaryAmount convert(MonetaryAmount amount,  Конвертирует валюту
Currency toCurrency) {
return new MonetaryAmount(
amount.getValue().multiply(new BigDecimal(2)),
toCurrency
);
}
 Этот метод читает объект ResultSet, когда экземпляр MonetaryAmount извлекается из базы
данных. Метод получает значения amount и currency из результата запроса и создает эк-
земпляр класса MonetaryAmount.
 Этот метод вызывается, когда требуется сохранить объект MonetaryAmount в базу данных.
Сумма пересчитывается в целевую валюту, и затем значения amount и currency сохраня-
ются в экземпляре PreparedStatement (если только экземпляр MonetaryAmount не null –
в этом случае для подготовки выражения вызывается setNull()).
 Здесь можно реализовать любые правила преобразования. Для целей примера значение
просто удваивается, чтобы можно было легко убедиться, что преобразование прошло
успешно. Этот код нужно поменять на настоящую конвертацию в реальном приложе-
нии. Данный метод не является частью интерфейса UserType.
Далее следуют методы интерфейса CompositeUserType, помогающие получить
сведения о классе MonetaryAmount, чтобы Hibernate мог интегрировать этот класс
в механизм запросов:
Файл: /model/src/main/java/org/jpwh/converter/MonetaryAmountUserType.java
public String[] getPropertyNames() {
return new String[]{"value", "currency"};
}
public Type[] getPropertyTypes() {
return new Type[]{
StandardBasicTypes.BIG_DECIMAL,
StandardBasicTypes.CURRENCY
};
}
public Object getPropertyValue(Object component,
int property) {
MonetaryAmount monetaryAmount = (MonetaryAmount) component;
if (property == 0)
return monetaryAmount.getValue();
else
return monetaryAmount.getCurrency();
}
public void setPropertyValue(Object component,
Отображение типов Java и SQL с применением конвертеров  147
int property,
Object value) {
throw new UnsupportedOperationException(
"MonetaryAmount is immutable"
);
}
Работа над классом MonetaryAmountUserType завершена, и теперь его можно ис-
пользовать в @org.hibernate.annotations.Type, как показано в разделе «Выбор
адаптера типа» выше. Эта аннотация также поддерживает параметры и позволяет
указать целевую валюту с помощью параметра convertTo.
Мы советуем создавать определения типов, связывая адаптеры с некоторыми
параметрами.
Использование определений типов
Итак, нам нужен один адаптер для преобразования в доллары США и еще один
для преобразования в евро. Если один раз объявить эти параметры как определе-
ние типа, вам не придется повторять их в отображениях свойств. Лучшим местом
для объявления определений типов является файл метаданных уровня пакета
package-info.java:
Файл: /model/src/main/java/org/jpwh/converter/package-info.java
@org.hibernate.annotations.TypeDefs({
@org.hibernate.annotations.TypeDef(
name = "monetary_amount_usd",
typeClass = MonetaryAmountUserType.class,
parameters = {@Parameter(name = "convertTo", value = "USD")}
),
@org.hibernate.annotations.TypeDef(
name = "monetary_amount_eur",
typeClass = MonetaryAmountUserType.class,
parameters = {@Parameter(name = "convertTo", value = "EUR")}
)
})
package org.jpwh.converter;
import org.hibernate.annotations.Parameter;
Теперь можно использовать адаптеры в отображениях, используя названия
monetary_amount_usd и monetary_amount_eur.
Давайте отобразим свойства buyNowPrice и initialPrice класса Item:
Файл: /model/src/main/java/org/jpwh/model/advanced/usertype/Item.java
@Entity
public class Item {
@NotNull
@org.hibernate.annotations.Type(
type = "monetary_amount_usd"
148  Отображение типов-значений
)
@org.hibernate.annotations.Columns(columns = {
@Column(name = "BUYNOWPRICE_AMOUNT"),
@Column(name = "BUYNOWPRICE_CURRENCY", length = 3)
})
protected MonetaryAmount buyNowPrice;
@NotNull
@org.hibernate.annotations.Type(
type = "monetary_amount_eur"
)
@org.hibernate.annotations.Columns(columns = {
@Column(name = "INITIALPRICE_AMOUNT"),
@Column(name = "INITIALPRICE_CURRENCY", length = 3)
})
protected MonetaryAmount initialPrice;
// ...
}
Класс UserType преобразует значения только для одного столбца, поэтому анно-
тация @Column не требуется. Однако классу MonetaryAmountUserType нужен доступ
к двум столбцам, поэтому в отображении поля нужно явно объявить два столбца.
Но поскольку JPA не поддерживает нескольких аннотаций @Column перед одним
свойством, их следует сгруппировать, используя аннотацию @org.hibernate.annotations.
Columns. Обратите внимание, что порядок аннотаций теперь имеет значе-
ние! Посмотрите еще раз на код класса MonetaryAmountUserType – многие операции
зависят от обращения к массиву по индексу. Элементы в PreparedStatement или
ResultSet следуют в том же порядке, что и столбцы в отображении. Заметьте так-
же, что количество столбцов не играет роли при выборе между UserType и CompositeUserType
– только желание передавать механизму запросов свойства с типами-
значениями.
Используя класс MonetaryAmountUserType, вы расширили прослойку между пред-
метной моделью в Java и схемой базы данных SQL. Оба представления теперь бо-
лее устойчивы к изменениям, и вы можете справиться с еще более необычными
требованиями, не внося изменений в классы предметной модели.
5.4. Резюме
 Мы обсудили отображение свойств классов сущностей с основными и встраиваемыми
типами.
 Узнали, как переопределять основные отображения, как менять имена столб-
цов, в которые производится отображение, как использовать вычисляемые
свойства, а также свойства со значениями по умолчанию, хранящие дату и/
или время и перечисления.
 Исследовали классы встраиваемых компонентов и процесс создания хорошо
детализированных моделей предметной области.
Резюме  149
 Научились отображать поля нескольких Java-классов, участвующих в компо-
зиции, таких как Address и City, в одну таблицу сущности.
 Узнали, как Hibernate выбирает конвертер между типами Java и SQL, а также
какие типы поддерживаются фреймворком Hibernate по умолчанию.
 Создали собственный конвертер для класса MonetaryAmount, используя стан-
дартные интерфейсы расширения JPA, а затем и низкоуровневый адаптер, на-
следующий низкоуровневый интерфейс UserType.
Глава 6
Отображение
наследования
В этой главе:
 стратегии отображения наследования;
 полиморфные ассоциации.
До сих пор мы намеренно почти ничего не говорили о наследовании. Отображение
иерархии классов в таблицы может оказаться весьма сложной задачей, и в этой
главе мы представим различные стратегии ее решения.
Основной стратегией отображения классов в таблицы базы данных может быть
«одна таблица для каждого класса хранимой сущности». Такой подход выглядит
простым и действительно отлично работает, но только пока не приходится иметь
дела с наследованием.
Наследование представляет собой такое наглядное структурное несоответствие
между объектно-ориентированным и реляционным мирами, потому что объектно-
ориентированные системы моделируют оба вида отношений: является (is a, то есть
один класс является специализацией другого) и имеет (has a, в классе определена
ссылка на экземпляр другого класса). Модели, основанные на SQL, поддержива-
ют только отношение имеет (has a); СУБД SQL не поддерживают наследования
типов, и даже когда такая поддержка имеется, она является либо нестандартной,
либо неполной.
Существуют четыре стратегии представления иерархии наследования:
 одна таблица для каждого конкретного класса и полиморфное поведение по
умолчанию во время выполнения;
 одна таблица для каждого конкретного класса, но полное исключение по-
лиморфизма и отношений наследования из схемы SQL. Для полиморфного
поведения во время выполнения необходимо использовать запросы с SQL-
инструкцией UNION;
 единая таблица для целой иерархии классов: полиморфизм поддерживает-
ся за счет денормализации схемы SQL, а определение суперкласса/подклас-
са осуществляется посредством различения строк;
Одна таблица для каждого конкретного класса и неявный полиморфизм  151
 одна таблица для каждого подкласса: отношение is a (наследования) пред-
ставлено в виде отношения has a (связь по внешнему ключу) с применением
SQL-операции JOIN.
В этой главе показан нисходящий подход к проектированию, предполагающий,
что вы начинаете с модели предметной области и постепенно пытаетесь получить
новую схему SQL. Описанные стратегии отображения могут применяться и в том
случае, когда вы работаете снизу вверх, начиная с существующих таблиц в базе
данных. По ходу изложения мы продемонстрируем пару приемов, позволяющих
работать с несовершенными схемами таблиц.
6.1. Одна таблица для каждого конкретного
класса и неявный полиморфизм
Предположим, что мы выбрали простейший из предложенных вариантов: в точности
одна таблица для каждого конкретного класса. Отобразить все свойства класса, в том
числе унаследованные, в столбцы этой таблицы можно, как показано на рис. 6.1.
ID << PK >>
CC_OWNER
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table >>
CREDITCARD
owner : String
BillingDetails
id : Long
cardNumber : String
expMonth : String
expYear : String
CreditCard
id : Long
account : String
bankname : String
swift : String
BankAccount
ID << PK >>
OWNER
ACCOUNT
BANKNAME
SWIFT
<< Table >>
BANKACCOUNT
Рис. 6.1  Отображение каждого конкретного класса
в независимую таблицу
Опираясь на такой неявный полиморфизм, каждый конкретный класс можно
отобразить как обычно, при помощи аннотации @Entity. Свойства суперкласса
по умолчанию игнорируются и не сохраняются! Чтобы встроить свойства супер-
класса в таблицы конкретных подклассов, необходимо отметить их аннотацией
@MappedSuperclass; см. листинг 6.1.
Листинг 6.1  Отображение класса BillingDetails (абстрактного суперкласса)
с неявным полиморфизмом
Файл: /model/src/main/java/org/jpwh/model/inheritance/mappedsuperclass/
BillingDetails.java
@MappedSuperclass
public abstract class BillingDetails {
@NotNull
protected String owner;
// ...
}
152  Отображение наследования
Теперь отобразим конкретные подклассы.
Листинг 6.2  Отображение класса CreditCard (конкретный подкласс)
Файл: /model/src/main/java/org/jpwh/model/inheritance/mappedsuperclass/
CreditCard.java
@Entity
@AttributeOverride(
name = "owner",
column = @Column(name = "CC_OWNER", nullable = false))
public class CreditCard extends BillingDetails {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull
protected String cardNumber;
@NotNull
protected String expMonth;
@NotNull
protected String expYear;
// ...
}
Отображение класса BankAccount выглядит аналогично, поэтому мы его опустим.
В подклассе можно переопределить отображение одного или нескольких столб-
цов суперкласса, используя аннотации @AttributeOverride или @AttributeOverrides
соответственно. В предыдущем примере столбец OWNER в таблице CREDITCARD
был переименован в CC_OWNER.
Также в суперклассе можно объявить свойство идентификатора, используя об-
щие для всех подклассов имя столбца и стратегию, чтобы не повторять их объяв-
ления. Мы не сделали этого в примере, показывая, что это необязательно.
Главная проблема неявного отображения наследования заключается в отсут-
ствии достаточной поддержки полиморфных ассоциаций. Обычно в базе данных
ассоциации представлены в виде связей по внешнему ключу. Если все подклассы
отображаются на разные таблицы, как показано в схеме на рис. 6.1, полиморфные
ассоциации с их суперклассом (абстрактным классом BillingDetails) не могут
быть представлены в виде простой связи по внешнему ключу. У вас не может быть
другой сущности, отображаемой с внешним ключом, «ссылающимся на таблицу
BILLINGDETAILS», – такой таблицы попросту нет. А это создаст проблемы для пред-
метной модели, поскольку класс BillingDetails связан с классом User отношением
ассоциации; обеим таблицам – CREDITCARD и BANKACCOUNT – понадобится внешний
ключ, ссылающийся на таблицу USERS. Ни одна из этих проблем не имеет простого
решения, поэтому придется рассмотреть альтернативную стратегию отображения.
Одна таблица для каждого конкретного класса с объединениями  153
Проблему также представляют полиморфные запросы, возвращающие экзем-
пляры всех классов, реализующих запрашиваемый интерфейс. Hibernate должен
выполнять запрос для суперкласса в виде нескольких SQL-выражений SELECT – по
одному для каждого подкласса. JPA-запрос select bd from BillingDetails bd требует
выполнения двух выражений SQL:
select
ID, OWNER, ACCOUNT, BANKNAME, SWIFT
from
BANKACCOUNT
select
ID, CC_OWNER, CARDNUMBER, EXPMONTH, EXPYEAR
from
CREDITCARD
Hibernate использует отдельный SQL-запрос для каждого конкретного под-
класса. С другой стороны, запросы для конкретных классов просты и обладают
хорошей производительностью: Hibernate выполнит только один запрос.
Другой концептуальной проблемой данной стратегии отображения является
разделение одинаковой семантики несколькими разными столбцами в разных
таблицах. Это сильно усложняет эволюцию схемы. Например, переименование
или изменение типа свойства суперкласса вызовет изменение столбцов во многих
таблицах. Большинство стандартных операций рефакторинга, предоставляемых
IDE, потребует ручной доработки, поскольку автоматизированные процедуры,
как правило, не учитывают таких особенностей, как @AttributeOverrides. Это так-
же усложнит реализацию ограничений целостности базы данных, применяемых
ко всем подклассам.
Мы советуем применять этот подход (только) для верхушки иерархии классов,
где полиморфизм на самом деле не нужен и не предвидится изменений в супер-
классе в будущем. Но это не подходит для предметной модели приложения CaveatEmptor,
где запросы и прочие сущности ссылаются на класс BillingDetails.
Большинство проблем с полиморфными запросами и ассоциациями решается
при помощи SQL-выражения UNION.
6.2. Одна таблица для каждого конкретного
класса с объединениями
Для начала рассмотрим отображение подкласса с объединением, где в качестве
абстрактного класса (или интерфейса) выступает класс BillingDetails, как
и в предыдущем разделе. В этом случае снова имеются две таблицы с повторяю-
щимися столбцами, соответствующими свойствам суперкласса в обеих: CREDITCARD
и BANKACCOUNT. Новой является стратегия наследования под названием TABLE_PER_
CLASS, объявленная в суперклассе, как показано далее.
154  Отображение наследования
Листинг 6.3  Отображение класса BillingDetails с применением стратегии
TABLE_PER_CLASS
Файл: /model/src/main/java/org/jpwh/model/inheritance/tableperclass/
BillingDetails.java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class BillingDetails {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull
protected String owner;
// ...
}
В суперклассе должны иметься идентификатор в базе данных и его отображе-
ние, чтобы все подклассы могли использовать его в своих таблицах. В отличие
от предыдущей стратегии, это условие обязательно. Обе таблицы – CREDITCARD
и BANKACCOUNT – имеют столбец первичного ключа ID. Все отображения конкретных
классов наследуют хранимые свойства суперкласса (или интерфейса). Требуется
только добавить аннотацию @Entity перед каждым подклассом.
Листинг 6.4  Отображение класса CreditCard
Файл: /model/src/main/java/org/jpwh/model/inheritance/tableperclass/Credit-
Card.java
@Entity
public class CreditCard extends BillingDetails {
@NotNull
protected String cardNumber;
@NotNull
protected String expMonth;
@NotNull
protected String expYear;
// ...
}
Помните, что схема SQL по-прежнему ничего не знает о наследовании – табли-
цы выглядят в точности, как показано на рис. 6.1.
Обратите внимание, что согласно стандарту JPA стратегия TABLE_PER_CLASS не
является обязательной, поэтому она может поддерживаться не всеми реализация-
ми JPA. Реализация также зависит от конкретного воплощения JPA – в Hibernate
она является эквивалентом отображения <union-subclass> в старом оригинальном
XML-файле метаданных Hibernate (не беспокойтесь об этом, если вам никогда не
приходилось использовать оригинальные XML-файлы Hibernate).
Одна таблица для каждого конкретного класса с объединениями  155
Если бы класс BillingDetails был конкретным, понадобилась бы дополнитель-
ная таблица для хранения экземпляров. Еще раз подчеркнем, что между таблица-
ми в базе данных по-прежнему нет никаких отношений, кроме наличия некоторых
(многих) одинаковых столбцов.
Преимущества данной стратегии отображения станут очевидны после знаком-
ства с полиморфными запросами. К примеру, запрос select bd from BillingDetails
bd генерирует следующее выражение SQL:
select
ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
ACCOUNT, BANKNAME, SWIFT, CLAZZ_
from
( select
ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
null as ACCOUNT,
null as BANKNAME,
null as SWIFT,
1 as CLAZZ_
from
CREDITCARD
union all
select
id, OWNER,
null as EXPMONTH,
null as EXPYEAR,
null as CARDNUMBER,
ACCOUNT, BANKNAME, SWIFT,
2 as CLAZZ_
from
BANKACCOUNT
) as BILLINGDETAILS
Этот запрос SELECT использует подзапрос в предложении FROM для извлечения
всех экземпляров класса BillingDetails из всех таблиц конкретных классов. Таблицы
объединяются с помощью оператора UNION, а в промежуточный результат
вставляются литералы (в данном случае это 1 и 2); они нужны фреймворку Hibernate
для создания экземпляра правильного класса из данных в конкретной запи-
си. Объединение требует, чтобы участвующие в нем запросы имели одинаковую
структуру столбцов, поэтому вместо несуществующих столбцов пришлось вста-
вить NULL. Вы спросите: действительно ли этот запрос выполнится быстрее, чем
два отдельных выражения? Здесь можно предоставить оптимизатору базы данных
найти лучший план выполнения для объединения строк из нескольких таблиц
вместо слияния результатов двух запросов в памяти, как это сделал бы механизм
полиморфной загрузки в Hibernate.
Другим гораздо более важным преимуществом является возможность приме-
нения полиморфных ассоциаций; например, теперь стало возможным отобразить
ассоциацию от класса User к классу BillingDetails. Hibernate может использовать
156  Отображение наследования
запрос с выражением UNION для имитации единой таблицы в качестве цели отобра-
жения ассоциации. Мы обсудим эту тему далее в данной главе.
Все рассмотренные до сих пор стратегии отображения не требовали дополни-
тельных соображений по поводу схемы SQL. Следующая стратегия меняет эту
ситуацию.
6.3. Единая таблица для целой иерархии классов
Иерархию классов целиком можно отобразить в одну таблицу. Эта таблица будет
содержать столбцы для всех полей каждого класса в иерархии. Конкретный под-
класс, представляемый отдельной записью, определяется значением дополнитель-
ного столбца с селектором типа или формулой. Такой подход показан на рис. 6.2.
ID << PK >>
BD_TYPE << Discriminator >>
OWNER
CARDNUMBER
EXPMONTH
EXPYEAR
ACCOUNT
BANKNAME
SWIFT
<< Table >>
id : Long BILLINGDETAILS
owner : String
BillingDetails
cardNumber : String
expMonth : String
expYear : String
CreditCard
account : String
bankname : String
swift : String
BankAccount
Рис. 6.2  Отображение целой иерархии классов в одну таблицу
Данная стратегия отображения – лучшая с точки зрения производительности
и простоты. Это самый производительный способ представления полиморфиз-
ма – как полиморфные, так и неполиморфные запросы работают быстро, – и мож-
но с легкостью писать запросы вручную. Можно получать отчеты на основе произ-
вольных запросов, не применяя сложных соединений или объединений. Эволюция
схемы происходит довольно просто.
Но есть одна главная проблема – целостность данных. Столбцы для свойств,
объявленных в подклассах, могут содержать null. Если каждый подкласс объяв-
ляет несколько свойств, которым нельзя присваивать null, отказ от ограничения
NOT NULL может стать серьезной проблемой с точки зрения корректности данных.
Представьте, что приложение требует наличия даты истечения срока действия
кредитной карты, но схема базы данных не способна это требование гарантиро-
вать, поскольку каждый столбец в таблице может иметь значение NULL. Простая
программная ошибка в приложении может привести к некорректным данным.
Другим важным аспектом является нормализация. Вы создаете функциональ-
ную зависимость между неключевыми столбцами, нарушая третью нормальную
форму. Как всегда, денормализация с целью повышения производительности мо-
жет оказаться обманчивой, поскольку приходится жертвовать долговременной
стабильностью, удобством сопровождения и гарантией целостности данных ради
сиюминутных приобретений, которые также можно достигнуть надлежащей оп-
Единая таблица для целой иерархии классов  157
тимизацией планов выполнения SQL (иначе говоря, спросите своего администра-
тора базы данных).
Для создания отображения с одной таблицей для целой иерархии классов ис-
пользуем стратегию наследования SINGLE_TABLE, как показано в листинге 6.5.
Листинг 6.5  Отображение класса BillingDetails с использованием стратегии
SINGLE_TABLE
Файл: /model/src/main/java/org/jpwh/model/inheritance/singletable/
BillingDetails.java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "BD_TYPE")
public abstract class BillingDetails {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull Hibernate игнорирует эту аннотацию при генерации схемы!
@Column(nullable = false)
protected String owner;
// ...
}
Корневой класс иерархии наследования BillingDetails автоматически отобра-
жается в таблицу BILLINGDETAILS. Наследуемые свойства суперкласса могут иметь
в схеме ограничение NOT NULL; экземпляр каждого подкласса должен содержать
какое-то значение. Особенность реализации Hibernate требует определить воз-
можность присваивания null, используя аннотацию @Column, поскольку при гене-
рации схемы Hibernate игнорирует аннотацию @NotNull из Bean Validation.
Для различения типов записей необходимо определить столбец селектора. Он
не является полем сущности – Hibernate использует его для собственных нужд.
Столбец называется BD_TYPE, а его значениями являются строки – в данном слу-
чае "CC" или "BA". Hibernate автоматически устанавливает и извлекает значения
селектора.
Если не определить столбец селектора в суперклассе, по умолчанию он будет
называться DTYPE, а его значениями будут строки. Каждый конкретный класс
в иерархии наследования может задавать свое значение селектора, как показано
в определении класса CreditCard.
Листинг 6.6  Отображение класса CreditCard
Файл: /model/src/main/java/org/jpwh/model/inheritance/singletable/
CreditCard.java
@Entity
@DiscriminatorValue("CC")
public class CreditCard extends BillingDetails {
158  Отображение наследования
@NotNull Hibernate игнорирует эту аннотацию при генерации схемы!
protected String cardNumber;
@NotNull
protected String expMonth;
@NotNull
protected String expYear;
// ...
}
Особенности Hibernate
Если не указать значения селектора явно, по умолчанию Hibernate будет исполь-
зовать полное квалифицированное имя класса, если используются XML-файлы
Hibernate, или простое имя сущности, если используются аннотации или XML-
файлы JPA. Обратите внимание, что JPA не определяет значения по умолчанию
для нестроковых селекторов; каждый производитель механизма хранения может
задавать разные значения по умолчанию. Следовательно, вы всегда должны ука-
зывать значения селектора для конкретных классов.
Отметьте каждый подкласс аннотацией @Entity, а затем отобразите поля под-
класса в столбцы таблицы BILLINGDETAILS. Помните, что схема не допускает огра-
ничений NOT NULL, поскольку в экземпляре BankAccount может не оказаться свой-
ства expMonth – в такой записи столбец EXPMONTH должен содержать значение NULL.
Hibernate игнорирует аннотацию @NotNull при формировании схемы, но проверя-
ет ее перед вставкой записи во время выполнения. Это позволяет избежать про-
граммных ошибок; никому не хочется случайно сохранить данные о кредитной
карте без даты истечения срока действия (конечно, другие приложения, не соблю-
дающие правил, смогут поместить некорректные данные в базу).
Hibernate сформирует следующий код SQL для запроса select bd from Billing-
Details bd:
select
ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
ACCOUNT, BANKNAME, SWIFT, BD_TYPE
from
BILLINGDETAILS
Для выполнения запроса к подклассу CreditCard Hibernate добавит ограниче-
ние на столбец селектора:
select
ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER
from
BILLINGDETAILS
where
BD_TYPE=’CC’
Одна таблица для каждого подкласса с использованием соединений  159
Особенности Hibernate
Иногда, особенно при работе с унаследованными схемами, просто нет возможно-
сти добавить еще один столбец селектора в таблицы сущностей. В таком случае
можно применить выражение для вычисления значения селектора в каждой стро-
ке. Формулы вычисления селектора не являются частью JPA, но в Hibernate для
этих целей имеется дополнительная аннотация @DiscriminatorFormula.
Листинг 6.7  Отображение класса BillingDetails с аннотацией
@DiscriminatorFormula
Файл: /model/src/main/java/org/jpwh/model/inheritance/singletableformula/
BillingDetails.java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@org.hibernate.annotations.DiscriminatorFormula(
"case when CARDNUMBER is not null then ‘CC’ else ‘BA’ end"
)
public abstract class BillingDetails {
// ...
}
В схеме отсутствует столбец селектора, поэтому, чтобы определить, что пред-
ставляет конкретная запись – кредитную карту или банковский счет, данное
отображение
полагается на SQL-выражение CASE/WHEN (большинство разработ-
чиков никогда не использовало подобного выражения SQL; если вы незнакомы
с ним, обратитесь к стандарту ANSI). Результатом вычисления выражения будет
литерал – CC или BA, – который должен быть объявлен в отображении соответствующего
подкласса.
Недостатки такой стратегии отображения, когда одна таблица используется
для целой иерархии, могут оказаться слишком серьезными для проекта – денор-
мализованные схемы в долгосрочной перспективе могут превратиться в тяжкое
бремя. Администратору базы данных это может совсем не понравиться. Следую-
щая стратегия отображения наследования не создает подобных проблем.
6.4. Одна таблица для каждого подкласса
с использованием соединений
Четвертый вариант – представление иерархии наследования в виде ассоциации
по внешнему ключу в SQL. Каждый класс/подкласс, включая абстрактные классы
и даже интерфейсы, объявляющий хранимые свойства, располагает собственной
таблицей.
В отличие от стратегии, где каждому конкретному классу соответствует своя
таблица, которую мы рассматривали первой, здесь таблица конкретной сущности
160  Отображение наследования
(@Entity) содержит только столбцы для ненаследуемых свойств, объявленных
в самом подклассе наряду с первичным ключом, также являющимся внешним
ключом таблицы суперкласса. Это проще, чем кажется; взгляните на рис. 6.3.
ID << PK >>
OWNER
<< Table >>
BILLINGDETAILS
ID << PK >> << FK >>
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table >>
CREDITCARD
ID << PK >> << FK >>
ACCOUNT
BANKNAME
SWIFT
<< Table >>
BANKACCOUNT
id : Long
owner : String
BillingDetails
cardNumber : String
expMonth : String
expYear : String
CreditCard
account : String
bankname : String
swift : String
BankAccount
Рис. 6.3  Отображение каждого класса иерархии
в собственную таблицу
При сохранении экземпляра подкласса CreditCard Hibernate вставляет две
записи.
Значения свойств, объявленных в суперклассе BillingDetails, сохраняют-
ся в новой записи, в таблице BILLINGDETAILS. Значения свойств, объявленных лишь
в подклассе, сохраняются в новой записи, в таблице CREDITCARD. Только общий пер-
вичный ключ объединяет две эти записи. Экземпляр подкласса может быть позже
извлечен из базы данных с использованием соединения таблиц подкласса и су-
перкласса.
Главное преимущество этой стратегии заключается в нормализации схемы
SQL. Эволюция схемы и определение ограничений целостности осуществляют-
ся довольно просто. Внешний ключ, ссылающийся на таблицу конкретного под-
класса, может представлять полиморфную ассоциацию с этим конкретным под-
классом. Используйте стратегию наследования JOINED, чтобы создать отображение
иерархии с отдельной таблицей для каждого подкласса.
Листинг 6.8  Отображение класса BillingDetails с применением стратегии
отображения JOINED
Файл: /model/src/main/java/org/jpwh/model/inheritance/joined/BillingDetails.
java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class BillingDetails {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
protected Long id;
@NotNull
protected String owner;
// ...
}
Одна таблица для каждого подкласса с использованием соединений  161
Корневой класс BillingDetails отображается в таблицу BILLINGDETAILS. Обрати-
те внимание, что в этой стратегии селектор не требуется.
В подклассах не нужно указывать столбец для соединения, если столбец пер-
вичного ключа таблицы подкласса имеет (или предполагается, что имеет) то же
имя, что и столбец первичного ключа в таблице суперкласса.
Листинг 6.9  Отображение класса BankAccount (конкретный класс)
Файл: /model/src/main/java/org/jpwh/model/inheritance/joined/
BankAccount.java
@Entity
public class BankAccount extends BillingDetails {
@NotNull
protected String account;
@NotNull
protected String bankname;
@NotNull
protected String swift;
// ...
}
В этой сущности отсутствует свойство-идентификатор – она автоматически на-
следует свойство и столбец ID от суперкласса, и Hibernate знает, как соединить
таблицы,
если потребуется извлечь экземпляры класса BankAccount. Конечно, мож-
но явно задать имя столбца.
Листинг 6.10  Отображение класса CreditCard
Файл: /model/src/main/java/org/jpwh/model/inheritance/joined/CreditCard.java
@Entity
@PrimaryKeyJoinColumn(name = "CREDITCARD_ID")
public class CreditCard extends BillingDetails {
@NotNull
protected String cardNumber;
@NotNull
protected String expMonth;
@NotNull
protected String expYear;
// ...
}
Столбцы первичных ключей в таблицах BANKACCOUNT и CREDITCARD также облада-
ют ограничением по внешнему ключу, ссылающемуся на первичный ключ табли-
цы BILLINGDETAILS.
162  Отображение наследования
Hibernate использует внешнее соединение SQL для запроса select bd from
BillingDetails bd:
select
BD.ID, BD.OWNER,
CC.EXPMONTH, CC.EXPYEAR, CC.CARDNUMBER,
BA.ACCOUNT, BA.BANKNAME, BA.SWIFT,
case
when CC.CREDITCARD_ID is not null then 1
when BA.ID is not null then 2
when BD.ID is not null then 0
end
from
BILLINGDETAILS BD
left outer join CREDITCARD CC on BD.ID=CC.CREDITCARD_ID
left outer join BANKACCOUNT BA on BD.ID=BA.ID
Предложение CASE ... WHEN определяет наличие (либо отсутствие) строк в таблицах
подклассов CREDITCARD и BANKACCOUNT, благодаря чему Hibernate может опре-
делить конкретный подкласс для каждой записи в таблице BILLINGDETAILS.
Для более простого запроса к подклассу, такого как select cc from CreditCard cc,
Hibernate использует внутреннее соединение:
select
CREDITCARD_ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER
from
CREDITCARD
inner join BILLINGDETAILS on CREDITCARD_ID=ID
Как видите, подобную стратегию отображения уже труднее реализовать вруч-
ную – даже создавать отчеты на основе произвольных запросов становится слож-
нее. Важно принять этот нюанс во внимание, если вы планируете смешивать код
Hibernate и код SQL, написанный вручную.
Более того, хотя эта стратегия кажется простой, наш опыт говорит, что для
сложных иерархий классов производительность может оказаться неприемлемой.
Запросы требуют соединения нескольких таблиц или многих последовательных
операций чтения.
Наследование с соединениями и селекторами
Для реализации стратегии InheritanceType.JOINED Hibernate не требуется нали-
чие в базе данных специального столбца селектора. Спецификация JPA также
не содержит никаких требований на этот счет. Предложение CASE... WHEN в SQL-
выражении SELECT – всего лишь ловкий способ определить тип сущности для каж-
дой извлекаемой записи. Тем не менее некоторые примеры JPA, которые могут
вам встретиться, используют и стратегию InheritanceType.JOINED, и отображение
@DiscriminatorColumn. Очевидно, другие реализации JPA не используют предложе-
ния CASE ... WHEN и полагаются на значение селектора даже при использовании
Смешение стратегий отображения наследования  163
стратегии InheritanceType.JOINED. Hibernate не требует наличия селектора, но мо-
жет использовать объявление @DiscriminatorColumn даже со стратегией отображения
JOINED. Если вы предпочитаете игнорировать отображение селектора для
стратегии JOINED (оно игнорировалось в ранних версиях Hibernate), можно ак-
тивировать параметр конфигурации hibernate.discriminator.ignore_explicit_for_
joined.
Прежде чем показать, когда и какую стратегию выбирать, давайте рассмотрим
смешение стратегий отображения наследования в одной иерархии классов.
6.5. Смешение стратегий отображения
наследования
Целую иерархию классов можно отобразить с помощью стратегий TABLE_PER_CLASS,
SINGLE_TABLE или JOINED. Но их нельзя смешивать – например, переключаться со
стратегии отображения одной таблицы для целой иерархии классов с селектором
на нормализованную стратегию с одной таблицей для каждого подкласса. Выбрав
стратегию наследования, вы должны твердо ее придерживаться.
Однако иногда, используя некоторые приемы, все же можно переключить страте-
гию отображения конкретного подкласса. Например, можно отобразить иерархию
классов в единственную таблицу, но для конкретного подкласса выбрать стратегию
с отдельной таблицей и внешним ключом – так же, как в стратегии с таблицей для
каждого подкласса. Взгляните на схему на рис. 6.4.
ID << PK >>
BD_TYPE << Discriminator >>
OWNER
ACCOUNT
BANKNAME
SWIFT
<< Table >>
BILLINGDETAILS
CREDITCARD_ID << PK >> << FK >>
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table >>
CREDITCARD
id : Long
owner : String
BillingDetails
cardNumber : String
expMonth : String
expYear : String
CreditCard
account : String
bankname : String
swift : String
BankAccount
Рис. 6.4  Выделение подкласса
в собственную дополнительную таблицу
164  Отображение наследования
Отобразим суперкласс BillingDetails со стратегией InheritanceType.SINGLE_TABLE,
как мы делали это раньше. Теперь отобразим в отдельную таблицу подкласс,
который нужно выделить из общей таблицы.
Листинг 6.11  Отображение класса CreditCard
Файл: /model/src/main/java/org/jpwh/model/inheritance/mixed/CreditCard.java
@Entity
@DiscriminatorValue("CC")
@SecondaryTable(
name = "CREDITCARD",
pkJoinColumns = @PrimaryKeyJoinColumn(name = "CREDITCARD_ID")
)
public class CreditCard extends BillingDetails {
@NotNull JPA игнорирует эту аннотацию при генерации DDL; стратегия – SINGLE_TABLE!
@Column(table = "CREDITCARD", nullable = false) Переопределение основной таблицы
protected String cardNumber;
@Column(table = "CREDITCARD", nullable = false)
protected String expMonth;
@Column(table = "CREDITCARD", nullable = false)
protected String expYear;
// ...
}
Аннотации @SecondaryTable и @Column объединяют некоторые свойства и сооб-
щают Hibernate, что их нужно брать из дополнительной таблицы. Все свойства,
которые вы переместили в дополнительную таблицу, должны отображаться с име-
нем этой таблицы. Для этого применяется параметр table аннотации @Column, не
показанный ранее. У такого отображения есть множество применений, и вы встре-
титесь с ним позже в этой книге. В данном примере оно выделяет поля класса
CreditCard из общей таблицы в таблицу CREDITCARD.
Столбец CREDITCARD_ID в то же время является первичным ключом, а также име-
ет ограничение по внешнему ключу, ссылающемуся на столбец ID единой таблицы
иерархии. Если не указать название столбца первичного ключа в дополнительной
таблице для соединения, по умолчанию будет выбрано имя первичного ключа еди-
ной таблицы наследования – в данном случае это ID.
Помните, что при выборе стратегии InheritanceType.SINGLE_TABLE все столбцы
подклассов могут содержать значение null. Одним из преимуществ данного спосо-
ба отображения является возможность гарантии целостности данных с помощью
объявления ограничения NOT NULL для столбцов таблицы CREDITCARD.
Во время работы приложения Hibernate выполнит внешнее соединение для по-
лиморфного извлечения экземпляров BillingDetails и всех его подклассов:
select
ID, OWNER, ACCOUNT, BANKNAME, SWIFT,
EXPMONTH, EXPYEAR, CARDNUMBER,
Наследование и встраиваемые классы  165
BD_TYPE
from
BILLINGDETAILS
left outer join CREDITCARD on ID=CREDITCARD_ID
Вы также можете применить этот прием к остальным подклассам иерархии. Но
если иерархия классов слишком обширна, внешнее соединение может стать проблемой.
Некоторые СУБД (например, Oracle) ограничивают количество таблиц,
участвующих в операции соединения. Для такой обширной иерархии, возможно,
предпочтительнее выбрать иную стратегию извлечения, которая немедленно вы-
полнит второй запрос SQL вместо внешнего соединения.
Особенности Hibernate
На момент написания книги переключение стратегии извлечения для данного
отображения было невозможно ни при помощи аннотаций JPA, ни при помощи
аннотаций Hibernate, поэтому придется отобразить класс в оригинальном XML-
файле отображения Hibernate:
Файл: /model/src/main/resources/inheritance/mixed/FetchSelect.hbm.xml
<subclass name="CreditCard"
discriminator-value="CC">
<join table="CREDITCARD" fetch="select">
...
</join>
</subclass>
До сих пор мы говорили лишь о наследовании сущностей. Несмотря на то что
спецификация JPA ничего не говорит о наследовании и полиморфизме встраи-
ваемых (@Embeddable) классов, Hibernate предлагает свою стратегию отображения
компонентов.
Особенности Hibernate
6.6. Наследование и встраиваемые классы
Встраиваемый класс – это компонент сущности-владельца; следовательно, к ним
не применимы обычные правила отображения наследования сущностей, пред-
ставленные в этой главе. Используя расширенные возможности Hibrnate, можно
отобразить встраиваемый класс, наследующий некоторые хранимые поля от су-
перкласса (или интерфейса). Рассмотрим два новых атрибута аукционного това-
ра – вес и габариты.
Габариты товара – это ширина, высота и глубина, выраженные в некоторой си-
стеме мер и обозначающего ее символа – например, дюймов (") или сантиметров
(cm). Вес товара также включает единицу измерения – например, фунты (lbs) или
166  Отображение наследования
килограммы (kg). Чтобы выделить общие атрибуты (название и символ) едини-
цы измерения, можно определить суперкласс Measurement, общий для Dimension
и Weight.
Листинг 6.12  Отображение встраиваемого абстрактного суперкласса
Measurement
Файл: /model/src/main/java/org/jpwh/model/inheritance/embeddable/
Measurement.java
@MappedSuperclass
public abstract class Measurement {
@NotNull
protected String name;
@NotNull
protected String symbol;
// ...
}
Примените аннотацию @MappedSuperclass к суперклассу встраиваемого класса,
который требуется отобразить, как к обычной сущности, и подклассы унаследуют
свойства этого класса как хранимые свойства.
Классы Dimensions и Weight определяются как встраиваемые (@Embeddable).
В классе Dimensions нужно переопределить все атрибуты суперкласса, добавив
префикс столбца.
Листинг 6.13  Отображение класса Dimensions
Файл: /model/src/main/java/org/jpwh/model/inheritance/embeddable/
Dimensions.java
@Embeddable
@AttributeOverrides({
@AttributeOverride(name = "name",
column = @Column(name = "DIMENSIONS_NAME")),
@AttributeOverride(name = "symbol",
column = @Column(name = "DIMENSIONS_SYMBOL"))
})
public class Dimensions extends Measurement {
@NotNull
protected BigDecimal depth;
@NotNull
protected BigDecimal height;
@NotNull
protected BigDecimal width;
// ...
}
Наследование и встраиваемые классы  167
Без этого переопределения класс Item, содержащий Dimension и Weight, отобра-
жался бы в таблицу с конфликтующими названиями столбцов. Далее показан
класс Weight; его отображение также добавляет префикс к именам столбцов (для
единообразия мы решили избежать конфликта с предыдущим переопределением).
Листинг 6.14  Отображение класса Weight
Файл: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Weight.
java
@Embeddable
@AttributeOverrides({
@AttributeOverride(name = "name",
column = @Column(name = "WEIGHT_NAME")),
@AttributeOverride(name = "symbol",
column = @Column(name = "WEIGHT_SYMBOL"))
})
public class Weight extends Measurement {
@NotNull
@Column(name = "WEIGHT")
protected BigDecimal value;
// ...
}
Сущность-владелец Item определяет два хранимых встроенных поля.
Листинг 6.15  Отображение класса Item
Файл: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Item.java
@Entity
public class Item {
protected Dimensions dimensions;
protected Weight weight;
// ...
}
Это отображение показано на рис. 6.5. Другой способ разрешения конфликта
имен заключается в переопределении названий столбцов в Measurement для встро-
енных свойств в классе Item, как показано в разделе 5.2. Но вместо этого мы пред-
почитаем переопределить их один раз во встроенных (@Embeddable) классах, чтобы
пользователям этих классов не пришлось разрешать этого конфликта.