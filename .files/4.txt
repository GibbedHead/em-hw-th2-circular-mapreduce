СТРАТЕГИИ
ОТОБРАЖЕНИЯ
Эта часть целиком посвящена настоящему ORM – от классов и полей до таблиц
и столбцов. Глава 4 начинается с рассмотрения обычных отображений полей
и классов и объясняет, как отображать хорошо детализированные Java-модели
предметной области. Далее, в главе 5, вы узнаете, как отображать простые поля
и встраиваемые компоненты, а также как управлять отображением типов между
Java и SQL. В главе 6 вы научитесь отображать в базу данных иерархии наследо-
вания сущностей, используя четыре основные стратегии отображения наследова-
ния; вы также познакомитесь с отображением полиморфных ассоциаций. Глава 7
целиком посвящена отображению коллекций и ассоциаций между сущностями –
вы узнаете, как отображаются хранимые коллекции, коллекции базовых и встраи-
ваемых типов, а также простые ассоциации многие к одному и один ко многим меж-
ду сущностями. В главе 8 вы углубитесь в изучение продвинутых отображений
ассоциаций сущностей – вы узнаете об отображении ассоциаций один к одному,
вариантах отображения один ко многим, ассоциациях многие ко многим и тернар-
ных отношения между сущностями. Наконец, глава 9 будет наиболее интересной
для тех, кому необходимо внедрить Hibernate в существующее приложение, или
если вам приходится работать с унаследованной схемой базы данных и написан-
ным вручную SQL.
Прочитав эту часть книги, вы будете готовы быстро создавать даже самые слож-
ные отображения, используя верную стратегию. Вы узнаете, как решается пробле-
ма с отображением наследования и как отображать коллекции и ассоциации. Вы
также научитесь настраивать и модифицировать Hibernate для интеграции с лю-
бой существующей схемой базы данных или приложением.
Глава 4
Отображение
хранимых классов
В этой главе:
 понятие сущности и типа-значения (value type);
 отображение классов сущностей с идентичностью;
 настройка отображений на уровне сущности.
В этой главе представлены некоторые фундаментальные свойства отображений
и объясняется, как отображать классы сущностей в таблицы SQL. Мы покажем
и обсудим, как обращаться с идентичностью в базе данных и первичными клю-
чами, как использовать множество других настроек загрузки и сохранения эк-
земпляров классов предметной модели в Hibernate. Все примеры отображений
используют JPA-аннотации. Однако, прежде чем начать, мы определим коренное
различие между сущностями и типами-значениями и объясним, как подходить
к объектно-реляционному отображению предметной модели.
Главные нововведения в JPA2
С помощью элемента <delimited-identifiers> в конфигурационном файле persistence.
xml можно включить глобальное экранирование всех имен в сгенерирован-
ных SQL-выражениях.
4.1. Понятие сущностей и типов-значений
Рассматривая модель предметной области, можно заметить различие между клас-
сами: те, что представляют бизнес-объекты (термин объект употреблен здесь
в своем обычном смысле), кажутся более важными. Например, классы Item,
Category и User – это сущности реального мира, которые вы пытаетесь представить
(обратитесь к рис. 3.3, чтобы увидеть примерную модель предметной области).
Другие типы в предметной модели, такие как Address, String и Integer, кажутся
менее важными. В этом разделе мы посмотрим, что значит использовать хорошо
Понятие сущностей и типов-значений  89
детализированную модель предметной области, делая различия между сущностя-
ми и типами-значениями.
4.1.1. Хорошо детализированные модели
предметной области
Основной целью Hibernate является поддержка хорошо детализированных и на-
сыщенных предметных моделей. Это одна из причин, по которой мы используем
POJO. Проще говоря, хорошо детализированный означает больше классов, чем
таблиц.
Например, в предметной модели у пользователя может быть домашний адрес.
В базе данных может быть одна таблица USER со столбцами HOME_STREET, HOME_CITY
и HOME_ZIPCODE. (Помните проблему SQL-типов, которую мы обсуждали в разде-
ле 1.2.1?)
В предметной модели можно было бы применить тот же подход и представить
адрес в виде трех строковых свойств класса User. Но гораздо лучше смоделировать
это в виде класса Address, чтобы у пользователя было свойство homeAddress. Такая
модель предметной области обладает лучшей связностью и большими возможно-
стями для повторного использования кода, при этом она гораздо понятнее, чем
SQL с негибкой системой типов.
JPA подчеркивает полезность хорошо детализированных классов для реализа-
ции типобезопасности и поведения. Например, многие моделируют адрес электронной
почты как строковое свойство в классе User. Более сложным подходом
было бы определение класса EmailAddress, добавляющего высокоуровневую се-
мантику и поведение, – он мог бы предоставлять метод prepareMail() (у него не
должно быть метода sendMail(), потому что класс предметной модели не должен
зависеть от почтовой подсистемы).
Эта проблема детализации приводит нас к различию, имеющему чрезвычай-
ную важность в ORM. В Java все классы равны: у каждого экземпляра свои иден-
тичность и жизненный цикл. Когда вы добавляете поддержку долговременного
хранения, может случиться так, что некоторые объекты не имеют собственной
идентичности и жизненного цикла – они зависят от других объектов. Давайте рас-
смотрим пример.
4.1.2. Определение сущностей приложения
В одном доме живут два человека, и оба регистрируют учетные записи в приложе-
нии CaveatEmptor. Назовем их Джон (John) и Джейн (Jane).
Каждая учетная запись представлена экземпляром User. Экземпляры User долж-
ны загружаться, сохраняться и удаляться независимо, соответственно, User явля-
ется классом сущности, а не типом-значением. Находить классы сущностей легко.
У класса User есть поле homeAddress – ассоциация с классом Address. Ссылаются
ли оба экземпляра User во время выполнения на один и тот же экземпляр Address,
или каждый экземпляр User ссылается на свой собственный экземпляр Address?
Имеет ли значение, что Джейн и Джон живут в одном доме?
90  Отображение хранимых классов
На рис. 4.1 показано, как два экземпляра User делят один экземпляр Address.
(Это UML-диаграмма объектов, а не классов.) Если объект Address должен под-
держивать разделяемую ссылку во время выполнения, это – тип сущности. У эк-
земпляра Address свой жизненный цикл; его нельзя удалить, когда Джон удаляет
свою учетную запись (User), – у Джейн может оставаться ссылка на этот объект
Address.
username="johndoe"
lastname="Doe"
jd: User
street="Some Street"
zipCode=12345
city="Some City"
home: Address
homeAddress
username="janeroe"
lastname="Roe"
jr: User
homeAddress
firstname="John"
firstname="Jane"
Рис. 4.1  Два экземпляра User
ссылаются на один экземпляр Address
Рассмотрим теперь альтернативную модель, где каждый объект User ссылается
на собственный экземпляр homeAddress, как показано на рис. 4.2. В этом случае
можно сделать объект Address зависимым от объекта User: он становится типом-
значением.
Когда Джон удаляет свою учетную запись (User), можно безопасно удалить его
экземпляр Address. Никто больше не будет ссылаться на него.
username="johndoe"
lastname="Doe"
jd: User
street="Some Street"
zipCode=12345
city="Some City"
home1: Address
homeAddress
username="janeroe"
lastname="Roe"
jr: User
homeAddress street="Some Street"
zipCode=12345
city="Some City"
home2: Address
firstname="John"
firstname="Jane"
Рис. 4.2  У каждого из двух экземпляров User
свой, зависимый экземпляр Address
В результате мы приходим к следующему коренному различию:
 экземпляр типа сущности можно извлечь, используя его хранимую идентич-
ность – например, экземпляры User, Item или Category. Ссылка на экземпляр
сущности (указатель в JVM) сохраняется как ссылка в базе данных (значе-
ние, ограниченное внешним ключом). У экземпляра сущности собственный
жизненный цикл; он может существовать независимо от остальных сущно-
Понятие сущностей и типов-значений  91
стей. Выбранные классы предметной модели отображаются как типы сущ-
ностей;
 у экземпляра типа-значения отсутствует хранимая идентичность; он при-
надлежит экземпляру сущности. Его время жизни определяется экземпля-
ром сущности-владельца. Тип-значение не поддерживает разделения ссы-
лок. Наиболее очевидные типы-значения – это все классы, объявленные
в JDK, такие как String, Integer, а также все примитивные типы. Вы также
можете отображать ваши классы модели предметной области как типы-зна-
чения – например, Address и MonetaryAmount.
Прочитав спецификацию JPA, можно обнаружить там аналогичные понятия.
Только типы-значения в JPA называются базовыми типами (basic property types)
или встраиваемыми классами (embeddable classes). Мы вернемся к этому в следующей
главе; сейчас сфокусируемся на сущностях.
Определение классов сущностей и типов-значений в модели предметной обла-
сти не происходит спонтанно, но следует определенной процедуре.
4.1.3. Разделение сущностей и типов-значений
Добавление стереотипов (механизма расширения UML) в UML-диаграмму клас-
сов иногда помогает сразу отличить сущность от типа-значения. Такой подход так-
же заставит вас думать об этом различии для всех классов, что является первым
шагом к оптимальному отображению и хорошей производительности уровня хра-
нения. Пример показан на рис. 4.3.
<<Entity>>
Item
<<Entity>>
seller User
0..*
<< Value type >>
Address
home
<< Entity >>
Bid 0..*
bidder
0..*
Рис. 4.3  Стереотипы сущностей и типов-значений
Очевидно, классы User и Item – сущности. У каждого своя идентичность, на их
экземпляры ссылается множество других экземпляров (разделяемые ссылки), их
отрезки жизни независимы.
Отметить класс Address как тип-значение тоже легко – один экземпляр User ссы-
лается на конкретный экземпляр Address. Это легко понять, поскольку ассоциация
представлена как композиция и экземпляр User целиком отвечает за жизнь экземпляра
Address, на который он ссылается. Таким образом, больше никто не может ссы-
латься на данный экземпляр Address, и ему не нужна собственная идентичность.
Проблемы могут возникнуть с классом Bid. Ромбовидная ассоциация между
классами Bid и Item в объектно-ориентированном моделировании называется
композицией. Таким образом, объект Item является владельцем всех экземпляров
Bid и хранит коллекцию ссылок. На первый взгляд это кажется разумным, ведь
предложения цен за товар на аукционе бесполезны, когда товара уже нет.
92  Отображение хранимых классов
Но что, если во время будущего расширения модели предметной области по-
надобится коллекция User#bids, в которой содержались бы все предложения цен,
сделанные конкретным пользователем? На данном этапе ассоциация между Bid
и User однонаправленная – в Bid есть ссылка bidder. Но что, если она будет двуна-
правленной?
В таком случае придется использовать разделяемую ссылку на экземпляры Bid,
поэтому класс Bid должен быть сущностью. Хотя у него зависимый жизненный
цикл, он должен обладать собственной идентичностью для поддержания (в буду-
щем) разделяемых ссылок.
Вы часто будете сталкиваться с такими вариантами смешанного поведения; пер-
вое, что вы должны делать, – объявлять все как тип-значение и переводить класс
в разряд сущностей лишь при крайней необходимости. Попробуйте упростить ас-
социации – хранимые коллекции, к примеру, часто добавляют сложности, не давая
никаких преимуществ. Вместо отображения коллекций User#bids и Item#bids мож-
но было бы создать запросы для получения всех предложений цены за товар и всех
предложений цены конкретного пользователя. Ассоциация на UML-диаграмме
была бы направлена от класса Bid в сторону классов Item и User, и она была бы
только однонаправленной. Класс Bid имел бы стереотип <<Value type>>. Мы еще
вернемся к этому вопросу в главе 7.
Далее на основе диаграммы модели предметной области создаются POJO для
всех сущностей и типов-значений. Необходимо обратить внимание на три вещи:
 разделяемые ссылки – избегайте разделяемых ссылок на экземпляры ти-
пов-значений при создании классов POJO. Например, убедитесь, что только
один объект User может ссылаться на объект Address. Можно сделать класс
Address неизменяемым, убрав общедоступный метод setUser(), и гаранти-
ровать целостность отношения при помощи общедоступного конструктора
с аргументом User. Конечно, конструктор без аргументов, возможно защи-
щенный, тоже придется объявить, чтобы, как обсуждалось в предыдущей
главе, Hibernate мог создавать экземпляры;
 зависимости жизненного цикла – при удалении объекта User вместе с ним
должен удаляться зависимый объект Address. Метаданные хранения будут
включать правила каскадирования для всех подобных зависимостей, чтобы
Hibernate (или база данных) могла позаботиться об удалении ненужных
объектов Address. Соответственно, разрабатывая прикладные процедуры
и пользовательский интерфейс, вы должны учитывать подобные зависи-
мости;
 идентичность – в большинстве случаев классам сущностей нужно свой-
ство-идентификатор. У типов-значений (и, конечно, классов из JDK, таких
как String и Integer) поле идентификатора отсутствует, т. к. эти объекты
идентифицируются через сущность-владельца.
Мы вернемся к ссылкам, ассоциациям и правилам жизненного цикла позже,
когда будем обсуждать более продвинутые отображения в следующих главах.
А пока нашей следующей темой будут идентичность и свойства-идентификаторы.
Отображение сущностей с идентичностью  93
4.2. Отображение сущностей с идентичностью
Отображение сущностей с идентичностью требует понимания различий между
равенством и идентичностью в Java. Только усвоив суть этих понятий, можно пе-
реходить к примеру с классом сущности и его отображением. После этого мы смо-
жем углубиться в детали: выбрать первичный ключ, настроить генераторы клю-
чей и в итоге пройтись по стратегиям генератора идентификаторов. Но прежде
чем начать обсуждение таких понятий, как идентичность в базе данных (database
identity) и как JPA управляет сущностями, разберемся с различиями между иден-
тичностью и равенством Java-объектов.
4.2.1. Идентичность и равенство в Java
Java-разработчки понимают разницу между идентичностью и равенством Java-
объектов. Понятие идентичности объектов (==) определяется виртуальной маши-
ной Java. Две ссылки идентичны, если они указывают на одну область памяти.
С другой стороны, понятие равенства объектов определяется методом equals()
класса. Равенство также часто называют эквивалентностью. Эквивалентность
означает, что два различных (неидентичных) экземпляра имеют одно значение –
одинаковое состояние. Два различных экземпляра String эквивалентны, если
представляют одинаковую последовательность символов, даже если каждая за-
нимает свою область памяти в виртуальной машине. (Если вы Java-гуру, то мы
готовы согласиться, что String – это особый случай. Представьте, что мы взяли
другой класс в качестве примера.)
Долговременное хранение усложняет эту картину. С точки зрения объектно-
реляционной модели, хранимая сущность – это представление в памяти конкрет-
ной записи (записей) из таблицы (таблиц) базы данных. Наряду с идентичностью
и равенством Java мы должны дать определение идентичности в базе данных. Те-
перь у вас есть три правила различения ссылок:
 объекты идентичны, если они занимают одну область памяти в JVM. Это
проверяется оператором a == b. Это понятие известно как объектная иден-
тичность (object identity);
 объекты равны, если их состояние одинаково, что определяется методом
a.equals(Object b). Классы, явно не переопределяющие этого метода, насле-
дуют реализацию в java.lang.Object, которая сравнивает идентичность объ-
ектов с помощью ==. Это понятие известно как равенство объектов (object
equality);
 объекты, сохраненные в базу данных, идентичны, если находятся в одной
таблице и у них одинаковый первичный ключ. На стороне Java это понятие
известно как идентичность в базе данных (database identity).
Теперь мы должны рассмотреть, как идентичность в базе данных соотносится
с объектной идентичностью и как идентичность в базе данных представляется
в метаданных отображения. В качестве примера отобразим сущность предметной
модели.
94  Отображение хранимых классов
4.2.2. Первый класс сущности и его отображение
В предыдущей главе мы немножко слукавили – аннотации @Entity недостаточно
для отображения хранимого класса. Вам также потребуется аннотация @Id, как по-
казано в листинге 4.1.
Листинг 4.1  Отображаемый класс сущности Item
со свойством-идентификатором
Файл: /model/src/main/java/org/jpwh/model/simple/Item.java
@Entity
public class Item {
@Id
@GeneratedValue(generator = "ID_GENERATOR")
protected Long id;
public Long getId() { Необязательный, но полезный
return id;
}
}
Это самый простой класс сущности, отмеченный аннотацией @Entity как «при-
годный к сохранению», с аннотацией @Id, отображающей свойство-идентифика-
тор в первичный ключ в базе данных. По умолчанию класс отображается в табли-
цу с именем ITEM.
Каждый класс сущности должен иметь поле @Id; таким способом JPA раскры-
вает приложению идентичность сущностей в базе данных. Мы не показываем
свойство-идентификатор на диаграммах, так как считаем, что оно есть у каждого
класса сущности. В наших примерах мы всегда даем такому свойству имя id. Это
хорошая практика; используйте одинаковое имя для свойства-идентификатора во
всех классах предметной модели. Если больше ничего не указывать, это поле будет
отображено в столбец первичного ключа ID таблицы ITEM.
Во время загрузки и сохранения объектов Hibernate будет обращаться к полю
идентификатора напрямую, минуя методы чтения/записи. Поскольку @Id нахо-
дится над полем класса, Hibernate по умолчанию сделает хранимым каждое поле
в классе. В данном случае действует следующее правило JPA: если аннотация @Id
расположена над полем класса, реализация JPA будет обращаться к полям класса
напрямую и по умолчанию считать их все частью сохраняемого состояния. Позже
в этой главе вы узнаете, как это переопределяется. По нашему опыту доступ к по-
лям класса часто является лучшим вариантом, т. к. дает больше свободы в проек-
тировании методов доступа.
Нужен ли (общедоступный) метод чтения для свойства-идентификатора? Во-
обще, приложение часто использует идентификаторы в базе данных как удобный
указатель на конкретный экземпляр, даже вне уровня хранения. Например, веб-
приложение обычно показывает пользователю экран результатов поиска в виде
списка кратких описаний. Когда пользователь выбирает конкретный элемент,
приложению может понадобиться извлечь выбранный элемент, и обычным делом
Отображение сущностей с идентичностью  95
является выполнение поиска по идентификатору для этой цели. Вы наверняка
уже использовали идентификаторы подобным образом даже в приложениях, ис-
пользующих JDBC.
Нужен ли метод записи? Значения первичного ключа никогда не изменяются,
поэтому не следует разрешать модификацию значения свойства-идентификатора.
Hibernate не будет обновлять столбец первичного ключа, и вам не стоит создавать
общедоступный метод записи для идентификатора сущности.
Java-тип поля идентификатора, java.lang.Long в предыдущем примере, зависит
от типа столбца первичного ключа таблицы ITEM и от того, как создаются значения
ключа. Это подводит нас к аннотации @GeneratedValue и первичным ключам в целом.
4.2.3. Выбор первичного ключа
Идентификатор сущности в базе данных отображается в первичный ключ табли-
цы, поэтому сначала мы должны немного узнать о первичных ключах, отложив
отображения в сторону.
Потенциальный ключ (candidate key) – это столбец или множество столбцов,
которые можно использовать для идентификации конкретной записи в таблице.
Чтобы стать первичным ключом, потенциальный ключ должен удовлетворять
следующим требованиям:
 значение любого столбца потенциального ключа не может быть null. Невоз-
можно идентифицировать что-либо с помощью неизвестных данных, и в ре-
ляционной модели отсутствует значение null. Некоторые SQL-системы
позволяют определять (составной) первичный ключ, значения столбцов
которого могут быть null, так что будьте осторожнее;
 значение столбца (или столбцов) потенциального ключа должно быть уни-
кальным для любой записи;
 значение столбца (или столбцов) потенциального ключа никогда не обнов-
ляется – оно неизменяемо.
Должен ли первичный ключ быть неизменяемым?
Реляционная модель утверждает, что потенциальный ключ должен быть уникаль-
ным и несократимым (никакое подмножество атрибутов ключа не может быть
уникальным). Кроме того, выбор потенциального ключа в качестве первичного –
это дело вкуса. Но Hibernate рассчитывает, что потенциальный ключ, выбранный
в качестве первичного, неизменяем. Hibernate не позволяет обновить значение
первичного ключа; попробовав обойти это требование, вы неизбежно столкне-
тесь с проблемами в механизмах кэширования и проверки состояния объектов
в Hibernate. Если ваша схема базы данных опирается на обновляемые первичные
ключи (и, возможно, использует ограничение внешнего ключа ON UPDATE CASCADE), вы
должны поменять схему прежде, чем она станет работать с Hibernate.
Если в таблице есть лишь один идентифицирующий атрибут, он по определению
является первичным ключом. Но несколько столбцов или комбинаций столбцов
96  Отображение хранимых классов
также может удовлетворять этим требованиям в конкретной таблице; вы должны
сделать выбор между потенциальными ключами, определив лучший первичный
ключ для таблицы. Потенциальные ключи, не выбранные в качестве первичного
ключа, следует объявить уникальными, если их значения действительно уникаль-
ны (но они могут быть изменяемыми).
Многие старые модели данных SQL используют естественные первичные клю-
чи. Естественный ключ (natural key) – это ключ, имеющий смысл в предметной
области: атрибут (или комбинация атрибутов), уникальный в силу семантики
предметной области. Примерами естественных ключей могут служить номер со-
циального страхования в США и австралийский налоговый номер. Отличить на-
туральный ключ довольно просто: если потенциальный ключ имеет смысл вне
контекста базы данных, это натуральный ключ, независимо от того, был ли он сге-
нерирован автоматически. Подумайте о пользователях приложения – если они об-
ращаются к ключевому атрибуту, когда говорят о приложении или работают с ним,
это естественный ключ: «Можешь прислать мне изображение товара #123-abc?»
Опыт показывает, что рано или поздно естественные первичные ключи создают
проблемы. Хороший первичный ключ должен быть уникальным, неизменяемым
и никогда не иметь значения null. Немногие атрибуты сущностей удовлетворяют
этим требованиям, а те, что удовлетворяют, не могут эффективно индексироваться
базами данных SQL (хотя это деталь реализации, и она не должна быть решающим
фактором за или против выбора конкретного ключа). Кроме того, нужно быть уве-
ренным, что потенциальный ключ никогда не изменится за время существования
базы данных. Изменение значения (или даже определения) первичного ключа,
а также всех ссылающихся на него внешних ключей является неприятной задачей.
Рассчитывайте на то, что ваша схема базы данных просуществует десятилетия,
даже если само приложение – нет.
Кроме того, часто естественные ключи получаются только путем соединения
нескольких столбцов в составной (composite) естественный ключ. Такие состав-
ные ключи, несмотря на свою полезность для некоторых артефактов схемы (таких
как промежуточная таблица в отношении многие ко многим), потенциально могут
усложнить сопровождение, выполнение произвольных запросов и эволюцию схе-
мы. Мы продолжим обсуждение составных ключей позже, в разделе 9.2.1.
По этим причинам мы настоятельно рекомендуем использовать искусствен-
ные идентификаторы, называемые также суррогатными ключами (surrogate key).
Суррогатные ключи не имеют смысла для предметной области – они хранят уни-
кальные значения, сформированные базой данных или приложением. В идеале
пользователи приложения не видят и не ссылаются на значения этого ключа: они
являются частью внутреннего устройства системы. Добавление столбца суррогат-
ного ключа также уместно в распространенной ситуации, когда потенциальные
ключи отсутствуют. Другими словами, (почти) каждая таблица схемы должна
иметь выделенный столбец суррогатного первичного ключа только для этой цели.
Существует несколько хорошо известных подходов к формированию значений
суррогатного ключа. Настройка осуществляется с помощью вышеупомянутой ан-
нотации @GeneratedValue.
Отображение сущностей с идентичностью  97
4.2.4. Настройка генераторов ключей
Свойство-идентификатор класса сущности обязательно должно отмечаться ан-
нотацией @Id. Если за ней не следует аннотация @GeneratedValue, реализация JPA
решит, что вы берете на себя задачу формирования и присваивания значений
идентификатора перед сохранением экземпляра. Мы называем это идентифи-
катором, назначенным приложением. Назначение идентификаторов сущностей
вручную необходимо при работе с унаследованной базой данных и/или есте-
ственными первичными ключами. Мы поговорим об этом подробнее в специаль-
ном разделе 9.2.1.
Обычно желательно, чтобы система сама формировала значение первично-
го ключа при сохранении экземпляра сущности, поэтому вслед за аннотацией
@Id добавляют аннотацию @GeneratedValue. JPA стандартизирует несколько стра-
тегий формирования значений, используя перечисление javax.persistence.
GenerationType, элемент которого вы указываете в @GeneratedValue(strategy = ):
 GenerationType.AUTO – Hibernate выбирает подходящую стратегию, исходя
из диалекта SQL, используемого настроенной базой данных. Это эквива-
лентно @GeneratedValue() без всяких настроек;
 GenerationType.SEQUENCE – Hibernate ищет (и создает, если вы используете
определенные инструменты) последовательность HIBERNATE_SEQUENCE в базе
данных. Эта последовательность будет вызываться отдельно перед каждой
операцией INSERT для получения последовательных числовых значений;
 GenerationType.IDENTITY – Hibernate ищет (и создает в DDL-определении
таблицы) специальный столбец первичного ключа с автоматическим при-
ращением, который сам генерирует числовое значение во время выполне-
ния INSERT в базе данных;
 GenerationType.TABLE – Hibernate будет использовать дополнительную таблицу
в схеме базы данных, хранящую следующее числовое значение пер-
вичного ключа: по одной строке на каждый класс сущности. Соответствен-
но, эта таблица будет читаться и обновляться перед выполнением INSERT.
По умолчанию таблица называется HIBERNATE_SEQUENCES и содержит столбцы
SEQUENCE_NAME и SEQUENCE_NEXT_HI_VALUE. (Внутренняя реализация использу-
ет более сложный, но эффективный алгоритм генерации идентификаторов
hi/lo; подробнее об этом позже.)
Несмотря на то что AUTO кажется удобным вариантом, обычно требуется боль-
ший контроль, поэтому имеет смысл не полагаться на него, а настроить стратегию
формирования значений первичного ключа явно. Кроме того, большинство при-
ложений работает с последовательностями в базе данных, но вам может понадо-
биться поменять имя или другие настройки последовательности. Поэтому вместо
выбора одной из стратегий JPA мы советуем использовать отображение иденти-
фикатора с помощью @GeneratedValue(generator = "ID_GENERATOR"), как показано
в предыдущем примере.
Это именованный генератор идентификаторов; теперь можно настраивать кон-
фигурацию ID_GENERATOR независимо от классов сущностей.
98  Отображение хранимых классов
В JPA существуют две встроенные аннотации для настройки именованных ге-
нераторов: @javax.persistence.SequenceGenerator и @javax.persistence.TableGenerator.
С их помощью можно создавать именованные генераторы с произвольными
именами последовательностей и таблиц. Как обычно, JPA-аннотации можно распо-
лагать только перед классом (возможно, пустым), но не в файле package-info.java.
Особенность Hibernate
По этой причине, а также из-за того, что аннотации JPA не дают полного доступа
ко всем особенностям Hibernate, мы предпочитаем альтернативу: оригинальную
аннотацию @org.hibernate.annotations.GenericGenerator. Она поддерживает все
стратегии генерации идентификаторов Hibernate и их настройку. В отличие от
весьма ограниченных аннотаций JPA, аннотации Hibernate можно использовать
в файле package-info.java, как правило, в том же пакете, что и классы модели пред-
метной области. В листинге 4.2 показана рекомендованная конфигурация.
Листинг 4.2  Генератор идентификаторов Hibernate
в виде метаданных уровня пакета
Файл: /model/src/main/java/org/jpwh/model/package-info.java
@org.hibernate.annotations.GenericGenerator(
name = "ID_GENERATOR",
strategy = "enhanced-sequence",  Стратегия применения расширенной последовательности
parameters = {
@org.hibernate.annotations.Parameter(
name = "sequence_name",  Имя последовательности
value = "JPWH_SEQUENCE"
),
@org.hibernate.annotations.Parameter(
name = "initial_value",  Начальное значение
value = "1000"
)
})
Конфигурация генератора в Hibernate имеет следующие преимущества:
 стратегия enhanced-sequence () производит последовательные числовые
значения. Если диалект SQL поддерживает последовательности, Hibernate
будет использовать настоящую последовательность в базе данных. Если
СУБД не поддерживает последовательности, Hibernate создаст и будет
использовать дополнительную «таблицу последовательностей», имити-
рующую поведение последовательности. Это обеспечивает настоящую
переносимость: генератор всегда будет вызываться перед выполнением
SQL-инструкции INSERT, в отличие, например, от столбца идентификатора
с автоматическим приращением, значение для которого формируется во
время выполнения INSERT и затем возвращается приложению;
 при помощи параметра sequence_name () можно выбрать имя последова-
тельности. Hibernate будет использовать либо существующую последова-
Отображение сущностей с идентичностью  99
тельность, либо создаст ее при автоматическом формировании SQL-схемы.
Если СУБД не поддерживает последовательности, это имя станет именем
специальной «таблицы последовательностей»;
 при помощи параметра initial_value () можно указать начальное значе-
ние, что дает возможность использования тестовых данных. Например, при
выполнении интеграционных тестов Hibernate будет делать любую вставку
данных со значениями идентификатора больше 1000. Любые тестовые дан-
ные, которые нужно загрузить до начала теста, могут использовать числа от
1 до 999, и в тестах можно обращаться к известным значениям идентифика-
торов: «Загрузить товар с идентификатором 123 и выполнить тестирование
с его участием». Эта настройка применяется в момент, когда Hibernate соз-
дает схему SQL и последовательность.
Одна и та же последовательность в базе данных может использоваться всеми клас-
сами предметной модели. Если указать @GeneratedValue(generator = "ID_GENERATOR")
во всех классах сущностей, это не создаст проблем. До тех пор, пока значения пер-
вичного ключа уникальны в пределах одной таблицы, не имеет значения, следуют
они друг за другом подряд или нет. Если вас беспокоит конкурентный доступ, по-
скольку последовательность вызывается перед каждым выполнением INSERT, мы об-
судим другой вариант этой конфигурации генератора позже, в разделе 20.1.
Наконец, типом свойства-идентификатора класса сущности выбран java.lang.
Long, который прекрасно отображается в числовой генератор последовательности
в базе данных. Можно также использовать примитивный тип long. Главным отли-
чием является возвращаемое значение метода someItem#getId(), еще не сохранен-
ного в базу данных объекта: null или 0. Проверка на null, чтобы выяснить, явля-
ется объект новым или нет, возможно, будет более понятна читателю вашего кода.
Не нужно использовать такие целочисленные типы, как short и int, для иденти-
фикаторов. Несмотря на то что их хватит на какое-то время (возможно, годы), по
мере роста базы данных вы можете оказаться ограничены их диапазоном. Если
генерировать новый идентификатор каждую миллисекунду, не делая пропусков,
типа Integer хватит на два месяца, тогда как тип Long продержится 300 млн лет.
Хотя стратегия enhanced-sequence, показанная в листинге 4.2, является реко-
мендованной для большинства приложений, она не единственная, встроенная
в Hibernate.
Особенность Hibernate
4.2.5. Стратегии генерации идентификаторов
Далее следует список всех стратегий генерации идентификаторов Hibernate, их
параметров и наших рекомендаций по их использованию. Если сейчас вам не хо-
чется читать весь список, выберите вариант GenerationType.AUTO и проверьте, что
выберет Hibernate для вашего диалекта SQL по умолчанию. Вероятнее всего, это
будет sequence или identity – хороший, но, возможно, не самый эффективный или
100  Отображение хранимых классов
переносимый вариант. Если требуются высокая переносимость и доступность
значений идентификаторов перед выполнением INSERT, следует использовать
enhanced-sequence, как показано в предыдущем разделе. Это переносимая, гибкая
и современная стратегия, предоставляющая также различные оптимизации для
больших наборов данных.
Мы также покажем связь каждой стандартной стратегии JPA с ее эквивалентом
в Hibernate. В ходе естественного развития Hibernate появились два типа отобра-
жений между стандартными и собственными стратегиями Hibernate; мы называ-
ем их в списке ниже Старые и Новые соответственно. Это отображение можно
поменять с помощью настройки hibernate.id.new_generator_mappings в файле
persistence.xml. Значение по умолчанию – true, что соответствует Новому отобра-
жению. Программное обеспечение стареет не как вино.
Формирование идентификаторов до или после выполнения INSERT:
в чем разница?
Служба ORM старается оптимизировать SQL-инструкции INSERT: например, объ-
единяя несколько запросов на уровне JDBC. То есть выполнение SQL-инструкций
происходит позже в течение транзакции, а не в момент вызова entityManager.
persist(someItem). Этот вызов лишь добавляет операцию вставки в очередь для по-
следующего выполнения и, если это возможно, присваивает значение идентифика-
тора. Но если реализация не сможет сгенерировать идентификатор до выполнения
инструкции INSERT, немедленный вызов someItem.getId() вернет null. В общем случае
мы предпочитаем стратегии генерации, производящие значения идентификаторов
независимо, перед выполнением INSERT. Общепринятым является использование
разделяемой и доступной в многопоточной среде последовательности в базе дан-
ных. Столбцы с автоматическим приращением, значения столбцов по умолчанию,
а также ключи, создаваемые триггерами, доступны лишь после INSERT.
 native – автоматически выбирает другую стратегию, такую как sequence или
identity, в зависимости от настроенного диалекта SQL. Загляните в Javadoc
(или даже в исходники) диалекта SQL, настроенного в persistence.xml. Ана-
лог GenerationType.AUTO в JPA со старым отображением.
 sequence – использует последовательность с именем HIBERNATE_SEQUENCE
в базе данных. Последовательность вызывается перед выполнением каждой
инструкции INSERT для вставки новой записи. Вы можете поменять имя по-
следовательности и указать дополнительные настройки DDL; см. Javadoc
для класса org.hibernate.id.SequenceGenerator.
 sequence-identity – генерирует значения ключа, вызывая последователь-
ность в базе данных во время вставки, например: insert into ITEM(ID) values
(HIBERNATE_SEQUENCE.nextval). Значение ключа извлекается после вставки,
по аналогии со стратегией identity. Поддерживает те же параметры на-
стройки, что и стратегия sequence; см. Javadoc для класса org.hibernate.
id.SequenceIdentityGenerator и его родителя.
Отображение сущностей с идентичностью  101
 enhanced-sequence – использует последовательность в базе данных, если
поддерживается; в противном случае использует дополнительную таблицу
с единственным столбцом и записью, имитирующую последовательность.
По умолчанию таблица получает имя HIBERNATE_SEQUENCE. «Последователь-
ность» всегда вызывается до выполнения INSERT, обеспечивая тем самым
одинаковое поведение независимо от реальной поддержки последователь-
ностей в СУБД. Поддерживает использование оптимизатора org.hibernate.
id.enhanced.Optimizer, предотвращающего обращения к базе данных при
каждой вставке: по умолчанию оптимизация отключена, и новое значение
извлекается перед каждым выполнением INSERT. Дополнительные примеры
приводятся в главе 20. Полный перечень параметров можно найти в Javadoc
для класса org.hibernate.id.enhanced.SequenceStyleGenerator. Аналог GenerationType.
SEQUENCE и GenerationType.AUTO в JPA с новым отображением –
вероятно, лучший выбор среди имеющихся стратегий.
 seqhilo – использует оригинальную последовательность Hibernate с названи-
ем HIBERNATE_SEQUENCE, оптимизируя вызовы перед выполнением INSERT путем
объединения старших (hi) и младших (lo) значений. Если полученное из по-
следовательности значение hi равно 1, то следующие 9 вставок будут сделаны
со значениями ключей 11, 12, 13, ..., 19. Затем последовательность вызывается
снова для получения следующего значения hi (2 или больше), и процесс по-
вторяется со значениями 21, 22, 23 и т. д. Максимальное значение lo (9 по
умолчанию) можно настроить с помощью параметра max_lo. К сожалению,
из-за особенностей реализации Hibernate эту стратегию невозможно настро-
ить в @GenericGenerator. Единственная возможность ее использования – с по-
мощью GenerationType.SEQUENCE в JPA и старого отображения. Настроить ее
можно при помощи стандартной JPA-аннотации @SequenceGenerator перед
(возможно, пустым) классом. Более подробную информацию о классе org.
hibernate.id.SequenceHiLoGenerator и его родителях ищите в Javadoc. Прежде
чем применять эту стратегию, подумайте о возможности применения более
предпочтительной enhanced-sequence с оптимизатором.
 hilo – использует дополнительную таблицу с именем HIBERNATE_UNIQUE_KEY
и такой же алгоритм, как в стратегии seqhilo. В таблице имеются один
столбец и одна запись, хранящая следующее значение последовательности.
По умолчанию максимальное значение lo равно 32 767, поэтому, вполне
возможно, вам захочется настроить его с помощью параметра max_lo. Бо-
лее подробную информацию о классе org.hibernate.id.TableHiLoGenerator
ищите в Javadoc. Мы не рекомендуем эту устаревшую стратегию; исполь-
зуйте вместо нее enhanced-sequence с оптимизатором.
 enhanced-table – использует дополнительную таблицу HIBERNATE_SEQUENCES,
представляющую последовательность, с одной записью по умолчанию, в ко-
торой хранится следующее значение. Это значение возвращается и обнов-
ляется, когда нужно сформировать значение идентификатора. В этой табли-
це можно организовать хранение нескольких записей – по одной на каждый
генератор; подробности ищите в описании org.hibernate.id.enhanced.Tabl102
 Отображение хранимых классов
Generator в Javadoc. Аналог GenerationType.TABLE в JPA с новым отображе-
нием. Заменяет устаревший класс org.hibernate.id.MultipleHiLoPerTableGe
nerator, который является старым отображением для GenerationType.TABLE.
 identity – поддерживает столбцы идентификаторов (IDENTITY) и с автома-
тическим приращением в DB2, MySQL, MS SQL Server и Sybase. Значе-
ние идентификатора для столбца первичного ключа определяется во время
вставки записи. Параметры настройки отсутствуют. К сожалению, из-за
особенностей реализации Hibernate эту стратегию невозможно настроить
в @GenericGenerator. Единственная возможность ее использования – с по-
мощью GenerationType.IDENTITY в JPA старого или нового отображения, что
делает ее стратегией по умолчанию для GenerationType.IDENTITY.
 increment – при запуске Hibernate читает максимальные (числовые) зна-
чения первичного ключа из каждой таблицы сущности и увеличивает это
значение на единицу каждый раз, когда происходит вставка новой записи.
Данная стратегия особенно эффективна в приложениях Hibernate, не являющихся
частью кластера и имеющих эксклюзивный доступ к базе дан-
ных; не используйте эту стратегию в других ситуациях.
 select – Hibernate не будет генерировать значение ключа или добавлять
столбец первичного ключа в выражение INSERT. Ожидается, что СУБД сама
присвоит значение (указанное в схеме или полученное с помощью тригге-
ра) столбцу во время вставки. После вставки Hibernate извлечет столбец
первичного ключа с помощью запроса SELECT. Имеет обязательный пара-
метр key, определяющий имя свойства-идентификатора в базе данных (на-
пример, id) для выражения SELECT. Данная стратегия не очень эффективна
и должна использоваться только со старыми драйверами JDBC, которые не
могут возвращать сгенерированных ключей непосредственно.
 uuid32 – создает уникальный 128-битный идентификатор UUID на уровне
приложения. Такая стратегия полезна, если требуется обеспечить глобаль-
ную уникальность идентификаторов в нескольких базах данных (к примеру,
если каждую ночь вы объединяете данные из нескольких рабочих баз дан-
ных в архив, используя пакетную обработку). В классе сущности иденти-
фикатор UUID может быть представлен как свойство типа java.lang.String,
byte[16] или java.util.UUID. Заменяет устаревшие стратегии uuid и uuid.hex.
Настраивается
с помощью org.hibernate.id.UUIDGenerationStrategy; подроб-
ности ищите в описании класса org.hibernate.id.UUIDGenerator в Javadoc.
 guid – использует глобально уникальный идентификатор, созданный базой
данных при помощи SQL-функции, доступной в Oracle, Ingres, MS SQL
Server и MySQL. Hibernate вызывает функцию базы данных перед встав-
кой. Значение отображается в поле идентификатора типа java.lang.String.
Если потребуется более полный контроль за созданием идентификато-
ра, настройте стратегию в аннотации @GenericGenerator, используя полное
квалифицированное имя класса, реализующего интерфейс org.hibernate.
id.IdentityGenerator.
Способы отображений сущностей  103
Подводя итог, мы можем дать следующие рекомендации по выбору стратегии
формирования идентификаторов:
 в общем случае мы предпочитаем стратегии, производящие значения иден-
тификаторов независимо, перед выполнением INSERT;
 используйте enhanced-sequence, которая работает со встроенной последова-
тельностью в базе данных, если та поддерживается, или с дополнительной
таблицей с единственным столбцом и единственной записью, имитирую-
щей последовательность.
Мы будем считать, что вы добавили свойство-идентификатор во все классы
сущностей вашей предметной модели и что, после того как завершите создание
основного отображения каждой сущности и ее свойства-идентификатора, вы про-
должите отображать свойства сущностей, имеющие тип-значение. Мы обсудим
отображения типов-значений в следующей главе. Читайте дальше, чтобы узнать
о некоторых специальных возможностях, которые могут упростить и улучшить
отображения ваших классов.
4.3. Способы отображений сущностей
Вы уже отобразили хранимый класс с помощью аннотации @Entity, используя зна-
чения по умолчанию для всех остальных настроек, таких как имя таблицы SQL,
в которую отображается класс. В следующем разделе мы исследуем некоторые на-
стройки, задаваемые на уровне класса, и как ими управлять:
 имена по умолчанию и стратегии именования;
 динамическое формирование SQL-запросов;
 изменяемость сущностей.
Далее обсуждаются настройки; вы можете пропустить этот раздел и вернуться
позже, когда придется решать конкретную проблему.
4.3.1. Управление именами
Поговорим сначала об именовании классов сущностей и таблиц. Если хранимый
класс отметить единственной аннотацией @Entity, по умолчанию для таблицы бу-
дет выбрано имя, совпадающее с именем класса. Обратите внимание, что имена
артефактов SQL мы записываем ПРОПИСНЫМИ буквами, чтобы их было легче разли-
чать, – SQL на самом деле не чувствителен к регистру. Таким образом, Java-класс
Item отображается в таблицу ITEM. Вы можете переопределить имя таблицы, ис-
пользуя JPA-аннотацию @Table, как показано далее.
Листинг 4.3  Аннотация @Table переопределяет имя таблицы
Файл: /model/src/main/java/org/jpwh/model/simple/User.java
@Entity
@Table(name = "USERS")
public class User implements Serializable {
// ...
}
104  Отображение хранимых классов
По умолчанию сущность User была бы отображена в таблицу USER, однако во
многих СУБД SQL это имя зарезервировано. Поскольку нельзя создать табли-
цу с таким именем, можно отобразить класс в таблицу USERS. Аннотация @javax.
persistence.Table имеет также параметры catalog и schema, если конфигурация ва-
шей базы данных требует их наличия в качестве префиксов имени.
Заключение в кавычки позволяет при необходимости использовать зарезерви-
рованные имена SQL и даже использовать имена, чувствительные к регистру.
Заключение идентификаторов SQL в кавычки
Время от времени, особенно в старых базах данных, можно встретить имена со
странными символами или пробелами, или возникает потребность учитывать ре-
гистр символов. Или, как в предыдущем примере, автоматическое отображение
класса или поля может приводить к использованию зарезервированного имени
таблицы или столбца.
Hibernate 5 узнает зарезервированные слова вашей СУБД по настроенному диалекту
базы данных и может автоматически ставить кавычки вокруг таких строк во
время формирования SQL, активировать автоматическое заключение в кавычки
с помощью параметра hibernate.auto_quote_keyword=true в конфигурации едини-
цы хранения. Если вы используете старую версию Hibernate или обнаружили, что
информации о диалекте недостаточно, при возникновении конфликтов с клю-
чевыми словами вам придется вручную добавить кавычки вокруг имен в ваших
отображениях.
Если заключить имя таблицы или столбца в отображении в обратные кавычки,
Hibernate всегда будет заключать этот идентификатор в кавычки во время форми-
рования SQL. Этот прием продолжает действовать в последних версиях Hibernate,
но спецификация JPA 2.0 стандартизовала эту функциональность как отделяемый
идентификатор (delimited identifier) с двойными кавычками.
Вот вариант предыдущего примера с обратными кавычками, доступный только
в Hibernate:
@Table(name = "`USER`")
Для совместимости с JPA необходимо также экранировать кавычки внутри
строки:
@Table(name = "\"USER\"")
Любой из этих вариантов будет работать с Hibernate. Фреймворк знает, какие
кавычки применять для вашего диалекта, и будет генерировать соответствующий
SQL: [USER] для MS SQL Server, 'USER' для MySQL, "USER" для H2 и т. д.
Если потребуется заключить в кавычки каждый SQL-идентификатор – создай-
те файл orm.xml и добавьте элемент <delimited-identifiers/> в раздел <persistenceunit-
defaults>, как показано в листинге 3.8. В этом случае Hibernate будет повсе-
местно использовать идентификаторы, заключенные в кавычки.
Обязательно подумайте о возможности переименования таблиц и столбцов,
имена которых совпадают с зарезервированными словами. Трудно писать про-
Способы отображений сущностей  105
извольные SQL-запросы в консоли SQL, когда приходится вручную расставлять
и экранировать кавычки.
Далее вы увидите, как Hibernate может помочь в случае, когда имеются строгие
соглашения об именовании таблиц и столбцов.
Особенность Hibernate
Реализация соглашений об именовании
Hibernate предоставляет возможность автоматического соблюдения стандартов
именования. Предположим, что все таблицы приложения CaveatEmptor должны
следовать шаблону CE_<table name>. Для этого можно вручную добавить аннота-
цию @Table перед каждым классом сущности. Такой подход требует времени, и при
его использовании легко что-нибудь пропустить. Вместо этого можно реализовать
Hibernate-интерфейс PhysicalNamingStrategy или переопределить существующую
реализацию, как показано в листинге 4.4.
Листинг 4.4  Реализация PhysicalNamingStrategy, переопределяющая соглашения
об именовании по умолчанию
Файл: /shared/src/main/java/org/jpwh/shared/CENamingStrategy.java
public class CENamingStrategy extends
org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl {
@Override
public Identifier toPhysicalTableName(Identifier name,
JdbcEnvironment context) {
return new Identifier("CE_" + name.getText(), name.isQuoted());
}
}
Переопределенный метод toPhysicalTableName() добавляет приставку CE_ к каж-
дому сгенерированному имени таблицы в вашей схеме. Загляните в Javadoc с опи-
санием интерфейса PhysicalNamingStrategy – он определяет также методы для про-
извольного именования столбцов, последовательностей и прочих артефактов.
После реализации стратегии именования ее следует активировать в persistence.
xml:
<persistence-unit>name="CaveatEmptorPU">
...
<properties>
<property name="hibernate.physical_naming_strategy"
value="org.jpwh.shared.CENamingStrategy"/>
</properties>
</persistence-unit>
Второй способ формирования нестандартных имен заключается в использова-
нии интерфейса ImplicitNamingStrategy. В отличие от физической стратегии име-
106  Отображение хранимых классов
нования PhysicalNamingStrategy, которая включается в работу на самом нижнем
уровне, когда формируются окончательные имена артефактов, неявная стратегия
именования ImplicitNamingStrategy вызывается раньше. Если отображается класс
сущности, не имеющий аннотации @Table с явным именем таблицы, выбор имени
производится неявной стратегией. На результат оказывают влияние такие факто-
ры, как имя сущности и имя класса. Hibernate включает несколько готовых страте-
гий для формирования устаревших или совместимых с JPA имен. По умолчанию
используется стратегия ImplicitNamingStrategyJpaCompliantImpl.
Давайте взглянем на другую схожую проблему – именование сущностей для
запросов.
Именование сущностей для запросов
По умолчанию имена всех сущностей автоматически импортируются в про-
странство имен движка запросов. Иными словами, в запросах JPA можно исполь-
зовать короткие имена классов без префикса с именем пакета, что очень удобно:
List result = em.createQuery("select i from Item i")
.getResultList();
Однако этот прием работает, только когда в единице хранения имеется един-
ственный класс Item. Если добавить еще один класс Item в другой пакет, один из
них придется переименовать, чтобы продолжать использовать короткие имена
в JPA-запросах:
package my.other.model;
@javax.persistence.Entity(name = "AuctionItem")
public class Item {
// ...
}
Короткая форма запроса для класса Item из пакета my.other.model теперь будет
выглядеть так: select i from AuctionItem i. Таким способом мы разрешили кон-
фликт имен с классом Item из другого пакета. Конечно, всегда можно использовать
полное квалифицированное имя с префиксом из имени пакета.
Мы завершаем наш обзор вариантов именования в Hibernate. Далее мы обсу-
дим, как Hibernate формирует код SQL, содержащий эти имена.
Особенность Hibernate
4.3.2. Динамическое формирование SQL
По умолчанию Hibernate формирует SQL-выражения для каждого хранимого
класса в момент создания единицы хранения на запуске. Эти выражения пред-
ставляют простые операции (CRUD) создания (create), чтения (read), изменения
(update), удаления (delete): для чтения одной записи, удаления записи и т. д. Вы-
годнее постоянно хранить эти запросы в памяти, а не генерировать их каждый раз,
Способы отображений сущностей  107
когда во время работы приложения потребуется выполнить тот или иной запрос.
Кроме того, кэширование подготовленных операторов на уровне JDBC тем более
эффективно, чем меньше имеется операторов.
Как может Hibernate создавать выражения UPDATE при запуске? В конце концов,
столбцы для изменения в этот момент неизвестны. Ответ прост: сгенерированное
SQL-выражение обновляет все столбцы, и если значение какого-либо столбца не
изменилось, выражение присваивает ему старое значение.
В некоторых случаях, например при работе со старыми таблицами с сотнями
столбцов, когда SQL-выражения могут быть большими даже для простейших опе-
раций (например, когда требуется обновить всего один столбец), вы должны от-
ключить формирование SQL при запуске и переключиться на динамическое фор-
мирование SQL-выражений во время работы приложения. Чрезмерно большое
количество сущностей также может повлиять на время запуска, потому что сна-
чала Hibernate должен сгенерировать все SQL-выражения для операций CRUD.
Потребление памяти кэшем запросов также будет велико, если туда поместить де-
сятки выражений для тысяч сущностей. Это может стать проблемой в виртуальном
окружении с ограничениями памяти или на устройствах малой мощности.
Чтобы деактивировать создание SQL-выражений INSERT и UPDATE при запуске,
потребуются оригинальные аннотации Hibernate:
@Entity
@org.hibernate.annotations.DynamicInsert
@org.hibernate.annotations.DynamicUpdate
public class Item {
// ...
}
Активируя динамическое создание инструкций вставки и изменения, вы со-
общаете Hibernate, что строки SQL должны формироваться по требованию, а не
заранее. В этом случае инструкция UPDATE будет содержать только столбцы с новы-
ми значениями, а INSERT – только столбцы, которые не могут принимать значение
null.
Мы еще вернемся к теме формирования и модификации SQL в главе 17. Иногда
вы можете вообще избежать формирования выражений UPDATE, если ваши сущно-
сти неизменяемы.
Особенность Hibernate
4.3.3. Неизменяемые сущности
Экземпляры конкретного класса могут быть неизменяемыми. Например, в при-
ложении CaveatEmptor предложение цены за товар (Bid) не изменяется. Поэтому
Hibernate никогда не потребуется выполнять операцию UPDATE над таблицей BID.
Hibernate также может выполнить несколько оптимизаций – например, не про-
верять состояния объекта, когда отображается неизменяемый класс, как показано
108  Отображение хранимых классов
в следующем примере. Здесь класс Bid – неизменяемый, и его экземпляры никогда
не обновляются:
@Entity
@org.hibernate.annotations.Immutable
public class Bid {
// ...
}
POJO считается неизменяемым, если не имеет общедоступных методов записи
ни для каких свойств – все значения устанавливаются в конструкторе. Hibernate
должен обращаться к полям класса напрямую во время загрузки и сохранения эк-
земпляров. Как уже обсуждалось выше в этой главе: если поле класса отмечено ан-
нотацией @Id, Hibernate будет обращаться к полям класса напрямую, а вы можете
проектировать свои методы доступа, как считаете нужным. Но помните, что не все
фреймворки могут работать с POJO в отсутствие методов записи; JSF, например,
не обращается напрямую к полям класса для формирования состояния объекта.
Когда нет возможности создать представление в схеме базы данных, неизменяемый
класс сущности можно отобразить в SQL-запрос SELECT.
Особенность Hibernate
4.3.4. Отображение сущности в подзапрос
Бывает, что администратор базы данных не позволяет менять схему базы данных;
невозможно добавить даже одно представление. Давайте представим, что вы хо-
тите создать представление, показывающее идентификатор аукционного товара
(Item) и количество всех предложений цены за него.
Используя аннотации Hibernate, можно создать представление уровня при-
ложения – класс сущности с доступом только на чтение, отображаемый в SQL-
запрос SELECT:
Файл: /model/src/main/java/org/jpwh/model/advanced/ItemBidSummary.java
@Entity
@org.hibernate.annotations.Immutable
@org.hibernate.annotations.Subselect(
value = "select i.ID as ITEMID, i.ITEM_NAME as NAME, " +
"count(b.ID) as NUMBEROFBIDS " +
"from ITEM i left outer join BID b on i.ID = b.ITEM_ID " +
"group by i.ID, i.ITEM_NAME"
)
@org.hibernate.annotations.Synchronize({"Item", "Bid"})
public class ItemBidSummary {
@Id
protected Long itemId;
TODO: имена таблиц
чувствительны к регистру
(баг Hibernate HHH-8430)
Способы отображений сущностей  109
protected String name;
protected long numberOfBids;
public ItemBidSummary() {
}
// Методы чтения...
// ...
}
При загрузке экземпляра ItemBidSummary Hibernate выполнит SQL-запрос SELECT
как подзапрос:
Файл: /examples/src/test/java/org/jpwh/test/advanced/MappedSubselect.java
ItemBidSummary itemBidSummary = em.find(ItemBidSummary.class, ITEM_ID);
// select * from (
// select i.ID as ITEMID, i.ITEM_NAME as NAME, ...
// ) where ITEMID = ?
Все имена таблиц, упомянутые в запросе SELECT, должны быть перечисле-
ны в аннотации @org.hibernate.annotations.Synchronize. (На момент написания
книги в Hibernate имелась ошибка с номером HHH-84301, которая делала имена
синхронизируемых таблиц чувствительными к регистру.) Тогда Hibernate будет
знать, что перед выполнением запроса к ItemBidSummary необходимо синхронизи-
ровать изменения в Item и Bid с базой данных.
Файл: /examples/src/test/java/org/jpwh/test/advanced/MappedSubselect.java
Item item = em.find(Item.class, ITEM_ID);
item.setName("New name");
// ItemBidSummary itemBidSummary = em.find(ItemBidSummary.class, ITEM_ID);
Query query = em.createQuery(
"select ibs from ItemBidSummary ibs where ibs.itemId = :id"
);
ItemBidSummary itemBidSummary =
(ItemBidSummary)query.setParameter("id", ITEM_ID).getSingleResult();
Обратите внимание, что Hibernate не выполняет автоматической синхрониза-
ции перед операцией find() – только перед выполнением запроса (Query), если это
необходимо. Hibernate определит, что модифицированный объект Item повлияет
на результат запроса, потому что таблица ITEM синхронизирована с ItemBidSummary.
Соответственно, необходимо выполнить синхронизацию изменений и инструк-
цию UPDATE, чтобы предотвратить возвращение запросом устаревших данных.
1 См. https://hibernate.atlassian.net/browse/HHH-8430.
При загрузке по идентификатору
синхронизация не происходит
Автоматическая синхронизация происходит перед выполнением
запроса, только когда задействованы синхронизируемые таблицы
110  Отображение хранимых классов
4.4. Резюме
 Сущности – это укрупненные классы системы. Их экземпляры обладают не-
зависимым жизненным циклом и собственной идентичностью, и на них может
ссылаться множество других объектов.
 Типы-значения, с другой стороны, зависят от конкретного класса сущности.
Экземпляр типа-значения связан с экземпляром сущности-владельца, и толь-
ко один объект может на него ссылаться – у него отсутствует собственная
идентичность.
 Мы рассмотрели понятия идентичности и равенства в Java, идентичности
в базе данных, а также узнали, что такое хороший первичный ключ. Вы узнали,
какие генераторы значений первичного ключа поддерживаются фреймворком
Hibernate «из коробки» и как использовать и расширить систему идентифи-
кации.
 Мы обсудили некоторые полезные способы отображений классов, такие как
стратегии именования и динамическое формирование SQL.
Глава 5
Отображение
типов-значений
В этой главе:
 отображение полей основных типов;
 отображение встраиваемых компонентов;
 управление отображением между типами Java и SQL.
Посвятив практически всю предыдущую главу сущностям и соответствующим на-
стройкам отображений классов и идентификаторов, сейчас мы сосредоточимся на
типах-значениях разных видов. Мы поделим типы-значения на две категории: ос-
новные классы типов-значений из JDK, такие как String, Date, примитивные типы
и их обертки; и типы-значения, определяемые разработчиком, такие как Address
и MonetaryAmount в приложении CaveatEmptor.
В этой главе мы сначала отобразим хранимые поля с типами из JDK и позна-
комимся с основными аннотациями. Вы узнаете, как управлять различными
аспектами свойств: переопределять значения по умолчанию, настраивать доступ
и работать со сгенерированными значениями. Также вы увидите применение SQL
для производных свойств и преобразованных значений столбцов. Знакомство
с основными типами мы завершим обзором свойств для представления време-
ни и отображением перечислений. Затем мы обсудим пользовательские классы
типов-значений и отобразим их как встраиваемые компоненты. Вы узнаете, как
классы соотносятся со схемой базы данных, и сделаете ваши классы встраивае-
мыми, позволяя в то же время переопределять встроенные атрибуты. Знакомство
со встраиваемыми
компонентами мы завершим отображением вложенных ком-
понентов. Наконец, мы обсудим более низкоуровневую настройку загрузки и со-
хранения значений полей с применением гибких конвертеров JPA – стандартного
механизма расширения реализаций JPA.
Главные нововведения в JPA 2
• Возможность переключения между прямым доступом к полям и через методы
чтения/записи свойств при помощи аннотации @Access.
112  Отображение типов-значений
• Создание нескольких вложенных уровней встраиваемых компонентов и возмож-
ность применения аннотации @AttributeOverride ко вложенным встроенным по-
лям с применением точечной нотации.
• Добавлена поддержка конвертеров для атрибутов основных типов, позволяю-
щая управлять загрузкой и сохранением значений, а также их преобразованием.
5.1. Отображение полей основных типов
При отображении хранимого класса, будь то сущность или встраиваемый тип
(подробнее об этом далее в разделе 5.2), каждое его свойство по умолчанию счита-
ется хранимым. К свойствам хранимого класса по умолчанию применяются сле-
дующие правила JPA:
 если свойство имеет простой тип, или это обертка простого типа, или это
тип String, BigInteger, BigDecimal, java.util.Date, java.util.Calendar, java.
sql.Date, java.sql.Time, java.sql.Timestamp, byte[], Byte[], char[] или Character[],
оно автоматически становится хранимым. Hibernate загружает и со-
храняет значение свойства в столбце соответствующего типа SQL и с име-
нем свойства;