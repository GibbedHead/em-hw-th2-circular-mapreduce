11.1.5. Декларативное определение границ транзакции
В приложении Java EE можно объявить, когда работа должна выполняться внутри
транзакции. Решение этой задачи берет на себя среда выполнения. Границы
транзакции обычно задаются с помощью аннотаций управляемых компонентов
(компонентов EJB, CDI и т. д.).
Для декларативного объявления границ транзакций компонентов EJB можно
использовать старую аннотацию @javax.ejb.TransactionAttribute. Примеры вы
найдете в разделе 18.2.1.
Для любого управляемого компонента Java EE можно применить более новую
аннотацию общего назначения @javax.transaction.Transactional. Примеры вы
найдете в разделе 19.3.1.
Управление параллельным доступом  307
Все прочие примеры из этой главы работают в любом окружении Java SE и не
требуют специальных контейнеров среды выполнения. Поэтому, начиная с дан-
ного момента, мы будем демонстрировать только код, определяющий границы
транзакций программно, пока мы не начнем рассматривать примеры конкретных
приложений Java EE.
Далее мы сосредоточимся на самом сложном из аспектов ACID – изолирован-
ности параллельно выполняющихся единиц работы.
11.2. Управление параллельным доступом
Базы данных (как и другие транзакционные системы) пытаются обеспечить изо-
лированность транзакций: с точки зрения каждой конкретной транзакции ника-
ких других транзакций как бы не существует. Традиционно СУБД обеспечивают
изолированность с помощью блокировок. Транзакция может установить бло-
кировку на конкретный элемент в базе данных, временно препятствуя другим
транзакциям в получении доступа к этому элементу на чтение и/или на запись.
Некоторые современные механизмы баз данных реализуют изолированность
транзакций, используя управление параллельным доступом с помощью много-
версионности (Multiversion Concurrency Control, MVCC), который считается бо-
лее масштабируемым решением. Мы будем обсуждать изолированность с точки
зрения модели блокировок, но большая часть наших наблюдений также приме-
нима к MVCC.
Способ реализации управления многопоточностью в базе данных имеет огром-
ное значение для приложения, использующего Java Persistence. Приложения
пользуются гарантиями изолированности, предоставляемыми СУБД. Hibernate,
к примеру, никогда ничего не блокирует в памяти. Преимущества такого подхо-
да особенно очевидны, если учесть многие годы, в течение которых создатели баз
данных работали над управлением многопоточностью. Кроме того, некоторые осо-
бенности Java Persistence могут обеспечить лучшие гарантии изолированности,
чем в базе данных, независимо от того, применяете вы их явно или они действуют
по умолчанию.
Мы будем знакомиться с управлением многопоточностью постепенно. Снача-
ла исследуем нижний уровень: гарантии изолированности транзакций со стороны
базы данных. Затем вы познакомитесь с пессимистическим и оптимистическим
управлением транзакциями на уровне приложения в Java Persistence, а также
с прочими гарантиями изолированности, которые можете дать Hibernate.
11.2.1. Многопоточность на уровне базы данных
Говоря об изолированности, нужно понимать, что изолированность либо есть,
либо ее нет; в реальном мире не существует промежуточного состояния. В случае
с транзакциями в базе данных за полную изолированность приходится платить
высокую цену. Нельзя остановить мир, чтобы получить эксклюзивный доступ
к данным в многопользовательской системе OLTP. Как следствие существует не-
308  Транзакции и многопоточность
сколько уровней изоляции, которые, естественно, ослабляют полную изоляцию,
но повышают производительность и масштабируемость систем.
Особенности изоляции транзакций
Для начала рассмотрим некоторые явления, которые могут возникать при
ослаблении
полной изолированности транзакций. Стандарт ANSI SQL определяет
несколько уровней изолированности, для каждого из которых данные явления до-
пустимы.
Потерянное изменение (lost update) происходит, когда две транзакции обнов-
ляют один элемент данных, а затем последняя транзакция отменяется, вызывая
потерю обоих изменений. Такое происходит в системах, где управление многопо-
точностью не реализовано, а параллельные транзакции не изолированы. Это по-
казано на рис. 11.1.
Рис. 11.1  Потерянное изменение: две транзакции
обновляют одни и те же данные без изоляции
Чтение неподтвержденных изменений (dirty read) происходит, если транзакция
читает изменения, сделанные другой транзакцией, которая еще не была подтверж-
дена. Такая ситуация опасна, поскольку изменения, сделанные другой транзакци-
ей, могут быть позже отменены, а первая транзакция может записать некоррект-
ные данные; см. рис. 11.2.
Рис. 11.2  Чтение неподтвержденных изменений:
транзакция A читает неподтвержденные данные транзакции B
Управление параллельным доступом  309
Неповторимое чтение (unrepeatable read) возникает, когда транзакция дважды
читает элемент данных, и каждый раз данные оказываются в разном состоянии.
Например, другая транзакция могла изменить элемент данных и оказаться под-
твержденной между двумя чтениями, как показано на рис. 11.3.
Рис. 11.3  Неповторимое чтение: транзакция A
выполняет две операции чтения, возвращающие разные результаты
Особым случаем неповторимого чтения является проблема, когда побежда-
ет последнее изменение. Представьте две параллельные транзакции, которые обе
читают один элемент данных, как показано на рис. 11.4. Одна из них выполняет
запись и подтверждается, а затем другая выполняет запись и тоже подтвержда-
ется. Изменения, сделанные первой транзакцией, будут потеряны. Эта проблема
сильно расстраивает пользователей: изменения пользователя A будут перезаписа-
ны без предупреждения, а пользователь B, возможно, принял решение, исходя из
устаревшей информации.
Рис. 11.4  Последняя транзакция побеждает:
транзакция B затирает изменения, сделанные транзакцией A
Фантомное чтение (phantom read) возникает, когда транзакция выполняет за-
прос дважды, и второй результат включает либо больше данных, чем было видно
первому запросу, либо меньше, поскольку что-то было удалено. Это не обязатель-
но должен быть один запрос. Другая транзакция, которая вставляет или удаляет
данные между выполнениями двух запросов, может вызвать ситуацию, показан-
ную на рис. 11.5.
310  Транзакции и многопоточность
Рис. 11.5  Фантомное чтение:
транзакция A читает измененные данные
во время выполнения второй операции SELECT
Теперь, когда вы узнали обо всех неприятностях, которые могут случиться, мы
можем определить уровни изолированности транзакций и узнать, какие из этих
проблем они решают.
Уровни изолированности ANSI
Основные уровни изолированности транзакций определены в стандарте ANSI
SQL, но они используются не только в базах данных SQL. JTA определяет точно та-
кие же уровни изолированности, и вы будете использовать их для задания требу-
емого уровня изолированности транзакций. Увеличение уровня изолированности
влечет увеличение стоимости и серьезное падение производительности и масшта-
бируемости.
 Чтение неподтвержденных данных (read uncommitted) – система, работающая
на данном уровне изолированности, допускает чтение неподтверж-
денных изменений, но не потерянные изменения. Транзакция не сможет
сохранить изменения, если другая неподтвержденная транзакция уже изме-
нила эту же запись. Однако любая транзакция может читать любые данные.
СУБД может реализовать данный уровень изолированности с помощью
монопольных блокировок на запись.
 Чтение подтвержденных данных (read committed) – система, работающая
на данном уровне изолированности, допускает неповторимость чтения, но
не позволяет читать неподтвержденные изменения. СУБД может работать
на данном уровне, используя разделяемую блокировку на чтение и моно-
польную на запись. Транзакции, читающие данные, не блокируют доступа
остальных транзакций, но неподтвержденная транзакция, выполняющая
изменения, блокирует доступ к записи всех остальных транзакций.
 Повторимое чтение (repeatable read) – система, работающая на данном
уровне изолированности, не допускает неповторимого чтения и чтения не-
подтвержденных изменений. Но фантомные чтения по-прежнему возмож-
ны. Транзакции, читающие данные, блокируют транзакции, выполняющие
изменения, но не блокируют других читающих транзакций, а транзакции,
выполняющие изменения, блокируют все остальные транзакции.
Управление параллельным доступом  311
 Упорядоченность – самый строгий уровень изолированности. Имитирует
последовательное выполнение, как если бы транзакции выполнялись одна
за другой, а не параллельно. СУБД не может обеспечивать упорядоченность
только за счет блокировок на уровне записей. Вместо этого СУБД должна
поддерживать иной механизм, не позволяющий только что вставленной
записи
становиться видимой для транзакции, которая уже выполнила за-
прос, который вернул бы эту запись. Грубое решение заключается в моно-
польной блокировке целой таблицы базы данных после изменения для
предотвращения фантомных чтений.
Способы реализации блокировок существенно различаются для разных СУБД;
каждый разработчик проводит в жизнь свою стратегию. Чтобы узнать больше
о механизме блокировок, их распространении (например, начиная уровнем записи
и заканчивая страницами и целыми таблицами) и о том, какое воздействие ока-
зывает каждый уровень изолированности на производительность и масштабируе-
мость системы, нужно изучать документацию конкретной СУБД.
Конечно, неплохо знать, как определяются эти технические термины, но как это
поможет в выборе уровня изолированности для приложения?
Выбираем уровень изолированности
Разработчики (в том числе и мы) часто не знают, какой уровень изолирован-
ности транзакций следует выбрать для приложения. В приложении с большим
количеством потоков слишком высокий уровень изолированности навредит мас-
штабируемости. Недостаточный уровень изолированности может вызывать по-
явление скрытых, трудновоспроизводимых ошибок, которые не обнаруживаются,
пока система не окажется под большой нагрузкой.
Обратите внимание, что далее мы будем использовать термин оптимистиче-
ская блокировка (с версионированием), значение которого объясняется далее
в этой главе. Вы можете сейчас пропустить этот раздел и вернуться к нему позже,
когда наступит время выбирать уровень изолированности вашего приложения.
В конце концов, выбор уровня изолированности во многом зависит от конкретно-
го сценария. Отнеситесь к последующему рассуждению как к рекомендациям, а не
как к истине, высеченной в камне.
Hibernate старается быть как можно более прозрачным в том, что касается
транзакционной
семантики базы данных. Тем не менее кэширование в контексте
хранения и версионирование влияют на эту семантику. Какой уровень изолиро-
ванности целесообразно выбирать для приложений JPA?
Во-первых, никогда не используйте уровень изолированности, допускающий
чтение неподтвержденных данных. Использовать неподтвержденные изменения
одной транзакции в другой транзакции чрезвычайно опасно. Откат или ошибка
одной транзакции повлияет на другие транзакции, выполняющиеся параллель-
но. Откат первой транзакции может откатить другие транзакции вместе с ней или
даже повлиять на них так, что они оставят базу данных в некорректном состоя-
нии (счет продавцу товара может быть выставлен дважды, что согласуется с пра-
312  Транзакции и многопоточность
вилами целостности в базе данных, но это некорректно). Кроме того, изменения,
сделанные транзакцией, которая затем была отменена, могут быть подтверждены
другой транзакцией, успевшей прочитать их и передать в базу данных!
Во-вторых, большинству приложений не требуется уровень изолированности,
поддерживающий упорядоченность. Как правило, фантомное чтение обычно не
вызывает проблем, и такой уровень изолированности плохо масштабируется. Не-
многие приложения используют уровень изолированности, поддерживающий
упорядоченность; они скорее полагаются на выборочно используемые пессимистические
блокировки, которые в определенных условиях фактически гарантиру-
ют последовательное выполнение операций.
Далее рассмотрим повторимое чтение. Этот уровень изолированности обеспе-
чивает воспроизводимость результатов запроса в течение транзакции в базе дан-
ных. Это значит, что транзакция не прочитает подтвержденных изменений, даже
если выполнит запрос несколько раз. Но фантомные чтения по-прежнему возмож-
ны: могут появляться новые строки, а те, которые существовали, могут исчезнуть,
если другая транзакция параллельно подтвердит такие изменения. Иногда повто-
римое чтение желательно, но обычно требуется не в каждой транзакции.
В спецификации JPA по умолчанию используется уровень изолированности,
обеспечивающий чтение подтвержденных данных. При его использовании при-
дется иметь дело с неповторимым чтением, фантомным чтением и проблемой вы-
игрыша последней подтвержденной транзакции.
Предположим, что для сущностей предметной модели вы применяете версио-
нирование, поддерживаемое фреймворком Hibernate автоматически. Комбинация
(обязательного) кэша контекста хранения и версионирования уже дает значитель-
ные преимущества уровня изолированности, обеспечивающего повторимое чте-
ние. Кэш контекста хранения гарантирует изолированность состояния экземпляров
сущностей, загруженных в одной транзакции, от изменений, сделанных в других
транзакциях. Если в рамках единицы работы загрузить экземпляр сущности дваж-
ды, во второй раз искомая сущность будет взята из кэша контекста хранения, а не из
базы данных. Следовательно, чтение является повторимым, и вы не увидите кон-
фликтующих подтвержденных данных (вы все равно получите фантомные чтения,
но иметь с ними дело, как правило, гораздо проще). Кроме того, при использовании
версионирования побеждает первая подтвержденная транзакция. Следовательно,
для большинства многопользовательских приложений JPA приемлемым является
уровень изолированности, обеспечивающий чтение подтвержденных изменений
для всех транзакций в базе данных при включенном версионировании.
Hibernate сохраняет уровень изолированности соединения с базой данных – он
не меняет его. В большинстве приложений по умолчанию выбирается уровень изо-
ляции, обеспечивающий чтение подтвержденных данных. Существует несколько
способов изменения как уровня изолированности транзакций по умолчанию, так
и настроек текущей транзакции.
Во-первых, вы можете проверить наличие глобального уровня изолированно-
сти транзакций СУБД в ее собственном файле настроек. Если СУБД поддерживает
Управление параллельным доступом  313
стандартное SQL-выражение SET SESSION CHARACTERISTICS, можно выполнить его для
установки настроек всех транзакций, запускаемых в данном конкретном сеансе ра-
боты с базой данных (имеется в виду конкретное подключение к базе данных, а не
Hibernate-экземпляр Session). Также в SQL стандартизовано выражение SET TRANSACTION,
устанавливающее уровень изолированности текущей транзакции. Наконец,
JDBC Connection API включает метод setTransactionIsolation(), который (соглас-
но документации) «пытается изменить уровень изолированности транзакции для
данного подключения». В приложении Hibernate/JPA экземпляр JDBC Connection
можно получить с помощью оригинального интерфейса Session (см. раздел 17.1).
Но если вы пользуетесь диспетчером транзакций JTA или даже простым пулом
соединений JDBC, мы рекомендуем другой подход. Система управления транзак-
циями JTA, такая как Bitronix, используемая в примерах этой книги, позволяет
устанавливать уровень изолированности транзакций по умолчанию отдельно для
каждого соединения, полученного из пула. В Bitronix можно установить уровень
изолированности по умолчанию вызовом PoolingDataSource#setIsolationLevel().
Более полную информацию ищите в документации к своей реализации источника
данных, сервера приложений или пула соединений JDBC.
Начиная с этого момента, мы будем полагать, что ваши соединения с базой дан-
ных используют уровень изолированности по умолчанию, обеспечивающий чтение
подтвержденных данных. Время от времени конкретная единица работы в прило-
жении может потребовать другого, обычно более строгого уровня изолированности.
Вместо изменения уровня изолированности целой транзакции используйте Java
Persistence API, чтобы получить дополнительные блокировки для соответствующих
данных. Обычно хорошо детализированные блокировки лучше масштабируются
в приложениях с большим количеством потоков. JPA поддерживает оптимистиче-
скую проверку версий и пессимистическую блокировку на уровне базы данных.
11.2.2. Оптимистическое управление
параллельным доступом
Оптимистическое управление параллельным доступом подходит в случаях, когда
изменения вносятся редко и в рамках единицы работы допустимо позднее обна-
ружение конфликтов. Также JPA поддерживает автоматическую проверку версий
в процедуре оптимистического обнаружения конфликтов.
Во-первых, вы должны включить версионирование, поскольку по умолчанию
оно отключено: именно поэтому всегда будет побеждать последняя зафиксирован-
ная транзакция. Большинству многопользовательских приложений, и особенно
веб-приложений, следует полагаться на версионирование всех экземпляров с ан-
нотацией @Entity, которые могут изменяться в многопоточной среде, и использо-
вать более дружественную для пользователя стратегию, при которой побеждает
первая подтвержденная транзакция.
Предыдущий раздел был достаточно скучным, зато теперь мы займемся практи-
кой. После включения автоматической проверки версий вы узнаете, как работает
ручная проверка и когда ее нужно использовать.
314  Транзакции и многопоточность
Включаем версионирование
Версионирование включается с помощью аннотации @Version перед специаль-
ным дополнительным свойством класса сущности, как показано далее.
Листинг 11.2  Включаем версионирование отображаемой сущности
Файл: /model/src/main/java/org/jpwh/model/concurrency/version/Item.java
@Entity
public class Item implements Serializable {
@Version
protected long version;
// ...
}
В этом примере каждому экземпляру сущности приваивается номер версии.
Он отображается на дополнительный столбец в таблице ITEM. Как обычно, имя
столбца по умолчанию совпадает с именем свойства, в данном случае VERSION. На-
стоящие имена свойства и столбца не важны – если VERSION является зарезервиро-
ванным словом в СУБД, используйте другие имена.
Вы можете добавить в класс метод getVersion(), но у вас не должно быть метода
записи, и приложение не должно менять значения поля. Hibernate меняет номер
версии автоматически: он будет увеличивать его каждый раз, когда объект Item
будет оказываться в измененном состоянии во время выталкивания контекста
хранения. Версия – это простой счетчик, не обладающий никакой полезной семан-
тикой, кроме той, что относится к управлению параллельным доступом. Можно
использовать типы int, Integer, short, Short или Long вместо long; если значение
версии достигнет предельного для данного типа значения, Hibernate начнет отсчет
с нуля.
После увеличения номера версии экземпляра Item, чье состояние изменилось,
Hibernate сравнит версии во время выполнения SQL-выражений UPDATE и DELETE.
Например, представьте, что в рамках единицы работы вы загрузили экземпляр
Item и поменяли его имя, как показано в листинге 11.3.
Листинг 11.3  Hibernate автоматически увеличивает номер версии и выполняет
сравнение
Файл: /examples/src/test/java/org\jpwh/test/concurrency/Versioning.java
tx.begin();
em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);  Поиск по идентификатору
// select * from ITEM where ID = ?
assertEquals(item.getVersion(), 0);  Версия экземпляра: 0
item.setName("New Name");
em.flush();  Выталкивает контекст хранения
// update ITEM set NAME = ?, VERSION = 1 where ID = ? and VERSION = 0
Управление параллельным доступом  315
 Поиск экземпляра сущности по идентификатору загружает текущую версию из базы
данных с помощью оператора SELECT.
 Текущая версия экземпляра Item равна 0.
 Выталкивая контекст хранения, Hibernate обнаружит изменения экземпляра Item и уве-
личит версию до 1. SQL-выражение UPDATE теперь выполняет проверку, сохраняя новый
номер версии, только если в базе данных он еще равен 0.
Обратите внимание на выражения SQL, в частности UPDATE и его предложе-
ние WHERE. Это изменение будет успешным лишь в том случае, если в базе дан-
ных существует
запись, для которой истинно выражение VERSION = 0. JDBC вернет
фреймворку Hibernate количество измененных записей; если в результате полу-
чится ноль, это означает, что такой записи в таблице ITEM больше нет или ее версия
отличается от 0. Hibernate обнаружит конфликт во время выталкивания контекста
и возбудит исключение javax.persistence.OptimisticLockException.
Представьте теперь двух пользователей, выполняющих эту единицу работы па-
раллельно, как показано на рис. 11.4. Подтверждение транзакции первым поль-
зователем обновит имя экземпляра Item и запишет в базу данных увеличенный
номер версии, равный 1. Подтверждение транзакции (и выталкивание контекста)
вторым пользователем завершится неудачей, поскольку выполняемое им выраже-
ние UPDATE не найдет в базе данных записи с версией 0. Номер версии в базе данных
равен 1. Таким образом, победит первая зафиксированная транзакция, а вы сможе-
те перехватить исключение OptimisticLockException и обработать его. Например,
можно показать второму пользователю следующее сообщение: «Данные, с кото-
рыми вы работали, были изменены другим пользователем. Пожалуйста, начните
выполнение задачи повторно с измененными данными. Нажмите кнопку “Начать
сначала” для продолжения».
Какие изменения приводят к увеличению номера версии сущности? Hibernate
увеличивает номер версии каждый раз, обнаруживая изменения в состоянии эк-
земпляра сущности. К ним относятся все изменения свойств сущности с типами-
значениями независимо от того, являются они скалярными (как поля типа String
или int), встроенными (как Address) или коллекциями. Исключение составляют
коллекции ассоциаций @OneToMany и @ManyToMany с доступом только на чтение, на-
строенным при помощи mappedBy. Добавление или удаление элементов из этих
коллекций не увеличивает номера версии экземпляра сущности-владельца. Вы
должны понимать, что ничего из этого в JPA не стандартизовано – работая с об-
щей базой данных, не нужно полагаться, что две разные реализации JPA следуют
одним и тем же правилам.
Версионирование в общей базе данных
Если к вашей базе данных обращается сразу несколько приложений и не все они ис-
пользуют алгоритм версионирования Hibernate, вы можете столкнуться с проблемами
параллельного доступа. Эта проблема легко решается с использованием триггеров и хра-
нимых процедур на уровне базы данных: триггер INSTEAD OF может вызывать хранимую
316  Транзакции и многопоточность
процедуру в каждой операции UPDATE; она будет выполняться вместо изменения. Внутри
процедуры можно проверить, увеличило ли приложение номер версии записи; если вер-
сия не обновлялась или столбец версии не был включен в операцию изменения, значит,
это выражение было сформировано не в приложении Hibernate. В таком случае проце-
дура могла бы увеличить номер версии перед выполнением UPDATE.
Если вы не хотите увеличивать номер версии экземпляра сущности при изме-
нении конкретных полей, их нужно отметить аннотацией @org.hibernate.annotations.
OptimisticLock(excluded = true). Вам также может не понравиться наличие
дополнительного столбца VERSION в схеме базы данных. С другой стороны, у вас
уже могут иметься поле с отметкой времени последнего изменения в классе сущ-
ности и соответствующий столбец в базе данных. Hibernate может проверять вер-
сии, используя отметки времени вместо дополнительного поля счетчика.
Версионирование с помощью отметок времени
Если в схеме вашей базы данных уже имеется столбец с отметкой времени, та-
кой как LASTUPDATED или MODIFIED_ON, вместо обычного счетчика для автоматиче-
ской проверки версии можно воспользоваться им.
Листинг 11.4  Версионирование с помощью отметок времени
Файл: /model/src/main/java/org/jpwh/model/concurrency/versiontimestamp/
Item.java
@Entity
public class Item {
@Version
// Необязательно: @org.hibernate.annotations.Type(type = "dbtimestamp")
protected Date lastUpdated;
// ...
}
В этом примере столбец LASTUPDATED отображается в свойство типа java.util.
Date; также Hibernate может работать с типом Calendar. Но использование свойств
этих типов для поддержки версионирования не регламентируется стандартом JPA;
согласно JPA переносимым решением является только тип java.sql.Timestamp. Это
не самый лучший вариант, поскольку придется импортировать этот JDBC-класс
в предметную модель. Вы должны стараться изолировать такие детали реализа-
ции от классов предметной модели, чтобы последние можно было протестировать,
скомпилировать кросс-компилятором (например, в JavaScript с помощью GWT),
сериализовать и десериализовать в как можно большем количестве окружений.
Теоретически версионирование с помощью отметки времени является чуть ме-
нее безопасным, поскольку две параллельно выполняющиеся транзакции могут
обновить и сохранить тот же экземпляр Item в одну миллисекунду; это усугубля-
ется и тем фактом, что обычно JVM не поддерживает точности до миллисекун-
ды (чтобы узнать гарантированную точность, сверьтесь с документацией к вашей
Управление параллельным доступом  317
JVM и операционной системе). Кроме того, получение текущего времени в JVM
может быть небезопасным в кластерном окружении, где системное время узлов
может быть не синхронизировано, или синхронизация времени может быть не на-
столько точной, насколько этого требуют транзакции.
Особенности Hibernate
Вы можете переключиться на использование текущего времени сервера с баз дан-
ных, добавив аннотацию @org.hibernate.annotations.Type(type="dbtimestamp") пе-
ред свойством версии. В этом случае Hibernate будет запрашивать текущее время
у базы данных перед обновлением, например с помощью выражения call current_
timestamp() для базы данных H2. Это позволит использовать единый ресурс для
синхронизации времени. Не все SQL-диалекты Hibernate поддерживают это, по-
этому загляните в исходный код своего диалекта, чтобы узнать, переопределяет ли
он метод getCurrentTimestampSelectString(). Помимо этого, к базе данных проис-
ходит чрезмерное количество обращений при каждом увеличении номера версии.
В новых проектах мы советуем использовать версионирование со счетчиком.
Если вы работаете с унаследованной схемой базы данных или уже существую-
щими классами Java, когда невозможно добавить номер версии или отметку вре-
мени с соответствующими столбцами, то у Hibernate есть для вас альтернативное
решение.
Особенности Hibernate
Версионирование без номера версии или метки времени
Если у вас нет столбцов для хранения версии или отметки времени, Hibernate
все же может обеспечить автоматическое версионирование. Альтернативная реализация
версионирования сравнивает текущее состояние в базе данных с неизме-
ненными значениями хранимых свойств на момент загрузки экземпляра сущно-
сти (или на момент последнего выталкивания контекста хранения).
Эту функциональность можно подключить с помощью оригинальной Hibernate-
аннотации @org.hibernate.annotations.OptimisticLocking:
Файл: model\src\main\java\org\jpwh\model\concurrency\versionall\Item.java
@Entity
@org.hibernate.annotations.OptimisticLocking(
type = org.hibernate.annotations.OptimisticLockType.ALL)
@org.hibernate.annotations.DynamicUpdate
public class Item {
// ...
}
318  Транзакции и многопоточность
Также нужно включить динамическое формирование SQL-выражений UPDATE,
добавив аннотацию @org.hibernate.annotations.DynamicUpdate, как объяснялось
в разделе 4.3.2.
Теперь для сохранения изменений экземпляра Item Hibernate выполнит следующее
выражение SQL:
update ITEM set NAME = ‘New Name’
where ID = 123
and NAME = ‘Old Name’
and PRICE = ‘9.99’
and DESCRIPTION = ‘Some item for auction’
and ...
and SELLER_ID = 45
В предложении WHERE Hibernate перечислит все столбцы с их последними из-
вестными значениями. Если какая-то параллельная транзакция изменила любое
из этих значений или даже удалила запись, это выражение ничего не обновит
и вернет ноль. Затем, во время выталкивания контекста, Hibernate возбудит ис-
ключение.
С другой стороны, Hibernate может использовать для ограничения только из-
мененные поля (в данном примере это только NAME), если выбрать OptimisticLock-
Type.DIRTY. Это значит, что две единицы работы могут параллельно изменить один
экземпляр Item, и Hibernate обнаружит конфликт, только если обе изменят одно
и то же поле с типом-значением (или значение внешнего ключа). Предложение
WHERE из последнего выражения SQL сократится до where ID = 123 and NAME = ‘Old
Name’. Кто-то другой может параллельно изменить цену, но Hibernate не заметит
этого. Исключение javax.persistence.OptimisticLockException возникнет, только
если приложение параллельно изменит значение имени.
Как правило, проверка только изменившихся полей – не лучшая стратегия для
бизнес-сущностей. Возможно, не совсем правильно менять цену товара, когда по-
менялось лишь описание!
Также эта стратегия не подходит для работы с отсоединенным состоянием
и слиянием: при слиянии отсоединенного экземпляра с новым контекстом хра-
нения «старые» значения неизвестны. Для оптимистического управления парал-
лельным доступом отсоединенному экземпляру сущности понадобится номер
версии или отметка времени.
Автоматическое версионирование в Java Persistence позволяет избежать поте-
рянных изменений, когда две параллельные транзакции пытаются подтвердить
изменения одного и того же элемента информации. Также версионирование вруч-
ную позволит получить дополнительные гарантии изоляции, если они вам пона-
добятся.
Проверка версии вручную
Рассмотрим сценарий, требующий повторного чтения информации из базы
данных; представьте, что в систему аукционов добавлены категории и каждый то-
Управление параллельным доступом  319
вар (Item) относится к некоторой категории (Category). Это обычное отображение
@ManyToOne связи Item#category.
Предположим, вам понадобилось найти сумму цен на все товары в нескольких
категориях. Для суммирования потребуется запросить все товары в каждой кате-
гории. А теперь представьте, что произойдет, если кто-то переместит некоторый
товар из одной категории в другую, пока вы будете выполнять запросы, последова-
тельно обращаясь ко всем товарам и категориям? Используя уровень изолирован-
ности, при котором возможно чтение только подтвержденных данных, один и тот
же экземпляр Item может быть обработан дважды!
Чтобы добиться повторимого чтения для запроса получения всех товаров в каж-
дой категории, в JPA-интерфейсе Query объявлен метод setLockMode(). Взгляните
на процедуру в листинге 11.5.
Листинг 11.5  Проверка версии во время выталкивания контекста
для обеспечения повторимого чтения
Файл: /examples/src/test/java/org/jpwh/test/concurrency/Versioning.java
tx.begin();
EntityManager em = JPA.createEntityManager();
BigDecimal totalPrice = new BigDecimal(0);
for (Long categoryId : CATEGORIES) {
List<Item> items =  Запрос, использующий оптимистический (OPTIMISTIC) режим блокировки
em.createQuery("select i from Item i where i.category.id = :catId")
.setLockMode(LockModeType.OPTIMISTIC)
.setParameter("catId", categoryId)
.getResultList();
for (Item item : items)
totalPrice = totalPrice.add(item.getBuyNowPrice());
}
tx.commit();  Выполняет инструкцию SELECT во время выталкивания контекста
em.close();
assertEquals(totalPrice.toString(), "108.00");
 Для каждой категории (Category) выбираются все товары (Item) в режиме блокировки
OPTIMISTIC. Теперь Hibernate знает, что во время выталкивания контекста нужно прове-
рить каждый экземпляр Item.
 Для каждого объекта Item, который был ранее загружен в блокирующем запросе, во вре-
мя выталкивания контекста Hibernate выполнит инструкцию SELECT. Он проверит вер-
сии во всех записях в таблице ITEM. Если хотя бы в одной записи версия будет отличаться
или она была удалена, фреймворк возбудит исключение OptimisticLockException.
И пусть вас не вводит в заблуждение терминология, связанная с блокировка-
ми: спецификация JPA не объясняет, как должен быть реализован каждый режим
блокировок (LockModeType); при выборе режима OPTIMISTIC Hibernate выполняет
проверку версий. Блокировки при этом не используются. Вы должны включить
320  Транзакции и многопоточность
версионирование для класса сущности Item, как объяснялось ранее, в противном
случае вы не сможете использовать оптимистический режим блокировок (LockModeType)
в Hibernate.
При проверке версии вручную Hibernate никак не оптимизирует выражения SELECT:
если вам потребуется сложить цены 100 товаров, во время выталкивания кон-
текста вы получите 100 дополнительных запросов. Как мы покажем далее в этой
главе, для этой конкретной ситуации лучше подойдет пессимистический подход.
Часто задаваемые вопросы:
Почему кэш контекста хранения не может решить эту проблему?
Запрос, выбирающий все товары из конкретной категории, возвращает данные
в виде объекта ResultSet (набора результатов). Затем Hibernate просматривает
значения первичных ключей в этом наборе и сначала пытается получить остальные
данные для каждого экземпляра Item в кэше контекста: он проверяет, был ли загру-
жен экземпляр Item с таким идентификатором. Однако для процедуры из примера
этот кэш будет бесполезен: если параллельная транзакция переместит товар из
одной категории в другую, такой товар может войти в несколько разных коллекций
ResultSet. Hibernate выполнит поиск по идентификатору в своем кэше и скажет: «Да
я ведь уже загрузил этот экземпляр Item; буду использовать то, что уже загружено
в память». Hibernate даже не узнает, что категория товара изменилась или товар
появился второй раз в другом наборе результатов. В данном случае повторное
чтение в контексте хранения скрывает параллельное изменение данных. Чтобы
узнать,
не изменились ли данные, нужно проверять версию вручную.
Как показано в предыдущем примере, интерфейс Query принимает параметр
LockModeType. Явное указание режима блокировки также поддерживается интер-
фейсами TypedQuery и NamedQuery с помощью такого же метода setLockMode().
В JPA доступен дополнительный оптимистический режим блокировки, кото-
рый всегда увеличивает версию сущности.
Принудительное увеличение номера версии
Что произойдет, если два пользователя разместят ставку на один и тот же товар
одновременно? Когда пользователь размещает ставку, приложение должно вы-
полнить несколько действий.
1. Найти в базе данных самую большую ставку (Bid) за товар (Item).
2. Сравнить текущую ставку с самой большой ставкой (Bid); если новая ставка
(Bid) окажется выше, сохранить его в базу данных.
Между этими двумя шагами может возникнуть ситуация гонки. Если между
чтением самой большой ставки (Bid) и записью новой ставки (Bid) будет сделана
еще одна ставка (Bid), вы об этом не узнаете. Это невидимый конфликт; не помо-
жет даже добавление версионирования для класса Item. Во время этой операции
экземпляр Item не обновляется. Только принудительное увеличение номера вер-
сии экземпляра Item позволит обнаружить конфликт.
Управление параллельным доступом  321
Листинг 11.6  Принудительное увеличение номера версии экземпляра сущности
Файл: /examples/src/test/java/org/jpwh/test/concurrency/Versioning.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Item item = em.find(  Вынуждает Hibernate увеличить номер версии
Item.class,
ITEM_ID,
LockModeType.OPTIMISTIC_FORCE_INCREMENT
);
Bid highestBid = queryHighestBid(em, item);
try {
Bid newBid = new Bid(  Сохраняет экземпляр Bid
new BigDecimal("44.44"),
item,
highestBid
);
em.persist(newBid);
} catch (InvalidBidException ex) {  Проверка ставки
}
tx.commit();  Выполнение INSERT для экземпляра Bid
em.close();
 Метод find() принимает параметр типа LockModeType. Режим OPTIMISTIC_FORCE_INCREMENT
требует от Hibernate увеличить версию полученного экземпляра Item после загрузки,
даже если он не изменялся в рамках единицы работы.
 Этот код сохраняет новый экземпляр Bid, никак не влияя на состояние экземпляра Item.
Происходит вставка новой записи в таблицу BID. Без принудительного увеличения но-
мера версии в экземпляре Item Hibernate не сможет обнаружить изменения наибольшей
ставки, сделанного параллельно.
 Для проверки новой ставки используется контролируемое исключение. Новая ставка
должна превышать самую большую на текущий момент.
 Во время выталкивания контекста хранения Hibernate выполнит инструкцию INSERT для
нового экземпляра Bid, а также инструкцию UPDATE с проверкой версии экземпляра Item.
Если кто-то параллельно изменил экземпляр Item или сделал новую ставку с помощью
этой процедуры, Hibernate возбудит исключение.
Параллельное размещение ставок, очевидно, часто будет происходить в системе
для аукционов. Увеличение номера версии вручную может пригодиться во многих
ситуациях, когда приходится вставлять или изменять данные и требуется увели-
чивать версию некоторого аггрегирующего экземпляра.
Обратите внимание, что если вместо связи @ManyToOne сущностей Bid#item уста-
новить связь Item#bids с помощью аннотации @ElementCollection, добавление став-
ки (Bid) в коллекцию увеличит номер версии экземпляра Item. В таком случае при-
нудительное увеличение версии не потребуется. Возможно, вам захочется заново
просмотреть обсуждение неоднозначного отношения родитель/потомок и как
в ORM работают агрегаты и отношения композиции в разделе 7.3.
322  Транзакции и многопоточность
До сих пор мы говорили только об оптимистическом управлении параллель-
ным доступом: мы полагали, что параллельные изменения будут редкими, и зара-
нее не предотвращали параллельного доступа, обнаруживая конфликты позднее.
Иногда известно, что конфликты могут случаться часто и на некоторые данные
нужно устанавливать монопольную блокировку. В таком случае применяется пес-
симистический подход.
11.2.3. Явные пессимистические блокировки
Давайте переделаем процедуру из предыдущего раздела с помощью пессимисти-
ческой блокировки, заменив ею оптимистическую проверку версии. Итак, нам
снова требуется найти сумму всех цен на товары в нескольких категориях. Про-
граммный код останется прежним, как было в листинге 11.5, изменится только
режим блокировки (LockModeType).
Листинг 11.7  Пессимистическая блокировка данных
Файл: /examples/src/test/java/org/jpwh/test/concurrency/Locking.java
tx.begin();
EntityManager em = JPA.createEntityManager();
BigDecimal totalPrice = new BigDecimal(0);
for (Long categoryId : CATEGORIES) {
List<Item> items =  Запрашивает все экземпляры Item
em.createQuery("select i from Item i where i.category.id = :catId")
.setLockMode(LockModeType.PESSIMISTIC_READ)
.setHint("javax.persistence.lock.timeout", 5000)
.setParameter("catId", categoryId)
.getResultList();
for (Item item : items)  Успешное выполнение означает получение монопольной блокировки
totalPrice = totalPrice.add(item.getBuyNowPrice());
}
tx.commit();  Блокировка снимается
em.close();
assertEquals(totalPrice.compareTo(new BigDecimal("108")), 0);
 Для каждой категории (Category) нужно выбрать все товары (Item) в режиме PESSIMISTIC_
READ. Hibernate заблокирует записи в базе данных с помощью запроса SQL. Если
прежде другая транзакция наложила конфликтующую блокировку, подождем 5 секунд.
Если установить блокировку невозможно, запрос возбудит исключение.
 Если запрос выполнился успешно, можно быть уверенным, что монопольная блокиров-
ка получена и никакая другая транзакция не сможет ни получить монопольную блоки-
ровку, ни модифицировать данных, пока текущая транзакция не будет подтверждена.
 После подтверждения транзакции все блокировки снимаются.
Спецификация JPA указывает, что режим блокировки PESSIMISTIC_READ гаран-
тирует повторимость чтения. Также JPA указывает, что режим PESSIMISTIC_WRITE
предоставляет дополнительные гарантии: в дополнение к повторимому чтению
Управление параллельным доступом  323
реализация JPA должна предоставить последовательный доступ к данным, чтобы
сделать невозможными фантомные чтения.
Только реализация JPA решает, следовать ли этим требованиям. В обоих режи-
мах Hibernate добавляет в запрос SQL предложение «for update». Таким способом
устанавливается блокировка записи на уровне базы данных. Тип блокировки, ис-
пользуемой Hibernate, зависит от параметра LockModeType и диалекта базы данных.
Например, для H2 запрос примет следующий вид: SELECT * FROM ITEM ... FOR UPDATE.
Поскольку H2 поддерживает лишь один тип монопольных блокировок, для
всех пессимистических режимов Hibernate сгенерирует одинаковый код SQL.
PostgreSQL, с другой стороны, поддерживает разделяемые блокировки на чте-
ние: режим PESSIMISTIC_READ добавит в запрос SQL предложение FOR SHARE. PESSIMISTIC_
WRITE использует монопольную блокировку на запись, добавляя предложе-
ние FOR UPDATE.
В MySQL параметр PESSIMISTIC_READ превращается в LOCK IN SHARE MODE,
а PESSIMISTIC_
WRITE – в FOR UPDATE. Проверьте диалект вашей базы данных. На-
стройка осуществляется при помощи методов getReadLockString() и getWriteLock-
String().
Пессимистическая блокировка в JPA длится столько же, сколько транзакция
в базе данных. Поэтому монопольную блокировку нельзя использовать для пре-
дотвращения параллельного доступа более чем на время одной транзакции. Если
блокировка в базе данных не может быть получена, возбуждается исключение.
Сравните это поведение с оптимистическим подходом, когда Hibernate возбуж-
дает исключение во время подтверждения транзакции, а не во время выполнения
запроса. Используя пессимистическую стратегию, можно безопасно читать и за-
писывать данные, если блокирующий запрос выполнился успешно. Используя
оптимистический подход, приходится надеяться на лучшее, но можно неприятно
удивиться позже, во время подтверждения транзакции.
Автономные блокировки
Пессимистические блокировки в базе данных действуют только в течение одной
транзакции. Также возможны другие реализации блокировок, например блокиров-
ка в памяти или так называемая таблица блокировок в базе данных. Такие типы
блокировок называются автономными.
Пессимистическая блокировка, длящаяся дольше одной транзакции, обычно нега-
тивно влияет на производительность; каждое обращение к данным требует допол-
нительных проверок с помощью глобального синхронизированного диспетчера
блокировок. С другой стороны, оптимистическая блокировка является прекрасной
стратегией управления параллельным доступом при длительных диалоговых взаимодействиях
(как вы увидите в следующей главе) и обладает прекрасной произ-
водительностью. В зависимости от стратегии разрешения конфликтов – т. е. дей-
ствий после обнаружения конфликта – пользователи приложения будут довольны
настолько, насколько это позволит блокирование параллельного доступа. Также
им бы понравилось, что приложение не блокирует доступа к определенным экра-
нам с данными, когда другие просматривают те же самые данные.
324  Транзакции и многопоточность
Есть возможность задать время, в течение которого база данных будет ожидать
получения блокировки и приостанавливать выполнение запроса, применяя реко-
мендацию javax.persistence.lock.timeout. Как обычно бывает с рекомендациями,
Hibernate может ее проигнорировать в зависимости от реализации базы данных.
Например, H2 не поддерживает времени ожидания блокировки для отдельного
запроса – только общее время ожидания для каждого соединения (по умолчанию
1 сек). В некоторых диалектах, таких как PostgreSQL и Oracle, время ожидания
блокировки, равное 0, добавляет в запрос SQL предложение NOWAIT.
Мы показали, как использовать рекомендацию со временем ожидания бло-
кировки для интерфейса Query. Вы также можете использовать рекомендацию
со временем ожидания в операциях find():
Файл: /examples/src/test/java/org/jpwh/test/concurrency/Locking.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Map<String, Object> hints = new HashMap<String, Object>();
hints.put("javax.persistence.lock.timeout", 5000);
Category category =
em.find(
Category.class,
CATEGORY_ID,
LockModeType.PESSIMISTIC_WRITE,
hints
);
category.setName("New Name");
tx.commit();
em.close();
Когда блокировка не может быть получена, Hibernate возбудит исключение
javax.persistence.LockTimeoutException, или javax.persistence.PessimisticLock-
Exception. Получив исключение PessimisticLockException, приложение должно
откатить транзакцию и прекратить выполнение единицы работы. Исключение
LockTimeoutException, наоборот, не является фатальным, как объяснялось в раз-
деле 11.1.4. Тип исключения зависит от диалекта SQL. Например, поскольку H2
не поддерживает времени ожидания блокировки для отдельного выражения, вы
всегда будете получать PessimisticLockException.
Вы можете использовать оба режима – PESSIMISTIC_READ и PESSIMISTIC_WRITE,
даже если не используете версионирования сущностей. Они будут преобразованы
в выражения SQL с блокировками на уровне базы данных.
Однако специальный режим PESSIMISTIC_FORCE_INCREMENT требует версиони-
рования. В Hibernate этот режим использует блокировку FOR UPDATE NOWAIT (или
ту, что поддерживает диалект базы данных; посмотрите реализацию метода get-
ForUpdateNowaitString()). Затем, сразу же после выполнения запроса, Hibernate
увеличивает номер версии и выполняет операцию UPDATE для (!) каждого получен-
Выполнит запрос SELECT ... FOR UPDATE WAIT 5000,
если диалект поддерживает подсказки
Управление параллельным доступом  325
ного экземпляра сущности. Это сообщит всем параллельным транзакциям, что вы
обновили эти строки, даже если никакие данные не изменялись. Данный режим
редко оказывается полезным и используется в основном для блокирования агре-
гатов, как было показано в разделе «Принудительное увеличение номера версии».
А что по поводу режимов блокировки READ и WRITE?
Это старые режимы блокировки, пришедшие из Java Persistence 1.0, и они не
должны больше использоваться. LockModeType.READ является эквивалентом режима
OPTIMISTIC, а LockModeType.WRITE – эквивалентом режима OPTIMISTIC_FORCE_INCREMENT.
При использовании пессимистических блокировок Hibernate блокирует только
записи, которые относятся к состоянию экземпляра сущности. Другими словами,
если заблокировать экземпляр Item, Hibernate заблокирует соответствующую за-
пись в таблице ITEM. Если используется стратегия наследования с соединениями,
Hibernate поймет это и заблокирует нужные строки в таблицах суперклассов
и подклассов. Это также относится к любому отображению сущности во вто-
ричную таблицу. Поскольку Hibernate блокирует всю запись, любое отношение,
внешний ключ которого находится в этой записи, также будет заблокировано:
связь Item#seller будет заблокирована, если столбец внешнего ключа SELLER_ID
находится в таблице ITEM. Но сам экземпляр Seller заблокирован не будет! Кол-
лекции и прочие связи класса Item, внешний(е) ключ(и) которых находится(ятся)
в других таблицах, также не будут заблокированы.
Используя монопольные блокировки в СУБД, можно столкнуться с неудачным
завершением транзакций из-за взаимоблокировок.
Расширение области действия блокировки
JPA 2.0 определяет параметр PessimisticLockScope.EXTENDED. Он может быть исполь-
зован в качестве рекомендации для запроса javax.persistence.lock.scope. При на-
личии этого параметра механизм хранения расширит область заблокированных
данных, включив в нее любые данные коллекций и таблицы соединения со связями
с заблокированными сущностями. На момент написания книги этот параметр еще
не был реализован в Hibernate.
11.2.4. Как избежать взаимоблокировок
В СУБД, реализующих изолированность транзакций с применением монопольных
блокировок, могут возникать взаимоблокировки. Рассмотрим следующую едини-
цу, обновляющую два экземпляра сущностей Item в определенном порядке:
tx.begin();
EntityManager em = JPA.createEntityManager();
Item itemOne = em.find(Item.class, ITEM_ONE_ID);
itemOne.setName("First new name");
326  Транзакции и многопоточность
Item itemTwo = em.find(Item.class, ITEM_TWO_ID);
itemTwo.setName("Second new name");
tx.commit();
em.close();
Выталкивая контекст хранения, Hibernate выполнит две SQL-инструкции UPDATE.
Первая заблокирует запись, представляющую первый экземпляр Item, а вто-
рая – представляющую второй экземпляр:
update ITEM set ... where ID = 1; Заблокирует запись 1
update ITEM set ... where ID = 2; Пытается заблокировать запись 2
Взаимоблокировка может возникнуть (а может и не возникнуть!), если в парал-
лельной транзакции будет выполняться похожая процедура, но с обратным поряд-
ком изменения экземпляров Item:
update ITEM set ... where ID = 2; Заблокирует запись 1
update ITEM set ... where ID = 1; Пытается заблокировать запись 2
При возникновении взаимоблокировки обе транзакции оказываются заблоки-
рованными – они не могут выполняться дальше, ожидая снятия блокировки. Веро-
ятность взаимоблокировки обычно мала, но в ситуациях с высокой вероятностью
параллельного доступа два приложения Hibernate могут выполнить подобное че-
редующееся изменение. Обратите внимание, что во время тестирования можно
не столкнуться со взаимоблокировками (если, конечно, не написать правильных
тестов). Но когда приложение работает с высокой транзакционной нагрузкой,
взаимоблокировки
могут возникать совершенно неожиданно. Обычно по истече-
нии периода ожидания СУБД завершает одну из заблокированных транзакций как
неудачную; остальные транзакции могут продолжить выполнение. С другой сто-
роны, СУБД может автоматически определять состояние взаимоблокировки и не-
медленно прерывать выполнение одной из транзакций, но это зависит от СУБД.
Старайтесь избегать неудачного завершения транзакций, поскольку после них
довольно трудно восстанавливать нормальную работу приложения. Одно из ре-
шений заключается в использовании для конкретного соединения с базой данных
уровня изолированности, обеспечивающего упорядоченность, блокирующую всю
таблицу при изменении одной записи. Параллельная транзакция должна ожидать,
пока первая транзакция завершит работу. С другой стороны, первая транзакция
может получить монопольную блокировку всех данных с помощью инструкции
SELECT, как было показано в предыдущем разделе. Тогда любая параллельная
транзакция
также должна будет ждать снятия этих блокировок.
В качестве альтернативы можно использовать программную оптимизацию, ко-
торая значительно снижает вероятность взаимоблокировок, упорядочивая выра-
жения UPDATE по значению первичного ключа: Hibernate всегда обновляет запись
с первичным ключом 1 перед изменением записи 2, независимо от того, в каком
порядке данные были загружены и изменены в приложении. Вы можете исполь-
зовать эту оптимизацию для всей единицы хранения, добавив параметр hiberДоступ
к данным вне транзакции  327
nate.order_updates в конфигурацию. После этого Hibernate будет упорядочивать
все инструкции UPDATE в порядке возрастания значений первичного ключа экзем-
пляров сущностей и элементов коллекций, обнаруженных во время выталкива-
ния контекста (как уже говорилось ранее, вы должны всецело понимать работу
транзакций и блокировок в вашей СУБД. Большинство транзакционных гарантий
Hibernate наследует от СУБД; например, база данных, поддерживающая версио-
нирование (MVCC), может не блокировать параллельного доступа для чтения, но
применять монопольные блокировки для изоляции пишущих транзакций, в ре-
зультате вы можете столкнуться с взаимоблокировками).
У нас еще не было возможности представить метод EntityManager#lock(). Он
принимает загруженный хранимый экземпляр сущности и значение режима бло-
кировки. Устанавливает такие же блокировки, как метод find() и интерфейс Query,
с той лишь разницей, что он не загружает экземпляра. Кроме того, если сущность
с версионированием блокируется пессимистически, метод lock() сразу же выпол-
няет проверку версии в базе данных и потенциально может возбудить OptimisticLockException.
Если представление экземпляра было удалено из базы данных, Hibernate
возбудит EntityNotFoundException. Наконец, метод EntityManager#refresh()
тоже принимает значение режима блокировки с такой же семантикой.
Мы рассмотрели управление параллельным доступом на самом низком уровне,
в базе данных, а также особенности оптимистических и пессимистических блоки-
ровок в JPA. Но нужно обсудить еще один аспект параллельного доступа: работу
с данными вне транзакции.
11.3. Доступ к данным вне транзакции
Экземпляр JDBC Connection по умолчанию работает в режиме автоматического
подтверждения (auto-commit). Этот режим удобен для выполнения произволь-
ных запросов SQL.
Представьте, что вы подключились к базе данных с помощью консоли SQL и вы-
полнили несколько запросов, возможно, обновив и удалив несколько записей. Та-
кое интерактивное обращение к данным является произвольным; в большинстве
случаев у вас нет плана или последовательности операций, которые можно было
бы считать единицей работы. Режим автоматического подтверждения отлично
подходит для подобной работы с данными. В конце концов, мало кому захочется
каждый раз вводить begin transaction и end transaction для каждого выражения
SQL. В режиме автоматического подтверждения каждая (непродолжительная)
транзакция начинается и заканчивается вместе с каждым запросом SQL, посылаемым
в базу данных. Фактически вы работаете в нетранзакционном режиме, по-
скольку сеанс в консоли SQL не гарантирует ни атомарности, ни изолированности.
(Единственная гарантия – каждое выражение SQL в отдельности будет выполнено
атомарно.)
Приложение по определению всегда выполняет запланированную последова-
тельность выражений. По этой причине кажется разумным всегда определять гра-
328  Транзакции и многопоточность
ницы транзакций, группируя выражения в атомарные единицы, изолированные
друг от друга. Тем не менее в JPA с режимом автоматической фиксации связана
особая функциональность, и он может понадобиться для реализации длительных
диалоговых взаимодействий. Режим автоматического подтверждения в приложе-
ниях можно использовать, например, для чтения данных.
11.3.1. Чтение данных в режиме автоматического
подтверждения
Рассмотрим следующий пример, сначала загружающий экземпляр Item, изменяющий
его свойство name, а потом откатывающий изменения повторным чтением
данных.
Листинг 11.8  Чтение данных в режиме автоматического подтверждения
Файл: /examples/src/test/java/org/jpwh/test/concurrency/
NonTransactional.java
EntityManager em = JPA.createEntityManager();  Рассинхронизированный режим
Item item = em.find(Item.class, ITEM_ID);  Обращение к базе данных
item.setName("New Name");
assertEquals(  Возвращает начальное значение
em.createQuery("select i.name from Item i where i.id = :id)")
.setParameter("id", ITEM_ID).getSingleResult(),
"Original Name"
);
assertEquals(  Возвращает уже загруженный экземпляр
((Item) em.createQuery("select i from Item i where i.id = :id)")
.setParameter("id", ITEM_ID).getSingleResult()).getName(),
"New Name"
);
// em.flush();  Возбуждает исключение
em.refresh(item);  Откатывает изменение
assertEquals(item.getName(), "Original Name");
em.close();
 В момент создания объекта EntityManager ни одна транзакция не активна. Контекст
хранения находится в особом, рассинхронизированном режиме – Hibernate не будет вы-
талкивать контекста автоматически.
 Вы можете читать данные из базы; эта операция выполнит инструкцию SELECT, передав
ее в базу данных в режиме автоматического подтверждения.
 Обычно Hibernate выталкивает контекст хранения при выполнении запроса (Query). Но
поскольку контекст рассинхронизирован, выталкивание не происходит, и запрос возвра-
щает старое, начальное значение. Запросы со скалярными результатами не повторимы:
вы видите только те значения, которые есть в базе данных и были переданы в Hibernate
в виде объекта ResultSet. Кроме того, в синхронизированном режиме вы получите непо-
вторимое чтение.
Доступ к данным вне транзакции  329
 Получение управляемого экземпляра сущности включает в себя поиск в текущем кон-
тексте хранения. Контекст возвращает уже загруженный экземпляр Item с измененным
названием; значения в базе данных игнорируются. Это чтение экземпляра сущности по-
вторимо, даже в отсутствие системной транзакции.
 При попытке вытолкнуть контекст хранения вручную, чтобы сохранить новое значение
Item#name, Hibernate возбудит javax.persistence.TransactionRequiredException. Нельзя
выполнять операцию UPDATE в рассинхронизированном режиме, потому что он не позво-
ляет откатить изменения.
 Откатить изменения можно вызовом метода refresh(). Он загружает текущее состояние
экземпляра Item из базы данных и перезаписывает сделанные в памяти изменения.
Используя рассинхронизированный контекст хранения, данные можно читать
в режиме автоматического подтверждения, используя запросы или методы find(),
getReference() и refresh(). Также можно загружать данные при необходимости:
инициализация прокси-объектов происходит при обращении к ним, а коллекции
загружаются в момент начала обхода элементов. Но если попытаться вытолкнуть
контекст хранения или заблокировать данные в режиме, отличном от LockModeType.
NONE, возникнет исключение TransactionRequiredException.
Пока что режим автоматического подтверждения кажется не особо полезным.
Действительно, многие разработчики заблуждаются в мотивах применения режи-
ма автоматического подтверждения:
 множество коротких транзакций для отдельных выражений (суть режима
автоматического подтверждения) не улучшит производительности прило-
жения;
 ухудшается масштабируемость приложения: одна продолжительная транзакция
вместо нескольких коротких для отдельных выражений SQL может
дольше удерживать блокировку. Но эта проблема незначительна, поскольку
Hibernate выполняет запись в базу данных как можно позже, ближе к кон-
цу транзакции (выталкивание контекста происходит во время подтвержде-
ния), поэтому фактически база данных удерживает блокировку на запись
лишь короткий промежуток времени;
 слабые гарантии изолированности, если приложение будет менять данные
параллельно. Повторимое чтение с помощью блокировок на запись невоз-
можно в режиме автоматического подтверждения (естественно, здесь на по-
мощь приходит кэш контекста хранения);
 если СУБД реализует управление параллельным доступом с помощью вер-
сионирования (MVCC), как, например, Oracle, PostreSQL, Informix или Firebird,
у вас наверняка появится желание использовать возможность изоля-
ции моментальных снимков, чтобы избежать неповторимого и фантомного
чтения. Каждая транзакция получает собственный моментальный снимок
данных; вы видите ту версию данных (внутри базы данных), какой она была
перед началом транзакции. При работе в режиме автоматического под-
тверждения изоляция моментального снимка не имеет смысла, поскольку
отсутствует область действия транзакции;
330  Транзакции и многопоточность
 снижается ясность программного кода. Теперь каждый, кто читает ваш код,
должен обращать особое внимание, присоединен ли контекст хранения
к транзакции или находится в рассинхронизированном режиме. Если вы
постоянно группируете операции внутри системной транзакции даже при
чтении данных, каждый сможет следовать этому простому правилу, что по-
зволит снизить количество трудных для обнаружения проблем с многопо-
точностью.
Какими же преимуществами обладает рассинхронизированный контекст хра-
нения? Если выталкивание контекста не происходит автоматически, вы можете
подготовить все изменения вне транзакции, поместив их в очередь.
11.3.2. Создание очереди изменений
Следующий пример демонстрирует сохранение экземпляра Item с помощью рас-
синхронизированного экземпляра EntityManager:
Файл: /examples/src/test/java/org/jpwh/test/concurrency/NonTransactional.java
EntityManager em = JPA.createEntityManager();
Item newItem = new Item("New Item");
em.persist(newItem)  Сохранение временного экземпляра
assertNotNull(newItem.getId());
tx.begin();  Сохранение изменений
if (!em.isJoinedToTransaction())
em.joinTransaction();
tx.commit(); Выталкивание!
em.close();
 Сохранить временный экземпляр сущности в рассинхронизированном контексте мож-
но вызовом метода persist(). Hibernate просто получит новое значение идентификато-
ра, обратившись к последовательности в базе данных, и назначит его экземпляру. Теперь
экземпляр находится в хранимом состоянии внутри контекста, но SQL-инструкция
INSERT еще не выполнилась. Обратите внимание, что такое возможно только при ис-
пользовании генератора идентификаторов, срабатывающего перед вставкой; см. раз-
дел 4.2.5.
 Когда изменения будут готовы к сохранению, присоедините контекст к транзакции.
Синхронизация и выталкивание контекста произойдут как обычно, во время подтверж-
дения транзакции. Hibernate запишет все накопленные изменения в базу данных.
Также в очередь можно поместить операцию слияния для отсоединенного эк-
земпляра сущности:
Файл: /examples/src/test/java/org/jpwh/test/concurrency/NonTransactional.java
detachedItem.setName("New Name");
EntityManager em = JPA.createEntityManager();
Доступ к данным вне транзакции  331
Item mergedItem = em.merge(detachedItem);
tx.begin();
em.joinTransaction();
tx.commit(); Выталкивание контекста!
em.close();
Hibernate выполнит инструкцию SELECT в режиме автоматического подтверж-
дения во время вызова merge(). Но отложит выполнение UPDATE до подтверждения
присоединенной транзакции.
Очередь можно создать и для удаления экземпляров сущностей и операций DELETE:
Файл: /examples/src/test/java/org/jpwh/test/concurrency/NonTransactional.java
EntityManager em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);
em.remove(item);
tx.begin();
em.joinTransaction();
tx.commit(); Выталкивание контекста!
em.close();
Рассинхронизированный контекст позволяет отделять операции с хранимы-
ми сущностями от транзакций. Эта особенность поведения EntityManager сыграет
важную роль в дальнейшем, когда мы приступим к обсуждению архитектуры при-
ложения. Возможность накапливать изменения данных независимо от транзак-
ций (а также запросов клиент/сервер) является главной особенностью контекста
хранения.
Режим выталкивания контекста вручную
В Hibernate имеется метод Session#setFlushMode() с дополнительным параметром
FlushMode.MANUAL, отключающим автоматическое выталкивание контекста хранения
даже в случае подтверждения присоединенной транзакции. В этом режиме вам
придется самостоятельно вызывать flush() для синхронизации с базой данных.
Спецификация JPA исповедует идею: «подтверждение транзакции всегда должно
приводить к записи любых изменений». Поэтому в ней чтение было отделено от
записи с помощью рассинхронизированного режима. Если вы не согласны с этим
и/или не хотите автоматически подтверждать изменения после выполнения ин-
струкций, можете использовать режим ручного сохранения контекста с помощью
Session API. В результате вы получите обычные границы транзакций для всех еди-
ниц работы, повторимое чтение и даже изоляцию моментальных снимков (если
поддерживаются) и сможете накапливать изменения в контексте хранения для
последующей обработки и ручного вызова метода flush() перед подтверждением
транзакции.
332  Транзакции и многопоточность
11.4. Резюме
 Вы узнали, как использовать транзакции, многопоточность, изолированность
и блокировки.
 Hibernate полагается на механизм управления параллельным доступом в базе
данных, но дает лучшие гарантии изолированности транзакций благодаря ав-
томатическому версионированию и кэшу контекста хранения.
 Мы обсудили программное определение границ транзакций и обработку ис-
ключений.
 Вы познакомились с оптимистическим управлением параллельным доступом
и явными пессимистическими блокировками.
 Вы узнали, как работать с режимом автоматического подтверждения и рассин-
хронизированным контекстом хранения, а также как накапливать изменения.
Глава 12
Планы извлечения,
стратегии и профили
В этой главе:
 отложенная и немедленная загрузка;
 планы извлечения, стратегии и профили;
 оптимизация выполнения SQL.
В этой главе мы исследуем решение фундаментальной проблемы ORM – обхода
графа объектов, о чем упоминалось в разделе 1.2.5. Мы покажем, как извлекать
информацию из базы данных и как этот процесс можно оптимизировать.
Hibernate поддерживает следующие способы загрузки информации из базы
данных в память.
 Если известно уникальное значение идентификатора экземпляра сущности,
самый удобный способ получить его – выполнить поиск по идентификато-
ру, например entityManager.find(Item.class, 123).
 Имеется возможность начать обход графа объектов с уже загруженного эк-
земпляра сущности, обращаясь к связанным сущностям через методы до-
ступа к свойствам, такие как someItem.getSeller().getAddress().getCity()
и т. д. Элементы отображаемых коллекций также могут загружаться по
требованию в начале обхода коллекции. Hibernate автоматически загружа-
ет вершины графа объектов, если контекст хранения еще открыт. Эта глава
расскажет, какие данные загружаются при вызове методов доступа и обходе
коллекций и каким способом происходит загрузка.
 Поддерживается полноценный объектно-ориентированный язык запросов
Java Persistence Query Language (JPQL), использующий строковое пред-
ставление, например select i from Item i where i.id = ?.
 Интерфейс CriteriaQuery реализует типобезопасный и объектно-ориенти-
рованный способ выполнения запросов без использования строк.
 Имеется возможность писать запросы на чистом SQL, вызывать хранимые
процедуры и переложить на плечи фреймворка Hibernate отображение ре-
зультатов запроса JDBC в экземпляры классов предметной модели.
334  Планы извлечения, стратегии и профили
В своих приложениях JPA вы будете применять комбинацию этих подходов, но
в этой главе мы не станем подробно разбирать каждый способ извлечения данных.
Вы уже достаточно хорошо знакомы с основами Java Persistence API, чтобы са-
мостоятельно реализовать загрузку по идентификатору. Мы постарались сделать
примеры с JPQL и CriteriaQuery как можно более простыми, чтобы вам не при-
шлось использовать средства отображения запросов SQL. Поскольку эта функциональность
довольно запутанна, мы исследуем ее позже в главах 15 и 17.
Главные нововведения в JPA 2
• Теперь можно вручную проверять состояние загрузки сущности или ее свойств,
используя статические методы вспомогательного класса PersistenceUtil.
• Можно создавать стандартизованные декларативные планы извлечения с помощью
нового интерфейса EntityGraph.
Эта глава рассказывает, что происходит за кулисами, когда выполняется обход
графа объектов предметной модели и когда Hibernate загружает данные по требо-
ванию. Во всех примерах мы будем показывать в комментариях код SQL, выпол-
няемый фреймворком Hibernate.
Что именно загрузит Hibernate, зависит от плана извлечения: вы определяете
(под)граф множества объектов для загрузки. Затем выбираете стратегию извле-
чения, определяя, как должны загружаться данные. План и стратегию можно со-
хранить в виде профиля извлечения, чтобы использовать их повторно.
Определение плана извлечения, какие данные должен загрузить Hibernate, за-
висит от двух фундаментальных способов загрузки вершин графа объектов: от-
ложенного (lazy) и немедленного (eager).
12.1. Отложенная и немедленная загрузка
В какой-то момент приходится выбирать, какие данные должны быть загружены
в память из базы. Что окажется в памяти и будет загружено в контекст хранения
при вызове entityManager.find(Item.class, 123)? Что произойдет, если вместо этого
вызвать EntityManager#getReference()?
В отображении предметной модели для связей и коллекций можно определить
глобальный план извлечения по умолчанию с помощью параметров FetchType.LAZY
и FetchType.EAGER. Он будет использоваться по умолчанию для всех операций
с участием классов предметной модели. Он всегда будет использоваться при за-
грузке экземпляра сущности по идентификатору, обходе графа объектов по свя-
зям и в итерациях по хранимым коллекциям.
В качестве плана извлечения по умолчанию мы рекомендуем использовать
стратегию отложенной загрузки для всех сущностей и коллекций. Если все связи
и коллекции отобразить с параметром FetchType.LAZY, Hibernate будет загружать
только данные, к которым происходит обращение в данный момент. Во время об-
хода графа экземпляров предметной модели Hibernate будет загружать данные по
Отложенная и немедленная загрузка  335
требованию, шаг за шагом. При необходимости это поведение можно переопреде-
лять в отдельных ситуациях.
Для реализации отложенной загрузки Hibernate использует сгенерированные
во время выполнения заглушки, называемые прокси-объектами или, в случае кол-
лекций, умными обертками.
12.1.1. Прокси-объекты
Рассмотрим метод getReference() интерфейса EntityManager. Мы впервые позна-
комились с этим интерфейсом в разделе 10.2.3 и узнали, как он может возвращать
прокси-объекты. Давайте исследуем эту важную особенность далее и узнаем, как
же работают прокси-объекты:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
Item item = em.getReference(Item.class, ITEM_ID); Никакого SELECT
assertEquals(item.getId(), ITEM_ID);
Этот код не повлечет отправки SQL-запроса в базу данных. Hibernate просто
создаст прокси-объект Item: он выглядит (и кажется) как настоящий объект, но это
всего лишь заглушка. В контексте хранения, в памяти, появится прокси-объект
в хранимом состоянии, как показано на рис. 12.1.
Рис. 12.1  Контекст хранения
содержит прокси-объект Item
Прокси-объект – это экземпляр подкласса Item, сгенерированный во время вы-
полнения и хранящий значение идентификатора представляемого им экземпляра
сущности. Вот почему Hibernate (наряду с JPA) требует, чтобы класс сущности
имел общедоступный или защищенный конструктор без аргументов (класс также
может иметь другие конструкторы). Чтобы Hibernate смог сгенерировать прокси-
объект, класс сущности и его методы не должны быть финальными (final). Обрати-
те внимание, что спецификация JPA вообще не упоминает прокси-объектов; способ
осуществления отложенной загрузки полностью зависит от реализации JPA.
Если вызвать любой метод прокси-объекта, отличный от метода чтения иден-
тификатора, произойдут обращение к базе данных и инициализация прокси-объ-
екта. При вызове item.getName() выполнится SQL-инструкция SELECT, которая
Вызов метода чтения идентификатора (без доступа
к членам класса!) не вызовет инициализацию
336  Планы извлечения, стратегии и профили
загрузит экземпляр Item. Вызов item.getId() в предыдущем примере не повлек
инициализации, поскольку в данном отображении getId() является методом чте-
ния идентификатора; метод getId() был отмечен аннотацией @Id. Если поместить
аннотацию @Id перед полем, вызов getId(), как и любого другого метода, повлек
бы инициализацию прокси-объекта! (Как вы наверняка помните, мы обычно реко-
мендуем применять аннотации отображения и доступа к полям класса, поскольку
это дает больше свободы при проектировании методов доступа; см. раздел 3.2.3.
Только вам решать, является ли более важным вызов getId() без инициализации
прокси-объекта.)
Будьте осторожней, сравнивая классы при работе с прокси-объектами. По-
скольку прокси-класс генерируется фреймворком Hibernate, он получает доволь-
но забавное имя, не совпадающее со значением Item.class:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
assertNotEquals(item.getClass(), Item.class);
assertEquals(
HibernateProxyHelper.getClassWithoutInitializingProxy(item),
Item.class
);
Если потребуется получить действительный тип, представляемый прокси-
классом, используйте класс HibernateProxyHelper.
В JPA имеется класс PersistenceUtil, который можно использовать для провер-
ки состояния инициализации сущности или любого ее атрибута:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
PersistenceUtil persistenceUtil = Persistence.getPersistenceUtil();
assertFalse(persistenceUtil.isLoaded(item));
assertFalse(persistenceUtil.isLoaded(item, "seller"));
assertFalse(Hibernate.isInitialized(item));
// assertFalse(Hibernate.isInitialized(item.getSeller())); Вызовет инициализацию item!
Статический метод isLoaded() также принимает имя свойства данного экзем-
пляра сущности (прокси-объекта) и проверяет его состояние инициализации. Hibernate
поддерживает альтернативный метод Hibernate.isInitialized(). Но если
вызвать item.getSeller(), сначала произойдет инициализация прокси-объекта
item!
Особенности Hibernate
В Hibernate также имеется метод для инициализации прокси-объектов по требо-
ванию:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
Hibernate.initialize(item);
// select * from ITEM where ID = ?
Класс сгенерирован во время выполнения и получает
примерно такое имя: Item_$$_javassist_1
Отложенная и немедленная загрузка  337
assertFalse(Hibernate.isInitialized(item.getSeller()));
Hibernate.initialize(item.getSeller());
// select * from USERS where ID = ?
Первый вызов произведет обращение к базе данных и загрузит информацию
для экземпляра Item, инициализируя такие свойства прокси-объекта, как имя,
цена и т. д.
Свойство seller объекта Item представляет связь @ManyToOne, отображаемую
с параметром FetchType.LAZY, поэтому во время загрузки экземпляра Item фрейм-
ворк Hibernate создаст прокси-объект User. Вы можете проверить состояние
прокси-объекта seller и загрузить его вручную точно так же, как экземпляр
Item. Помните, что в JPA аннотация @ManyToOne по умолчанию получает параметр
FetchType.EAGER! Обычно его желательно переопределить, чтобы использовать
план отложенного извлечения, как впервые было показано в разделе 7.3.1, а те-
перь и здесь:
Файл: /model/src/main/java/org/jpwh/model/fetching/proxy/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.LAZY)
public User getSeller() {
return seller;
}
// ...
}
Используя план отложенного извлечения, можно столкнуться с исключением
LazyInitializationException. Рассмотрим следующий код:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
Item item = em.find(Item.class, ITEM_ID);  Загрузка экземпляра Item
// select * from ITEM where ID = ?
em.detach(item);  Отсоединение данных
em.detach(item.getSeller());
// em.close();
PersistenceUtil persistenceUtil = Persistence.getPersistenceUtil();
assertTrue(persistenceUtil.isLoaded(item));
assertFalse(persistenceUtil.isLoaded(item, "seller"));
assertEquals(item.getSeller().getId(), USER_ID);  Вызывает метод чтения
// assertNotNull(item.getSeller().getUsername()); Возбудит исключение!
 Экземпляр сущности Item загружается в контекст хранения. Свойство seller не инициализируется,
так как это прокси-объект User.
 Вы можете отсоединить данные от контекста хранения вручную или закрыть контекст,
отсоединив все.
Убедитесь, что значение по умолчанию EAGER
в аннотации @ManyToOne было заменено на LAZY
 Вспомогательный класс
PersistenceUtil
338  Планы извлечения, стратегии и профили
 Статический вспомогательный класс PersistenceUtil работает без контекста хранения.
В любой момент вы можете проверить, были ли загружены данные, к которым предпо-
лагается обратиться.
 В отсоединенном состоянии допускается вызывать метод чтения идентификатора прок-
си-объекта User. Но вызов любого другого метода прокси-объекта, такого как getUsername(),
возбудит исключение LazyInitializationException. Данные могут загружаться по
требованию, только пока прокси-объект находится под управлением контекста хране-
ния, но не в отсоединенном состоянии.
Как работает отложенная загрузка связей один к одному?
Отложенная загрузка связи один к одному иногда вводит новых пользователей
Hibernate в замешательство. Например, связь один к одному, использующая раз-
деляемый первичный ключ (см. раздел 8.1.1), может быть представлена прокси-
объектом только при использовании параметра optional=false. Например, адрес
(Address) всегда имеет ссылку на пользователя (User). Если связь может иметь зна-
чение null и не является обязательной, Hibernate должен сначала обратиться к базе
данных и выяснить, нужно ли возвращать прокси-объект или null; но цель отложен-
ной загрузки как раз в том и состоит, чтобы избежать обращений к базе данных.
Вы всегда можете настроить отложенную загрузку необязательных связей один
к одному путем перехвата вызовов, и мы обсудим этот прием ниже в данной главе.
Прокси-объекты Hibernate могут пригодиться не только в случае простой от-
ложенной загрузки. Например, можно сохранить новую ставку (Bid), не загружая
в память никаких данных:
Item item = em.getReference(Item.class, ITEM_ID);
User user = em.getReference(User.class, USER_ID);
Bid newBid = new Bid(new BigDecimal("99.00"));
newBid.setItem(item);
newBid.setBidder(user);
em.persist(newBid);
// insert into BID values (?, ? ,? , ...)
Два первых вызова создадут прокси-объекты товара (Item) и пользователя
(User) соответственно. Затем полям связей временного экземпляра ставки (Bid)
с товаром (item) и пользователем (bidder) будут присвоены значения в виде прок-
си-объектов. Вызов persist() поместит в очередь одну SQL-инструкцию INSERT,
и для создания записи в таблице BID не понадобится ни одной инструкции SELECT,
потому что значения всех (внешних) ключей доступны как значения идентифика-
торов прокси-объектов Item и User.
Динамическое создание прокси-классов фреймворком Hibernate во время вы-
полнения – превосходное решение для прозрачной отложенной загрузки. Классы
предметной модели не должны наследовать каких-либо специальных (супер)ти-
пов, как это было в более старых решениях ORM. Также не требуется генериро-
В этой процедуре не выполняется ни одного SQL-запроса
SELECT, только одна инструкция INSERT
Отложенная и немедленная загрузка  339
вать дополнительный код или выполнять постобработку байт-кода, что упрощает
процедуру сборки проекта. Но вы должны иметь в виду некоторые негативные
аспекты:
 когда полиморфные ассоциации проверяются оператором instanceof, сгене-
рированные во время выполнения прокси-классы не являются полностью
прозрачным решением, как было показано в разделе 6.8.1;
 при работе с прокси-классами сущностей нужно избегать прямых обраще-
ний к полям в реализациях методов equals() и hashCode(), как обсуждалось
в разделе 10.3.2;
 прокси-объекты могут использоваться только для отложенной загрузки свя-
зей сущностей. Они не могут применяться для отложенной загрузки полей
простых типов или встроенных компонентов, таких как Item#description
или User#homeAddress. Если для такого поля указать подсказку @Basic(fetch =
FetchType.LAZY), Hibernate ее проигнорирует; значение будет загружено сра-
зу же при загрузке экземпляра сущности-владельца. Отложенную загрузку
можно реализовать перехватом вызовов, но мы считаем, что подобная опти-
мизация редко бывает полезной. Оптимизация на уровне отдельных столб-
цов, выбираемых запросом SQL, не нужна, если только вы не работаете (а)
с большим количеством необязательных столбцов (или столбцов, которые
могут хранить null) или (б) со столбцами, содержащими большие объемы
данных, которые нужно загружать по требованию из-за физических огра-
ничений системы. Вместо этого объемные значения лучше представлять
с помощью объектов логических указателей (LOB); они изначально под-
держивают отложенную загрузку (см. раздел «Двоичные типы и типы для
представления больших значений» в главе 5).
Прокси-объекты обеспечивают отложенную загрузку экземпляров сущностей.
Для хранимых коллекций Hibernate применяет несколько иной подход.
12.1.2. Отложенная загрузка хранимых коллекций
Хранимые коллекции отображаются либо с помощью аннотации @ElementCollection
(коллекции элементов простых или встраиваемых типов), либо с помощью
аннотаций @OneToMany и @ManyToMany (связи между сущностями). К таким коллек-
циям, в отличие от @ManyToOne, отложенная загрузка применяется по умолчанию.
То есть в отображении можно не указывать параметра FetchType.LAZY.
При загрузке товара (Item) Hibernate не станет тут же загружать коллекцию
изображений (images). Коллекция bids (ставки), представляющая отношение один
ко многим, также будет загружена по требованию, когда произойдет обращение
к ней:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
Item item = em.find(Item.class, ITEM_ID);
// select * from ITEM where ID = ?
Set<Bid> bids = item.getBids(); Коллекция не инициализирована
340  Планы извлечения, стратегии и профили
PersistenceUtil persistenceUtil = Persistence.getPersistenceUtil();
assertFalse(persistenceUtil.isLoaded(item, "bids"));
assertTrue(Set.class.isAssignableFrom(bids.getClass())); Это множество Set
assertNotEquals(bids.getClass(), HashSet.class); Это не класс HashSet
assertEquals(bids.getClass(),
org.hibernate.collection.internal.PersistentSet.class);
Операция find() загрузит экземпляр сущности Item в контекст хранения, как
видно на рис. 12.2. Экземпляр Item имеет неинициализированную ссылку seller
на прокси-объект User. Также он имеет ссылку на неинициализированное мно-
жество Set ставок (bids) и неинициализированный список List изображений
images.
Рис. 12.2  Прокси-объекты и обертки коллекций
представляют границы загруженного графа сущностей
Hibernate реализует отложенную загрузку (и проверку состояния объектов)
коллекций с помощью собственного механизма оберток коллекций. Хотя коллек-
ция bids кажется похожей на Set, Hibernate поменял ее реализацию на org.hibernate.
collection.internal.PersistentSet.
Это не HashSet, но имеет схожее поведение. Вот почему в предметной модели
так важно программировать с использованием интерфейсов и полагаться только
на Set, а не на HashSet. Списки и словари работают аналогично.
Эти специальные коллекции могут обнаруживать обращение к ним и загружать
данные в этот момент. Как только вы начнете обход множества bids, сразу же бу-
дет загружена коллекция вместе со ставками:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyProxyCollections.java
Bid firstBid = bids.iterator().next();
// select * from BID where ITEM_ID = ?
// Альтернативный вариант: Hibernate.initialize(bids);
Отложенная и немедленная загрузка  341
Для прокси-классов сущностей существует альтернативный вариант – стати-
ческий вспомогательный метод Hibernate.initialize(), загружающий коллек-
цию. Он загрузит всю коллекцию; вы не сможете, к примеру, загрузить только
две первые ставки. Для реализации подобного поведения придется написать
запрос.
Особенности Hibernate
Чтобы избавить от необходимости писать множество тривиальных запросов, Hibernate
предоставляет свой способ отображения коллекций:
Файл: /model/src/main/java/org/jpwh/model/fetching/proxy/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.LazyCollection(
org.hibernate.annotations.LazyCollectionOption.EXTRA
)
public Set<Bid> getBids() {
return bids;
}
// ...
}
Параметр LazyCollectionOption.EXTRA включает поддежку операций с коллек-
цией, не вызывающих ее инициализацию. Например, можно узнать размер кол-
лекции:
Item item = em.find(Item.class, ITEM_ID);
// select * from ITEM where ID = ?
assertEquals(item.getBids().size(), 3);
// select count(b) from BID b where b.ITEM_ID = ?
Операция size() выполнит SQL-запрос SELECT COUNT(), но не загрузит коллек-
цию bids в память. Для коллекций с дополнительным параметром подобные за-
просы будут выполняться также для операций isEmpty() и contains(). При вызове
метода add() множество Set с дополнительным параметром проверит повторяю-
щиеся элементы с помощью простого запроса. Список List с дополнительным па-
раметром загрузит только один элемент при вызове get(index). Словарь Map полу-
чит дополнительные отложенные операции: containsKey() и containsValue().
Прокси-объекты и умные коллекции в Hibernate являются лишь одной из воз-
можных реализаций отложенной загрузки, имеющих хорошее соотношение между
стоимостью и функциональностью. Альтернативой, о которой упоминалось ранее,
является перехват вызовов.
342  Планы извлечения, стратегии и профили
Особенности Hibernate
12.1.3. Реализация отложенной загрузки путем
перехвата вызовов
Фундаментальная проблема отложенной загрузки состоит в том, что реализация
JPA должна знать, в какой момент загружать поле seller объекта Item или кол-
лекцию bids. Вместо создания прокси-классов во время выполнения и работы
с умными
коллекциями другие реализации JPA полагаются исключительно на пе-
рехват вызовов методов. Например, при вызове someItem.getSeller() реализация
JPA перехватит этот вызов и загрузит экземпляр User, представляющий продавца
товара (поле seller).
Такой подход требует специального кода в классе Item для реализации пере-
хвата: метод getSeller() или поле seller должно быть обернуто. Поскольку мало
у кого возникает желание писать подобный код вручную, как правило, после ком-
пиляции классов предметной модели запускается оптимизатор байт-кода (по-
ставляемый вместе с реализацией JPA). Он вставляет необходимый код перехвата
вызовов в скомпилированные классы, взаимодействуя с полями и методами на
уровне байт-кода.
Давайте обсудим реализацию отложенной загрузки путем перехвата на паре
примеров. Сначала отключим генерацию прокси-классов в Hibernate:
Файл: /model/src/main/java/org/jpwh/model/fetching/interception/User.java
@Entity
@org.hibernate.annotations.Proxy(lazy = false)
public class User {
// ...
}
Hibernate больше не будет генерировать прокси-класс для сущности User. Те-
перь при вызове entityManager.getReference(User.class, USER_ID) будет выполне-
на инструкция SELECT, так же как при вызове find():
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyInterception.java
User user = em.getReference(User.class, USER_ID);
// select * from USERS where ID = ?
assertTrue(Hibernate.isInitialized(user));
Для связей сущностей, направленных к классу User, таких как поле seller клас-
са Item, подсказка FetchType.LAZY не будет работать:
Файл: /model/src/main/java/org/jpwh/model/fetching/interception/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.LAZY) Никакого эффекта – отсутствует прокси-класс User
@org.hibernate.annotations.LazyToOne( Требует внедрения дополнительного байт-кода!
Прокси-классы не используются. getReference()
вернет инициализированный экземпляр
Отложенная и немедленная загрузка  343
org.hibernate.annotations.LazyToOneOption.NO_PROXY
)
protected User seller;
// ...
}
Вместо этого настройка LazyToOneOption.NO_PROXY сообщит Hibernate, что опти-
мизатор байт-кода добавит код перехвата обращений к свойству seller. Если не
использовать этот параметр или не запускать оптимизатора байт-кода, эта связь
будет загружаться и заполняться данными вместе с экземпляром Item, поскольку
создание прокси-объектов для класса User отключено.
Если запустить оптимизатор байт-кода, Hibernate будет перехватывать обраще-
ния к полю seller и вызывать загрузку при обращении к нему:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyInterception.java
Item item = em.find(Item.class, ITEM_ID);
// select * from ITEM where ID = ?
assertEquals(item.getSeller().getId(), USER_ID);
// select * from USERS where ID = ? Даже вызов item.getSeller() повлечет выполнение SELECT
Это поведение отличается от поведения прокси-объектов. Как вы помните, мы
могли вызвать метод User#getId() прокси-объекта без инициализации экземпля-
ра. При использовании перехвата вызовов любое обращение к полю seller и вы-
зов getSeller() повлекут инициализацию.
Для связей сущностей обычно лучше использовать прокси-объекты. Более рас-
пространенный вариант использования перехватчиков – работа со свойствами
простых типов, таких как String или byte[], возможно, имеющих большой объ-
ем. Мы могли бы утверждать, что для больших строк и двоичных данных луч-
ше использовать объекты логических указателей (LOB), как показано в разделе
«Двоичные типы и типы для представления больших значений», но вы, возможно,
не захотите добавлять типов java.sql.Blob или java.sql.Clob в свою предметную
модель. Прием перехвата вызовов позволяет загружать простые поля типа String
или byte[] по требованию:
Файл: /model/src/main/java/org/jpwh/model/fetching/interception/Item.java
@Entity
public class Item {
@Basic(fetch = FetchType.LAZY)
protected String description;
// ...
}
Если обработать скомпилированные классы оптимизатором байт-кода, для поля
Item#description будет использована отложенная загрузка. Если не запускать оп-
тимизатора байт-кода, например во время разработки, свойство типа String будет
загружаться вместе с экземпляром Item.
344  Планы извлечения, стратегии и профили
При использовании перехвата вызовов обратите внимание, что Hibernate загру-
зит все свойства сущности или встраиваемого класса с настроенной отложенной
загрузкой, даже если должно быть загружено только одно:
Файл: /examples/src/test/java/org/jpwh/test/fetching/LazyInterception.java
Item item = em.find(Item.class, ITEM_ID);
// select NAME, AUCTIONEND, ... from ITEM where ID = ?
assertTrue(item.getDescription().length() > 0);
// select DESCRIPTION from ITEM where ID = ?
// select * from USERS where ID = ?
При загрузке описания (description) товара (Item) Hibernate тут же загрузит
продавца (seller) и все остальные поля, доступ к которым перехватывается. На
момент написания книги в Hibernate еще не было групп загрузки: загружалось все
или ничего.
Недостатками перехвата вызовов являются необходимость выполнения опти-
мизатора байт-кода во время каждой сборки классов предметной модели и ожи-
дание завершения его работы. Вы можете не выполнять оптимизацию во время
разработки, если, к примеру, поведение приложения не зависит от состояния за-
грузки описания товара. Затем во время сборки, тестирования и создания готового
программного продукта можно запустить оптимизатор.
Оптимизатор байт-кода в Hibernate 5
К сожалению, мы не можем гарантировать работоспособности приведенных здесь
примеров перехвата вызовов в последней версии Hibernate 5. Оптимизатор байт-
кода Hibernate 5 был переписан и теперь обеспечивает больше, чем просто пере-
хват вызовов для поддержки отложенной загрузки: он может внедрять в классы
предметной модели код, ускоряющий проверку состояния объектов и автоматиче-
ски управляющий двунаправленными связями сущностей. Тем не менее на момент
написания книги мы не смогли заставить этот новый оптимизатор работать, а его
разработка еще продолжалась. За более подробной информацией об оптимиза-
торе и способах его настройки обращайтесь к текущей документации Hibernate
в проекте.
Только вам решать, использовать ли прием перехвата вызовов для поддержки
отложенной загрузки, но, судя по нашему опыту, подходящих вариантов для его
использования довольно мало. Обратите внимание, что при обсуждении перехва-
та вызовов мы не упомянули об обертках коллекций: несмотря на возможность
настроить перехват вызовов для полей, представляющих коллекции, Hibernate
все равно будет использовать собственные умные обертки коллекций. Причина
в том, что эти обертки, в отличие от прокси-объектов, помимо поддержки отло-
женной загрузки, нужны также для других целей. Например, Hibernate исполь-
Обращение к одному свойству загрузит
все остальные (описание, продавец и пр.)
Отложенная и немедленная загрузка  345
зует их для обнаружения добавления и удаления элементов коллекций во вре-
мя проверки состояния объектов. Вы не сможете отключить обертки коллекций
в отображениях – они используются всегда (конечно, вы не обязаны отображать
хранимых коллекций; это лишь дополнительная функциональность, а не требова-
ние. См. предыдущее обсуждение в разделе 7.1). С другой стороны, для хранимых
массивов отложенная загрузка может применяться только путем перехвата вызо-
вов – их нельзя обернуть так же, как коллекции.
Вот вы и познакомились со всеми доступными способами организации отло-
женной загрузки в Hibernate. Далее мы посмотрим на противоположную сторо-
ну – немедленную загрузку данных.
12.1.4. Немедленная загрузка коллекций и ассоциаций
Мы рекомендуем применять по умолчанию план отложенного извлечения, зада-
ваемый параметром FetchType.LAZY, ко всем отображениям связей и коллекций.
Но иногда, хоть и нечасто, может понадобиться обратное: указать, что конкретная
связь или коллекция должна загружаться всегда, чтобы гарантировать наличие
данных в памяти без дополнительного обращения к базе данных.
Но еще более важной может оказаться доступность свойства seller объекта
Item, даже когда объект Item находится в отсоединенном состоянии. После за-
крытия контекста хранения отложенная загрузка становится недоступной. Если
seller указывает на неинициализированный прокси-объект, при попытке обра-
титься к нему в отсоединенном состоянии вы получите LazyInitializationException.
Чтобы данные были доступны в отсоединенном состоянии, нужно пред-
варительно загрузить их вручную, пока контекст открыт, или поменять план
извлечения c отложенного на немедленный, если требуется, чтобы они загружа-
лись всегда.
Предположим, что нам требуется всегда загружать свойства seller и bids объ-
екта Item:
Файл: /model/src/main/java/org/jpwh/model/fetching/eagerjoin/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.EAGER) Значение по умолчанию
protected User seller;
@OneToMany(mappedBy = "item", fetch = FetchType.EAGER) Не рекоммендуется
protected Set<Bid> bids = new HashSet<>();
// ...
}
В отличие от параметра FetchType.LAZY, являющегося лишь рекомендацией, ко-
торую реализация JPA может игнорировать, параметр FetchType.EAGER – это требо-
вание. Реализация должна обеспечить загрузку данных и их доступность в отсо-
единенном состоянии; она не может игнорировать эту настройку.
346  Планы извлечения, стратегии и профили
Рассмотрим отображение коллекции: насколько оправдано решение загружать
все ставки за товар в память при загрузке самого товара? Даже если потребуется
только отобразить название товара или узнать, когда заканчивается аукцион, все
ставки все равно будут загружаться в память. Немедленная загрузка всех коллек-
ций путем применения параметра FetchType.EAGER в качестве плана извлечения по
умолчанию в отображениях – не самая лучшая стратегия. Используя немедлен-
ную загрузку для нескольких коллекций, вы неизбежно столкнетесь с проблемой
декартова произведения, которую мы обсудим далее в этой главе. Лучше всего
оставить для коллекций значение по умолчанию FetchType.LAZY.
Теперь при вызове find() для поиска экземпляра Item (или при вынужденной
инициализации прокси-объекта Item) свойства seller (продавец) и bids (ставки)
будут загружены в контекст хранения в виде хранимых экземпляров:
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerJoin.java
Item item = em.find(Item.class, ITEM_ID);
// select i.*, u.*, b.*
// from ITEM i
// left outer join USERS u on u.ID = i.SELLER_ID
// left outer join BID b on b.ITEM_ID = i.ID
// where i.ID = ?
em.detach(item); Извлечение окончено; отложенная загрузка больше не работает
assertEquals(item.getBids().size(), 3); В отсоединенном состоянии доступны предложения цены...
assertNotNull(item.getBids().iterator().next().getAmount());
assertEquals(item.getSeller().getUsername(), "johndoe"); ...и продавец
Для загрузки данных при вызове find() Hibernate выполнит единственное SQL-
выражение SELECT с предложением JOIN, включающим три таблицы. Cодержимое
контекста хранения для этого случая показано на рис. 12.3. Обратите внимание,
как представлены границы загруженного графа объектов: коллекция images не
была загружена, а каждый экземпляр Bid ссылается на неинициализированный
прокси-объект User с помощью поля bidder. Если сейчас отсоединить экземпляр
Item, сохранится возможность обращаться к загруженным полям seller и bids, не
вызывая исключения LazyInitializationException. Но если попытаться обратить-
ся к полю images или одному из прокси-объектов через поле bidder, будет возбуж-
дено исключение!
В следующих примерах предполагается, что в предметной модели по умолча-
нию используется план отложенного извлечения. Hibernate будет загружать толь-
ко те данные, которые запрашиваются явно, и только те связи и коллекции, к ко-
торым происходят обращения.
Далее мы обсудим, как данные должны загружаться при поиске экземпляра
сущности по идентификатору и при обходе графа объектов с помощью указателей
на отображаемые связи и коллекции. Нас интересует не только выполняемый код
SQL, но и поиск идеальной стратегии извлечения.
Выбор стратегии извлечения  347
Рис. 12.3  Загружены продавец и ставки для товара (Item)
12.2. Выбор стратегии извлечения
Для загрузки данных в пямять Hibernate выполняет SQL-выражения SELECT. При
этом в зависимости от числа участвующих таблиц и выбранной стратегии из-
влечения могут выполняться одно или несколько выражений SELECT. Наша цель –
уменьшить число SQL-выражений и упростить их, чтобы запросы выполнялись
как можно быстрее.
Рассмотрим план извлечения, рекомендованный нами выше в этой главе: каж-
дая связь и коллекция должна загружаться по требованию. Такой план почти на-
верняка повлечет за собой слишком большое количество SQL-запросов, каждый
из которых будет загружать лишь небольшой объем данных. Этот план ведет
к проблеме n + 1 выражений SELECT, поэтому сначала обсудим эту проблему. Аль-
тернативный план извлечения, использующий немедленную загрузку, потребует
меньше SQL-запросов, поскольку каждый запрос будет загружать в память боль-
ше данных. С увеличением объемов данных, загружаемых запросами, вы можете
столкнуться с проблемой декартова произведения.
Вам придется найти золотую середину между этими двумя крайностями –
идеальную
стратегию извлечения для каждой процедуры и каждого сценария ис-
пользования в вашем приложении. Так же как для планов извлечения, глобальную
стратегию извлечения можно задать для отображений: определить настройки по
умолчанию, действующие всегда. Затем можете переопределить стратегию извле-
чения по умолчанию для конкретной процедуры, используя произвольные запро-
сы JPQL, CriteriaQuery или даже SQL.
Для начала обсудим фундаментальные проблемы, с которыми можно столкнуться,
начав с проблемы n + 1 выражений SELECT.
12.2.1. Проблема n + 1 выражений SELECT
Эту проблему проще продемонстрировать на примере. Предположим, что вы ис-
пользуете план отложенного извлечения в отображении, и все данные загружают-
348  Планы извлечения, стратегии и профили
ся только по мере необходимости. Следующий пример проверяет, задано ли имя
пользователя (username) у каждого продавца (seller) товара (Item):
Файл: /examples/src/test/java/org/jpwh/test/fetching/NPlusOneSelects.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM
for (Item item : items) {
assertNotNull(item.getSeller().getUsername());
// select * from USERS where ID = ?
}
Как видите, одно SQL-выражение SELECT загружает экземпляры сущностей Item.
Затем, во время обхода всех товаров (items), для получения каждого экземпляра
User требуется выполнить дополнительные инструкции SELECT. Это тождественно
одному запросу для экземпляра Item и n дополнительным запросам в зависимости
от количества товаров, а также от того, продает ли конкретный пользователь (User)
более одного товара (Item). Это явно не самая эффективная стратегия, если зара-
нее известно, что придется обращаться к полю seller каждого экземпляра Item.
С той же проблемой можно столкнуться, применив отложенную загрузку для
коллекций. Следующий пример проверяет количество ставок (bids) для каждого
товара (Item):
Файл: /examples/src/test/java/org/jpwh/test/fetching/NPlusOneSelects.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM
for (Item item : items) {
assertTrue(item.getBids().size() > 0); Для загрузки каждой коллекции bids требуется
// select * from BID where ITEM_ID = ? выполнить дополнительный запрос SELECT
}
Если заранее известно, что придется обращаться ко всем коллекциям bids, за-
грузка каждой из них по отдельности снова оказывается неэффективной. Если
у вас имеется 100 товаров, выполнится 101 запрос SQL!
С теми знаниями, которыми вы уже владеете, вам, возможно, захочется поме-
нять план извлечения по умолчанию в своих отображениях и указать параметр
FetchType.EAGER для связей seller или bids. Но, поступив так, вы столкнетесь
с проблемой декартова произведения.
12.2.2. Проблема декартова произведения
Исследовав предметную модель и модель данных и обнаружив, что каждый раз
при загрузке экземпляра Item также требуется загружать его свойство seller, вы
можете решить отобразить связь с параметром FetchType.EAGER. Если вам нужна
гарантия, что при этом с каждым экземпляром Item будет загружаться его свой-
ство seller, нужно обеспечить доступность этих данных в отсоединенном состоя-
нии экземпляра Item и при закрытом контексте хранения:
Каждый продавец будет загружен
дополнительной инструкцией SELECT
Выбор стратегии извлечения  349
Файл: /model/src/main/java/org/jpwh/model/fetching/cartesianproduct/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.EAGER)
protected User seller;
// ...
}
Для реализации немедленного извлечения Hibernate использует SQL-предложение
JOIN, чтобы загрузить экземпляры Item и User в одном запросе SELECT:
item = em.find(Item.class, ITEM_ID);
// select i.*, u.*
// from ITEM i
// left outer join USERS u on u.ID = i.SELLER_ID
// where i.ID = ?
Результат запроса будет содержать одну запись с данными из таблицы ITEM, объ-
единенную с данными из таблицы USERS, как показано на рис. 12.4.
i.NAME
One
i.SELLER_ID
...
i.ID
1
u.ID
2
u.USERNAME
johndoe
... ...
2 ...
Рис. 12.4  Hibernate соединяет две таблицы,
чтобы обеспечить немедленную загрузку связанных записей
Немедленное извлечение, по умолчанию использующее стратегию JOIN, не
вызовет проблем для связей @ManyToOne и @OneToOne. В одном запросе SQL с не-
сколькими предложениями JOIN можно одновременно загрузить товар (Item), его
продавца (seller), адрес (Address) пользователя (User), его город (City) и т. д.
Даже при отображении этих связей с параметром FetchType.EAGER запрос вернет
только одну запись. Но в какой-то момент Hibernate должен перестать следо-
вать плану FetchType.EAGER. Количество соединяемых таблиц зависит от гло-
бального параметра конфигурации hibernate.max_fetch_depth. По умолчанию
никаких ограничений не задано. Приемлемыми являются значения от 1 до 5. Вы
даже можете отключить извлечение связей @ManyToOne и @OneToOne с использова-
нием JOIN, установив значение 0. При достижении лимита Hibernate будет по-
прежнему немедленно загружать данные в соответствии с планом извлечения,
но используя дополнительные выражения SELECT (обратите внимание, что этот
параметр можно задать в некоторых диалектах баз данных: например, в диалекте
MySQL он равен 2).
Немедленная загрузка коллекций с помощью JOIN, с другой стороны, может
привести к серьезному падению производительности. Если стратегию FetchType.
EAGER применить также к коллекциям bids и images, возникнет проблема декартова
произведения.
350  Планы извлечения, стратегии и профили
Эта проблема появляется, когда одним запросом SQL с предложением JOIN
одновременно загружаются две коллекции. Давайте создадим такой план извле-
чения, а затем исследуем проблему:
Файл: /model/src/main/java/org/jpwh/model/fetching/cartesianproduct/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item", fetch = FetchType.EAGER)
protected Set<Bid> bids = new HashSet<>();
@ElementCollection(fetch = FetchType.EAGER)
@CollectionTable(name = "IMAGE")
@Column(name = "FILENAME")
protected Set<String> images = new HashSet<String>();
// ...
}
Не имеет значения, отмечены ли обе коллекции аннотациями @OneToMany, @ManyToMany
или @ElementCollection. Независимо от содержимого коллекции, немед-
ленная загрузка более чем одной коллекции с применением SQL-предложения
JOIN является фундаментальной проблемой. При загрузке экземпляра Item Hibernate
выполнит проблемное выражение SQL:
Файл: /examples/src/test/java/org/jpwh/test/fetching/CartesianProduct.java
Item item = em.find(Item.class, ITEM_ID);
// select i.*, b.*, img.*
// from ITEM i
// left outer join BID b on b.ITEM_ID = i.ID
// left outer join IMAGE img on img.ITEM_ID = i.ID
// where i.ID = ?
em.detach(item);
assertEquals(item.getImages().size(), 3);
assertEquals(item.getBids().size(), 3);
Как видите, Hibernate последовал нашему плану извлечения, и теперь есть
возможность обращаться к коллекциям bids и images в отсоединенном состоя-
нии. Проблема лишь в том, как эти коллекции загружаются – с помощью SQL-
операции JOIN, результатом которой является прямое произведение. Рассмотрим
результат запроса на рис. 12.5.
Он содержит много лишних данных, тогда как фреймворку необходимы лишь
выделенные ячейки. Экземпляр Item имеет три ставки и три изображения. Мощ-
ность произведения зависит от размеров извлекаемых коллекций: трижды три
равняется девяти итоговым записям. Представьте теперь, что имеется экземпляр
Item с 50 ставкам (bids) и 5 изображениями (images); в этом случае запрос вернет
250 записей! При создании собственных запросов JPQL или CriteriaQuery можно
Выбор стратегии извлечения  351
получить еще более впечатляющие результаты: представьте, что произойдет при
извлечении 500 товаров и немедленной загрузке с помощью JOIN десятков ставок
и изображений.
i.NAME
One
... b.ID
...
i.ID
1
b.AMOUNT
1 99.00
img.FILENAME
foo.jpg
1 One ... 1 99.00 bar.jpg
1 One ... 1 99.00 baz.jpg
1 One ... 2 100.00 foo.jpg
1 One ... 2 100.00 bar.jpg
1 One ... 2 100.00 baz.jp
1 One ... 3 101.00 foo.jpg
1 One ... 3 101.00 bar.jpg
1 One ... 3 101.00 baz.jpg
Рис. 12.5  Результатом двух соединений нескольких строк
является прямое произведение
Для создания таких результатов серверу базы данных потребуется значитель-
ный объем памяти и процессорного времени. Если вы надеетесь, что драйвер JDBC
каким-то образом выполнит сжатие данных, вы, вероятно, ожидаете от создателей
базы данных слишком многого. Преобразуя результаты запроса в хранимые эк-
земпляры и коллекции, Hibernate сразу избавится от всех дубликатов; информа-
ция в невыделенных ячейках на рис. 12.5 будет проигнорирована. Очевидно, вы
не сможете удалить эти дубликаты на уровне SQL – оператор DISTINCT здесь не
поможет.
Можно было бы одновременно извлечь экземпляр сущности и две коллекции
быстрее, если вместо одного запроса SQL с огромным результатом выполнить три
отдельных запроса. Далее мы рассмотрим этот тип оптимизации, а также способы
поиска и реализации лучшей стратегии извлечения. Мы заново рассмотрим план
отложенного извлечения по умолчанию и попробуем решить проблему n + 1 вы-
ражений SELECT.
12.2.3. Массовая предварительная выборка данных
Если Hibernate будет извлекать все связи сущностей и коллекции по требованию,
для выполнения конкретной процедуры может понадобиться множество допол-
нительных SQL-выражений SELECT. Как и прежде, рассмотрим код, проверяющий
наличие имени пользователя (username) у поставщика (seller) каждого товара
(Item). При использовании отложенной загрузки это потребует одной инструк-
ции SELECT, чтобы получить все экземпляры Item, и еще n инструкций SELECT для
инициализации прокси-объекта seller каждого экземпляра Item.
352  Планы извлечения, стратегии и профили
Hibernate реализует несколько алгоритмов, способных производить предвари-
тельную выборку данных. Первый алгоритм, который мы обсудим, – массовое из-
влечение (batch fetching), он работает следующим образом: если Hibernate должен
инициализировать один прокси-объект User, тогда в этой же инструкции SELECT он
инициализирует еще несколько. Другими словами, если известно, что в контексте
хранения находится несколько экземпляров Item и в каждом связь seller ссыла-
ется на прокси-объект, тогда при обращении к базе данных можно инициализиро-
вать сразу несколько прокси-объектов.
Посмотрим, как это работает. Во-первых, нужно включить массовое извлечение
экземпляров User с помощью аннотации:
Файл: /model/src/main/java/org/jpwh/model/fetching/batch/User.java
@Entity
@org.hibernate.annotations.BatchSize(size = 10)
@Table(name = "USERS")
public class User {
// ...
}
Эта настройка сообщает Hibernate, что при загрузке одного прокси-объекта
User он может в одной инструкции SELECT загрузить до 10 прокси-объектов. Мас-
совое извлечение обычно называют оптимизацией вслепую, поскольку неизвестно,
как много неинициализированных прокси-объектов User может находиться в кон-
кретном контексте хранения. Нельзя с уверенностью утверждать, что 10 – это
идеальное значение, – это лишь предположение. Зато вы знаете, что вместо n + 1
запросов SQL будет выполнено n + 1/10 запросов, что является существенным
улучшением. Приемлемые значения обычно невелики, поскольку редко бывает
желательно загружать в память слишком много данных, особенно если нет уве-
ренности, что они понадобятся.
Следующая оптимизированная процедура проверяет имя пользователя (username)
каждого продавца (seller):
Файл: /examples/src/test/java/org/jpwh/test/fetching/Batch.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM
for (Item item : items) {
assertNotNull(item.getSeller().getUsername());
// select * from USERS where ID in (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
}
Обратите внимание на запрос SQL, который будет выполнен перед началом
обхода коллекции items. В первом вызове item.getSeller().getUserName() Hibernate
должен инициализировать первый прокси-объект User. Вместо загрузки од-
ной записи из таблицы USERS Hibernate извлечет несколько записей и загрузит до
10 экземпляров User. Как только вы обратитесь к одиннадцатому полю seller, тут
Выбор стратегии извлечения  353
же будет загружено еще 10 экземпляров; так будет продолжаться до тех пор, пока
в контексте хранения не останется неинициализированных прокси-объектов User.
ЧАСТО ЗАДАВАЕМЫЕ ВОПРОСЫ:
Как на самом деле работает алгоритм массового извлечения?
Мы несколько упростили описание алгоритма массовой загрузки. На практике он
действует немного иначе. В качестве примера рассмотрим ситуацию, когда пакет
имеет размер 32. При запуске Hibernate неявно создаст несколько массовых за-
грузчиков. Каждый загрузчик знает, сколько прокси-объектов он может инициали-
зировать: 32, 16, 10, 9, 8, 7, …, 1. Цель состоит в том, чтобы минимизировать по-
требление памяти для создания загрузчиков и создать достаточное их количество,
чтобы можно было выполнить массовую загрузку с любым размером пакета. Оче-
видно, другая цель состоит в минимизации количества запросов SQL.
Для инициализации 31 прокси-объекта Hibernate загрузит 3 набора (возможно, вы
ожидали 1, поскольку 32 > 31). Hibernate автоматически выберет загрузчики с разме-
рами наборов 16, 10 и 5. Вы можете настроить работу алгоритма массового извлече-
ния с помощью параметра hibernate.batch_fetch_style в конфигурации единицы хра-
нения. Значением по умолчанию является LEGACY, что приводит к созданию и выбору
нескольких загрузчиков во время запуска. Другими вариантами являются PADDED и DYNAMIC.
При использовании параметра PADDED Hibernate создаст только один запрос SQL
для массового загрузчика с 32 свободными аргументами в предложении IN, и если
нужно будет загрузить меньше 32 прокси-объектов, некоторые значения идентифи-
каторов будут повторяться. При использовании параметра DYNAMIC Hibernate дина-
мически сформирует SQL-выражение для массовой загрузки во время выполнения,
когда ему будет известно количество прокси-объектов для инициализации.
Массовое извлечение также доступно для коллекций:
Файл: /model/src/main/java/org/jpwh/model/fetching/batch/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.BatchSize(size = 5)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Теперь при инициализации одной коллекции bids будет загружено до пяти до-
полнительных коллекций Item#bids, если они еще не инициализированы в теку-
щем контексте хранения.
Файл: /examples/src/test/java/org/jpwh/test/fetching/Batch.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM
for (Item item : items) {
354  Планы извлечения, стратегии и профили
assertTrue(item.getBids().size() > 0);
// select * from BID where ITEM_ID in (?, ?, ?, ?, ?)
}
При первом вызове item.getBids().size() во время обхода будет предваритель-
но загружен целый набор коллекций объектов Bid для других экземпляров Item.
Массовое извлечение – это простая и, как правило, разумная оптимизация, спо-
собная значительно сократить количество выражений SQL, которые в противном
случае понадобилось бы выполнить для инициализации прокси-объектов и кол-
лекций. При этом есть риск загрузить данные, которые затем не понадобятся, и по-
тратить больше памяти, однако уменьшение количества обращений к базе данных
может оказать существенное влияние. Память обходится дешево, а масштабирова-
ние серверов баз данных – нет.
Другой алгоритм предварительного извлечения, который не является оптимиза-
цией вслепую, использует подзапросы для инициализации нескольких коллекций.
Особенности Hibernate
12.2.4. Предварительное извлечение коллекций
с помощью подзапросов
Возможно, более эффективной стратегией загрузки всех коллекций bids для не-
скольких экземпляров Item является предварительное извлечение с помощью
подзапросов. Для применения этой оптимизации отметьте коллекцию аннотацией
Hibernate:
Файл: /model/src/main/java/org/jpwh/model/fetching/subselect/Item.java
@Entity
public class Item {
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.Fetch(
org.hibernate.annotations.FetchMode.SUBSELECT
)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Теперь, как только вы инициализируете одну из коллекций bids, Hibernate ини-
циализирует все коллекции bids для всех загруженных экземпляров Item.
Файл: /examples/src/test/java/org/jpwh/test/fetching/Subselect.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM
for (Item item : items) {
assertTrue(item.getBids().size() > 0);
// select * from BID where ITEM_ID in (
Выбор стратегии извлечения  355
// select ID from ITEM
// )
}
Hibernate запомнит первоначальный запрос, использовавшийся для загрузки
коллекции items. Затем встроит этот запрос (немного измененный) внутрь подза-
проса, чтобы извлечь коллекцию bids для каждого экземпляра Item.
Предварительное извлечение с применением подзапросов является мощной
оптимизацией, но на момент написания этих строк она была доступна только для
коллекций с планом отложенной загрузки, но не для прокси-объектов сущностей.
Также обратите внимание, что Hibernate запомнит первоначальный запрос, ис-
пользуемый затем в подзапросе, только в рамках конкретного контекста хране-
ния. Если отсоединить экземпляр Item, не инициализировав коллекцию bids, а за-
тем выполнить слияние с новым контекстом хранения и начать обход коллекции,
предварительного извлечения остальных коллекций не произойдет.
При следовании глобальному плану отложенного извлечения предварительное
извлечение с помощью подзапросов и массовое извлечение сокращают количество
запросов, помогая справиться с проблемой n + 1 запросов SELECT. Если вместо
этого для связей и коллекций использовать глобальный план отложенного извле-
чения, вам придется решать проблему декартова произведения, разбивая запрос
с несколькими предложениями JOIN на несколько выражений SELECT.
Особенности Hibernate
12.2.5. Отложенное извлечение
с несколькими выражениями SELECT
При попытке извлечь несколько коллекций в одном запросе SQL с несколькими
предложениями JOIN вы столкнетесь с проблемой декартова произведения, как
было показано выше. Однако есть возможность попросить Hibernate не использо-
вать операцию JOIN, а загружать данные с помощью дополнительных инструкций
SELECT, чтобы избежать слишком объемных результатов запросов и прямых произ-
ведений SQL с дубликатами:
Файл: /model/src/main/java/org/jpwh/model/fetching/eagerselect/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.EAGER)
@org.hibernate.annotations.Fetch(
org.hibernate.annotations.FetchMode.SELECT
)
protected User seller;
@OneToMany(mappedBy = "item", fetch = FetchType.EAGER)
@org.hibernate.annotations.Fetch(
org.hibernate.annotations.FetchMode.SELECT
По умолчанию JOIN
356  Планы извлечения, стратегии и профили
)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Теперь вместе с экземпляром Item будут загружены поля seller и bids:
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerSelect.java
Item item = em.find(Item.class, ITEM_ID);
// select * from ITEM where ID = ?
// select * from USERS where ID = ?
// select * from BID where ITEM_ID = ?
em.detach(item);
assertEquals(item.getBids().size(), 3);
assertNotNull(item.getBids().iterator().next().getAmount());
assertEquals(item.getSeller().getUsername(), "johndoe");
Чтобы загрузить запись из таблицы ITEM, Hibernate выполнит одну инструк-
цию SELECT. Затем он сразу же выполнит еще две инструкции SELECT: одна загрузит
записьиз
таблицы USERS (поле seller), а вторая – несколько записей из таблицы
BID (коллекция bids).
Дополнительные выражения SELECT выполняются сразу же; метод find() выпол-
нит несколько запросов SQL. Видно, что Hibernate следует плану немедленного
извлечения – все данные будут доступны в отсоединенном состоянии.
Все эти настройки действуют глобально – они работают всегда. Опасность за-
ключается в том, что изменение одной настройки для конкретной проблемной си-
туации в вашем приложении может оказать негативное влияние на другие проце-
дуры. Поддерживать баланс непросто, поэтому мы советуем отображать все связи
сущности с параметром FetchType.LAZY, как было показано ранее.
Гораздо практичнее применять немедленное извлечение и операции JOIN дина-
мически, отдельно для конкретной процедуры.
12.2.6. Динамическое немедленное извлечение
Так же, как в предыдущих разделах, представим, что нужно проверить свойство
username в каждом объекте Item#seller. Используя глобальный план отложенного
извлечения, можно загрузить данные, необходимые для этой процедуры, а затем
динамически применить стратегию немедленного извлечения:
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerQuery.java
List<Item> items =
em.createQuery("select i from Item i join fetch i.seller")
.getResultList();
Выбор стратегии извлечения  357
// select i.*, u.*
// from ITEM i
// inner join USERS u on u.ID = i.SELLER_ID
// where i.ID = ?
em.close(); Отсоединить все
for (Item item : items) {
assertNotNull(item.getSeller().getUsername());
}
Самые важные ключевые слова в этом запросе JPQL – join fetch – требуют от
Hibernate применить SQL-операцию JOIN (фактически INNER JOIN) для получения
свойства seller каждого экземпляра Item в том же запросе. Тот же самый запрос
можно выразить с помощью CriteriaQuery API:
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerQuery.java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery();
Root<Item> i = criteria.from(Item.class);
i.fetch("seller");
criteria.select(i);
List<Item> items = em.createQuery(criteria).getResultList();
em.close(); Отсоединить все
for (Item item : items) {
assertNotNull(item.getSeller().getUsername());
}
Динамическое немедленное извлечение с соединениями также можно приме-
нять к коллекциям. Следующий код загружает все объекты из коллекций bids всех
экземпляров Item:
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerQuery.java
List<Item> items =
em.createQuery("select i from Item i left join fetch i.bids")
.getResultList();
// select i.*, b.*
// from ITEM i
// left outer join BID b on b.ITEM_ID = i.ID
// where i.ID = ?
em.close(); Отсоединить все
for (Item item : items) {
assertTrue(item.getBids().size() > 0);
}
Теперь то же самое, но с CriteriaQuery API:
358  Планы извлечения, стратегии и профили
Файл: /examples/src/test/java/org/jpwh/test/fetching/EagerQuery.java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery();
Root<Item> i = criteria.from(Item.class);
i.fetch("bids", JoinType.LEFT);
criteria.select(i);
List<Item> items = em.createQuery(criteria).getResultList();
em.close(); Отсоединить все
for (Item item : items) {
assertTrue(item.getBids().size() > 0);
}
Обратите внимание, что для извлечения коллекций требуется выражение LEFT
OUTER JOIN, поскольку вам также понадобятся записи из таблицы ITEM, даже если не
найдется соответствующей коллекции bids. Мы еще многое расскажем про извле-
чение данных с помощью JPQL и CriteriaQuery далее, в главе 15. Там вы увидите
много примеров внутренних, внешних, левых и правых соединений, так что не бес-
покойтесь пока об этих особенностях.
Для динамического переопределения глобального плана извлечения в предмет-
ной модели необязательно писать запросы вручную. Также можно использовать
декларативный подход, определяя профили извлечения.
12.3. Профили извлечения
Профили извлечения дополняют параметры извлечения в языке запросов и раз-
личных API. Они позволяют управлять определениями профилей с помощью
XML и метаданных в аннотациях. Ранние версии Hibernate не поддерживали спе-
циальных профилей извлечения, но сегодня Hibernate поддерживает следующие
возможности.
 Профили извлечения – нестандартный API, основанный на декларативном
определении профилей с помощью аннотации @org.hibernate.annotations.
FetchProfile и метода Session#enableFetchProfile(). На текущий момент этот
простой механизм поддерживает выборочное переопределение отображае-
мых ассоциаций сущностей с отложенной загрузкой, активируя стратегию
немедленного извлечения с применением JOIN в конкретной единице работы.
 Графы сущностей – как определено в JPA 2.1, граф сущностей и связей мож-
но определить с помощью аннотации @EntityGraph. Этот план извлечения
(или комбинация планов) может активироваться с помощью подсказки
при вызове EntityManager#find() или выполнении запросов (JPQL, запросов
с критериями). Данный граф определяет, что должно быть загружено; к со-
жалению, он не определяет, как.
Справедливости ради следует сказать, что здесь есть что улучшить, и мы ожи-
даем от будущих версий Hibernate и JPA более единообразного и мощного API.
Профили извлечения  359
Не забывайте, что выражения JPQL и SQL можно выносить во внешние файлы ме-
таданных (см. раздел 14.4). Запрос JPQL является декларативным (именованным)
профилем извлечения; чего ему не хватает, так это возможности легко накладывать
различные планы на один базовый запрос. Мы сталкивались с довольно интерес-
ными решениями, основанными на манипуляции строками, но их лучше избегать.
С другой стороны, используя запросы с критериями, вы получаете всю доступную
мощь Java для организации кода построения запросов. Кроме того, графы сущностей
позволяют повторно применять план извлечения к любому типу запроса.
Давайте сначала обсудим профили извлечения Hibernate и способы переопре-
деления глобального плана отложенного извлечения для конкретной единицы
работы.
Особенности Hibernate
12.3.1. Определение профилей извлечения Hibernate
Профили извлечения Hibernate – это глобальные метаданные, которые опреде-
ляются для целой единицы хранения. Можно, конечно, поместить аннотацию
@FetchProfile
перед классом, но мы предпочитаем метаданные уровня пакета в фай-
ле package-info.java:
Файл: /model/src/main/java/org/jpwh/model/fetching/profile/package-info.java
@org.hibernate.annotations.FetchProfiles({
@FetchProfile(name = Item.PROFILE_JOIN_SELLER,  Название профиля
fetchOverrides = @FetchProfile.FetchOverride(  Переопределение
entity = Item.class,
association = "seller",
mode = FetchMode.JOIN  Режим JOIN
)),
@FetchProfile(name = Item.PROFILE_JOIN_BIDS,
fetchOverrides = @FetchProfile.FetchOverride(
entity = Item.class,
association = "bids",
mode = FetchMode.JOIN
))
})
 Каждый профиль имеет имя. Это просто строка, представленная константой.
 Каждое переопределение в профиле указывает на одну связь или коллекцию.
 На момент написания этих строк был доступен только режим JOIN.
Теперь профили можно подключать к конкретной единице работы:
Файл: /examples/src/test/java/org/jpwh/test/fetching/Profile.java
Item item = em.find(Item.class, ITEM_ID);  Извлечение экземпляра
em.clear();
360  Планы извлечения, стратегии и профили
em.unwrap(Session.class).enableFetchProfile(Item.PROFILE_JOIN_SELLER);
item = em.find(Item.class, ITEM_ID);
em.clear();
em.unwrap(Session.class).enableFetchProfile(Item.PROFILE_JOIN_BIDS);
item = em.find(Item.class, ITEM_ID);
 Для поля Item#seller задано отложенное отображение, поэтому с планом извлечения по
умолчанию будет получен только экземпляр сущности Item.
 Для подключения профиля нужен Hibernate API. После этого он будет использоваться
для любой операции в рамках этой единицы работы. Поле Item#seller загружается при
помощи соединения в том же запросе SQL, всякий раз, когда экземпляр Item загружается
этим экземпляром EntityManager.
 На ту же единицу работы можно наложить другой профиль. Теперь при загрузке каж-
дого экземпляра Item поле Item#seller и коллекция Item#bids будут загружены в одном
запросе SQL с соединением.
Несмотря на простоту, профили извлечения Hibernate могут оказаться дей-
ственным решением проблем оптимизации извлечения в небольших или простых
приложениях. С появлением JPA 2.1 и графов сущностей похожая функциональ-
ность появилась в стандартизованном виде.
12.3.2. Графы сущностей
Граф сущностей – это объявление экземпляров и атрибутов, переопределяющее
или улучшающее план извлечения по умолчанию при вызове EntityManager#find()
или с помощью подсказки в операциях с запросами. Следующий пример демон-
стрирует извлечение с использованием графа сущностей:
Файл: /examples/src/test/java/org/jpwh/test/fetching/FetchLoadGraph.java
Map<String, Object> properties = new HashMap<>();
properties.put(
"javax.persistence.loadgraph",
em.getEntityGraph(Item.class.getSimpleName()) Строка «Item»
);
Item item = em.find(Item.class, ITEM_ID, properties);
// select * from ITEM where ID = ?
Используемый граф сущностей имеет имя Item, а подсказка для операции find()
указывает, что это еще и граф загрузки. Это означает, что все атрибуты, указанные
как вершины графа сущностей, будут загружаться с параметром FetchType.EAGER,
а те, что не указаны, будут загружаться соответственно их параметрам или типу
FetchType, заданному в отображении по умолчанию.
Ниже представлено определение этого графа, а также плана извлечения класса
сущности по умолчанию:
 Подключает профиль
 Накладывается на второй профиль
Профили извлечения  361
Файл: /model/src/main/java/org/jpwh/model/fetching/fetchloadgraph/Item.java
@NamedEntityGraphs({
@NamedEntityGraph По умолчанию используется граф сущностей «Item»
})
@Entity
public class Item {
@NotNull
@ManyToOne(fetch = FetchType.LAZY)
protected User seller;
@OneToMany(mappedBy = "item")
protected Set<Bid> bids = new HashSet<>();
@ElementCollection
protected Set<String> images = new HashSet<>();
// ...
}
В метаданных графы сущностей имеют названия и связаны с классами сущно-
стей; обычно они объявляются с помощью аннотаций перед классами сущностей.
При желании объявление можно поместить в файл XML. Если явно не указать имя
графа, он получит простое имя класса сущности-владельца: в данном случае это Item.
Если не перечислить вершины графа с указанием атрибутов, как в случае с пустым
графом сущностей из предыдущего примера, по умолчанию будут использоваться
параметры класса сущности. В классе Item все связи и коллекции отображаются как
отложенные; это план извлечения по умолчанию. То есть все, что мы сделали, не
даст никакого результата, и операция find() безо всяких подсказок даст такой же
результат: загрузит только экземпляр Item, но не поля seller, bids и images.
Другим вариантом является построение графа сущностей с помощью API:
Файл: /examples/src/test/java/org/jpwh/test/fetching/FetchLoadGraph.java
EntityGraph<Item> itemGraph = em.createEntityGraph(Item.class);
Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.loadgraph", itemGraph);
Item item = em.find(Item.class, ITEM_ID, properties);
Это снова пустой граф сущностей без вершин с атрибутами, передаваемый пря-
мо в операцию извлечения.
Предположим, что требуется создать граф сущностей, который меняет отло-
женное извлечение по умолчанию для поля Item#seller на немедленное:
Файл: /model/src/main/java/org\jpwh/model/fetching/fetchloadgraph/Item.java
@NamedEntityGraphs({
@NamedEntityGraph(
name = "ItemSeller",
attributeNodes = {
362  Планы извлечения, стратегии и профили
@NamedAttributeNode("seller")
}
)
})
@Entity
public class Item {
// ...
}
Теперь этот граф можно использовать, когда потребуется немедленная загрузка
экземпляра Item и поля seller:
Файл: /examples/src/test/java/org/jpwh/test/fetching/FetchLoadGraph.java
Map<String, Object> properties = new HashMap<>();
properties.put(
"javax.persistence.loadgraph",
em.getEntityGraph("ItemSeller")
);
Item item = em.find(Item.class, ITEM_ID, properties);
// select i.*, u.*
// from ITEM i
// inner join USERS u on u.ID = i.SELLER_ID
// where i.ID = ?
Если нежелательно жестко определять граф с помощью аннотаций, его можно
создать, используя API:
EntityGraph<Item> itemGraph = em.createEntityGraph(Item.class);
itemGraph.addAttributeNodes(Item_.seller); Статическая метамодель
Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.loadgraph", itemGraph);
Item item = em.find(Item.class, ITEM_ID, properties);
// select i.*, u.*
// from ITEM i
// inner join USERS u on u.ID = i.SELLER_ID
// where i.ID = ?
До сих пор мы применяли подсказки только в операции find(). Графы сущностей
тоже могут использоваться как подказки в запросах:
Файл: /examples/src/test/java/org/jpwh/test/fetching/FetchLoadGraph.java
List<Item> items =
em.createQuery("select i from Item i")
.setHint("javax.persistence.loadgraph", itemGraph)
.getResultList();
// select i.*, u.*
// from ITEM i
// left outer join USERS u on u.ID = i.SELLER_ID
Профили извлечения  363
Графы сущностей могут быть сложными. Следующий пример демонстрирует,
как работать с повторно используемыми объявлениями подграфов:
Файл: /model/src/main/java/org/jpwh/model/fetching/fetchloadgraph/Bid.java
@NamedEntityGraphs({
@NamedEntityGraph(
name = "BidBidderItemSellerBids",
attributeNodes = {
@NamedAttributeNode(value = "bidder"),
@NamedAttributeNode(
value = "item",
subgraph = "ItemSellerBids"
)
},
subgraphs = {
@NamedSubgraph(
name = "ItemSellerBids",
attributeNodes = {
@NamedAttributeNode("seller"),
@NamedAttributeNode("bids")
})
}
)
})
@Entity
public class Bid {
// ...
}
При использовании этого графа сущностей в качестве графа загрузки полу-
чение экземпляров Bid повлечет за собой извлечение полей Bid#bidder, Bid#item,
а также Item#seller и всей коллекции Item#bids. Несмотря на то что графам сущно-
стей можно давать любые имена, мы советуем выработать соглашение, которому
сможет следовать каждый член вашей команды, а также вынести строки в общие
константы.
При работе с API графов сущностей предыдущий план извлечения выглядит
так:
Файл: /examples/src/test/java/org/jpwh/test/fetching/FetchLoadGraph.java
EntityGraph<Bid> bidGraph = em.createEntityGraph(Bid.class);
bidGraph.addAttributeNodes(Bid_.bidder, Bid_.item);
Subgraph<Item> itemGraph = bidGraph.addSubgraph(Bid_.item);
itemGraph.addAttributeNodes(Item_.seller, Item_.bids);
Map<String, Object> properties = new HashMap<>();
properties.put("javax.persistence.loadgraph", bidGraph);
Bid bid = em.find(Bid.class, BID_ID, properties);
364  Планы извлечения, стратегии и профили
До сих пор мы использовали графы сущностей в качестве графов загрузки. Но
граф сущностей также можно использовать в качестве графа извлечения с помощью
подсказки javax.persistence.fetchgraph. При вызове метода find() или выполне-
нии запроса с использованием графа извлечения любые атрибуты и коллекции, не
указанные в плане, будут загружены с параметром FetchType.LAZY, а указанные –
с параметром FetchType.EAGER. Фактически это отменяет действие всех параметров
FetchType для атрибутов сущности и отображений коллекций, в то время как граф
загрузки вносит только дополнения.
Следует отметить две слабые стороны графов сущностей JPA, с которыми вы
столкнетесь довольно быстро. Во-первых, нельзя менять только планы извлече-
ния, без изменения стратегии извлечения (массовая загрузка /подзапросы/объ-
единения/выборки). Во-вторых, определение графа сущностей с помощью ан-
нотаций или XML небезопасно с точки зрения типов: имена атрибутов задаются
строками. Интерфейс EntityGraph, напротив, является типобезопасным.
12.4. Резюме
 Профиль извлечения объединяет план извлечения (какие данные загружать)
со стратегией извлечения (как их загружать) и определяется в метаданных
или аннотациях, которые можно использовать повторно.
 Мы создали глобальный план извлечения и определили, какие связи и кол-
лекции должны всегда загружаться в память. Мы создали план извлечения,
основанный на вариантах использования, определяющий способы доступа
к связанным сущностям и обхода коллекций, а также наборы данных, которые
должны быть доступны в отсоединенном состоянии.
 Научились выбирать правильную стратегию для плана извлечения. Вашей
целью должны быть минимизация количества выражений SQL и снижение
сложности отдельных выполняемых выражений SQL. Особенно следует из-
бегать проблем n + 1 выражений SELECT и декартова произведения, которые
мы подробно обсудили, используя различные стратегии оптимизации.
 Вы познакомились с профилями извлечения Hibernate и графами сущностей,
а также с профилями извлечения JPA.
Глава 13
Фильтрация данных
В этой главе:
 каскадная передача изменений состояния;
 перехват и обработка событий;
 аудит и версионирование с помощью Hibernate Envers;
 динамическая фильтрация данных.
В этой главе вы познакомитесь со множеством стратегий фильтрации данных при
их прохождении сквозь механизмы Hibernate. Когда Hibernate загружает инфор-
мацию из базы данных, при помощи фильтра можно прозрачно отсекать данные,
которые не должны быть доступны приложению. Также можно перехватывать та-
кие события, как запись информации в базу данных, и запускать вспомогательные
процедуры: например, делать записи в журнале аудита или присваивать записям
виртуальные идентификаторы.
Мы рассмотрим следующие возможности фильтрации данных и API.
 В разделе 13.1 вы узнаете, как реагировать на изменения состояния экзем-
пляра сущности и каскадно изменять состояния связанных сущностей.
Например, при сохранении объекта User (пользователь) Hibernate может
автоматически сохранить все связанные с ним объекты BillingDetails (пла-
тежные реквизиты). При удалении товара (Item) Hibernate может удалить
все связанные с ним экземпляры ставок (Bid). Вы можете воспользоваться
этой стандартной функциональностью JPA с помощью специальных атри-
бутов отображения связей и коллекций.
 Стандарт Java Persistence определяет поддержку методов обратного вызо-
вы и приемников событий жизненного цикла. Приемник событий (event listener)
– это класс со специальными методами, которые Hibernate вызывает
при изменении состояния экземпляра сущности: например, после загрузки
из базы данных или перед удалением из нее. Эти методы обратного вызова
могут также определяться в классах сущностей, с помощью специальных
аннотаций. Это дает возможность производить дополнительные побочные
эффекты при изменении состояния. В Hibernate имеется также несколько
нестандартных механизмов, позволяющих перехватывать события жизнен-
ного цикла на более низком уровне, которые мы обсудим в разделе 13.2.
366  Фильтрация данных
 Типичным побочным эффектом является запись в журнал аудита; подоб-
ный журнал обычно содержит информацию о том, какие данные измени-
лись, когда были сделаны изменения и кто их сделал. Более продвинутые
системы аудита могут хранить несколько версий данных, а также временные
представления (temporal views); при желании можно запросить у Hibernate
данные в том состоянии, в каком они были, например, неделю назад. Это
сложная проблема, и в разделе 13.3 мы познакомим вас с Hibernate Envers –
подпроектом, задачей которого являются версионирование и аудит в при-
ложениях JPA.
 В разделе 13.4 вы узнаете, что в Hibernate API имеются также фильтры
данных (data filters), позволяющие добавлять произвольные ограничения
в SQL-выражения SELECT, которые выполняет Hibernate. Благодаря им мож-
но определить произвольное ограниченное представление данных на уров-
не приложения. К примеру, можно применить фильтр, ограничивающий
данные по региону продажи или по критерию авторизации.
Сначала рассмотрим варианты каскадирования изменений состояния.
Главные нововведения в JPA 2
• Добавлена поддержка внедрения зависимостей с помощью CDI в классах при-
емников событий сущностей JPA.
13.1. Каскадная передача изменений состояния