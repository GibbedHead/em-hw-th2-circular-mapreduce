19.4.2. Применение JAXB-отображений
JAXB использует аннотации для определения свойств класса, так же как JPA. Эти
аннотации отображают поля класса в элементы и атрибуты документа XML. Сре-
да выполнения JAXB автоматически преобразует сущности в формат XML и об-
ратно. Вам это уже должно казаться знакомым; JAXB является отличным допол-
нением к предметной модели, использующей JPA.
Сериализация данных предметной модели  593
Ниже показан простой документ XML, представляющий экземпляр Item:
<item id="1" auctionEnd="2018-03-06T15:00:00+01:00">
<name>Baseball Glove</name>
<description>It is brown.</description>
<initialPrice>5.00</initialPrice>
<bids> А где продавец? Мы скоро это обсудим
<bid id="1" createdOn="2018-03-06T15:01:00+01:00">
<amount>11.00</amount>
</bid>
<bid id="2" createdOn="2018-03-06T15:02:00+01:00">
<amount>12.00</amount>
</bid>
<bid id="3" createdOn="2018-03-06T15:03:00+01:00">
<amount>13.00</amount>
</bid>
</bids>
</item>
Для получения такой схемы XML было принято несколько проектных реше-
ний. Давайте посмотрим на аннотации JAXB в классе Item, чтобы разобраться
с имеющимися возможностями:
Файл: /apps/app-web/src/main/java/org/jpwh/web/model/Item.java
@Entity
@XmlRootElement  Отображение в XML
@XmlAccessorType(XmlAccessType.FIELD)  Использует поля класса
public class Item implements Serializable {
@Id
@GeneratedValue(generator = Constants.ID_GENERATOR)
@XmlAttribute
protected Long id;
@NotNull
@Future(message = "{Item.auctionEnd.Future}")
@XmlAttribute
protected Date auctionEnd;
// ...
}
 Экземпляр Item отображается в XML-элемент <item>. Фактически эта аннотация раз-
решает использование JAXB для этого класса.
 Во время сериализации и десериализации экземпляр JAXB должен обращаться напря-
мую к полям класса, а не к методам чтения/записи. Доводы в пользу такого решения те
же, что и для JPA: это дает свободу при проектировании методов.
Идентификатор товара и дата окончания аукциона становятся атрибутами
XML, а остальные поля отобразятся во вложенные XML-элементы. Не нужно от-
594  Создание веб-приложений
мечать аннотациями JAXB поля класса description и initialPrice, поскольку они
будут отображены в элементы по умолчанию. Проще дело обстоит с атрибутами
классов модели предметной области, хранящими единственное значение: они ото-
бражаются в XML-атрибуты или во вложенные XML-элементы. А что насчет кол-
лекций и связей сущностей?
Можно просто добавить коллекцию со всеми элементами в документ XML, как
показано на примере Item#bids:
Файл: /apps/app-web/src/main/java/org/jpwh/web/model/Item.java
public class Item implements Serializable {
@OneToMany(mappedBy = "item")
@XmlElementWrapper(name = "bids")
@XmlElement(name = "bid")
protected Set<Bid> bids = new HashSet<>();
// ...
}
Здесь есть возможность для оптимизации; если при возвращении товара Item
потребуется включить все ставки, они все должны быть загружены. В настоящий
момент в JPA понадобится выполнить несколько запросов для загрузки экземпля-
ра Item и коллекции Item#bids, для которой настроена отложенная загрузка. При
подготовке ответа сериализатор JAXB автоматически обойдет каждый элемент
коллекции.
Hibernate инициализирует данные коллекции с помощью немедленной или
отложенной загрузки, а JAXB (или любой другой сериализатор) сериализует
каждый элемент по отдельности. Фактически Hibernate применяет специальные
коллекции, как объяснялось в разделе 12.1.2, поэтому при сериализации никаких
различий наблюдаться не будет. Это будет важно позднее, при десериализации
XML, поэтому оставим пока этот вопрос.
Если не требуется отображать коллекцию или поле в документ XML, ее нужно
отметить аннотацией @XmlTransient:
Файл: /apps/app-web/src/main/java/org/jpwh/web/model/Item.java
public class Item implements Serializable {
@OneToMany(mappedBy = "item", cascade = MERGE)
@XmlTransient
protected Set<Image> images = new HashSet<>();
// ...
}
Работать с коллекциями довольно легко независимо от того, что они содержат:
экземпляры простых типов, встраиваемых типов или множественные связи сущ-
ностей. Конечно, нужно быть осторожным при работе с циклическими ссылками
(circular references), когда, например, объект Bid содержит обратную ссылку на
Сериализация данных предметной модели  595
объект Item. В какой-то момент нужно остановиться и объявить ссылку несериа-
лизуемой (transient).
Самую большую трудность во время сериализации экземпляров сущностей, за-
груженных Hibernate, представляют внутренние прокси-объекты: заглушки для
коллекций и связей с отложенной загрузкой. В классе Item таковым является поле
seller, сслылающееся на сущность User.
19.4.3. Сериализация прокси-объектов Hibernate
Для поля Item#seller с помощью аннотации @ManyToOne(fetch = LAZY) настроена
отложенная загрузка. В момент загрузки экземпляра сущности Item ее поле seller
ссылается не на настоящий объект User: это прокси-класс User, который Hibernate
сгенерировал во время выполнения.
Если не добавлять никаких настроек, JAXB отобразит это поле так:
<item id="1" auctionEnd="2018-03-06T15:00:00+01:00">
<!-- ... -->
<seller/>
<!-- ... -->
</item>
Глядя на такой документ, клиент решит, что у товара нет продавца. Это, конечно
же, неверно; неинициализированный прокси-объект – это не то же самое, что null!
Вы можете придать пустому элементу XML особое значение, сообщая клиенту, что
пустой элемент означает прокси-объект, а отсутствие элемента соответствует null.
К сожалению, нам попадались такие решения сериализации (даже разработанные
для работы с Hibernate), которые не делали этого различия. Некоторые решения,
не предназначенные для Hibernate, наткнувшись на прокси-объект, могут даже
аварийно завершить работу.
Как правило, вы должны настроить свой инструмент сериализации для ос-
мысленной обработки прокси-объектов Hibernate. Для неинициализированных
прокси-объектов в этом приложении требуется получить следующий фрагмент
XML:
<item id="1" auctionEnd="2018-03-06T15:00:00+01:00">
<!-- ... -->
<seller type="org.jpwh.web.model.User" id="123"/>
<!-- ... -->
</item>
Это та же информация, что содержится в прокси-объекте: класс сущности
и идентификатор экземпляра, представляемого прокси-объектом. Теперь кли-
ент знает, что у товара действительно есть продавец с определенным идентифи-
катором; он сможет запросить эти данные, если потребуется. Получив этот до-
кумент XML на сервере, когда пользователь будет редактировать информацию
о товаре, вы сможете восстановить прокси-объект, зная идентификатор и класс
сущности.
596  Создание веб-приложений
Вы должны определить класс предметной модели, представляющий подобную
ссылку на сущность, и отобразить его в элементы и атрибуты XML:
Файл: /apps/app-web/src/main/java/org/jpwh/web/model/EntityReference.java
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class EntityReference {
@XmlAttribute
public Class type;
@XmlAttribute
public Long id;
public EntityReference() {
}
public EntityReference(Class type, Long id) {
this.type = type;
this.id = id;
}
}
Далее вы должны настроить преобразование экземпляра Item, чтобы для поля
Item#seller вместо реального объекта User использовался объект EntityReference.
Для такого поля в JAXB нужно указать собственный адаптер:
Файл: /apps/app-web/src/main/java/org/jpwh/web/model/Item.java
public class Item implements Serializable {
@NotNull
@ManyToOne(fetch = LAZY)
@XmlJavaTypeAdapter(EntityReferenceAdapter.class)
protected User seller;
// ...
}
Вы можете использовать EntityReferenceAdapter для любого поля, представляющего
связь между сущностями. Он знает, как читать и записывать объекты Entity-
Reference из XML и обратно:
Файл: /apps/app-web/src/main/java/org/jpwh/web/jaxrs/
EntityReferenceAdapter.java
public class EntityReferenceAdapter
extends XmlAdapter<EntityReference, Object> {
EntityManager em;
public EntityReferenceAdapter() {  Записывает экземпляры EntityReference
}
public EntityReferenceAdapter(EntityManager em) {  Читает экземпляры EntityReference
Сериализация данных предметной модели  597
this.em = em;
}
@Override
public EntityReference marshal(Object entityInstance)
throws Exception {
Class type = getType(entityInstance);  Создает представление для сериализации
Long id = getId(type, entityInstance);
return new EntityReference(type, id);
}
@Override
public Object unmarshal(EntityReference entityReference)
throws Exception {
if (em == null)
throw new IllegalStateException(
"Call Unmarshaller#setAdapter() and " +
"provide an EntityManager"
);
return em.getReference(  Создает прокси-объект
entityReference.type,
entityReference.id
);
}
}
 JAXB вызовет этот конструктор, когда понадобится сгенерировать документ XML.
В этом случае экземпляр EntityManager не понадобится: прокси-объект уже содержит
всю информацию, необходимую для создания экземпляра EntityReference.
 JAXB должен вызвать этот конструктор во время чтения документа XML. Вам понадо-
бится экземпляр EntityManager, чтобы получить прокси-объект Hibernate из экземпляра
EntityReference.
 При записи в документ XML возьмите прокси-объект Hibernate и создайте сериализуе-
мое представление. Здесь будут вызваны внутренние методы Hibernate, которые в этом
примере не показаны.
 При чтении документа XML возьмите сериализуемое представление и создайте прокси-
объект Hibernate, связанный с текущим контекстом хранения.
Наконец, вам понадобится расширение для JAX-RS, которое автоматически
инициализирует адаптер текущим экземпляром EntityManager из области види-
мости запроса, когда нужно будет преобразовать XML-документ на сервере. Вы
можете найти расширение EntityReferenceXMLReader в коде примеров.
Осталось обсудить несколько моментов. Во-первых, мы еще не говорили о пре-
образовании коллекций. Во время вызова службы любой элемент <bids> в доку-
менте XML будет десериализован, и на основе этих данных созданы отсоединенные
экземпляры Bid. Во время работы службы они будут доступны в отсоединенной
коллекции Item#bids. Больше ничего не произойдет, да и не может произойти:
598  Создание веб-приложений
коллекция, созданная JAXB после преобразования документа, не будет одной из
специальных коллекций Hibernate. Даже если в отображении вы настроили для
коллекции Item#bids каскадное слияние, метод EntityManager#merge() проигнори-
рует его.
Это напоминает проблему с прокси-объектами, которую вы решили в преды-
дущем разделе. Вы должны определить момент создания специальной коллекции
Hibernate, когда конкретное свойство будет прочитано из документа XML. Для
создания этой особой коллекции придется обратиться к внутренним методам Hibernate.
Мы советуем использовать коллекции с доступом только на чтение; фак-
тически отображение коллекции – это ссылка на операцию вставки результатов
запроса при отправке данных клиенту. Когда клиент отправляет серверу документ
XML, он не должен включать элемент <bids>. На сервере вы обращаетесь к коллек-
ции хранимого экземпляра Item после операции слияния (игнорируя коллекцию
во всемя слияния).
Во-вторых, вам, наверное, интересно, где найти примеры с JSON. Мы знаем, что
сейчас вы, скорее всего, используете в своих приложениях JSON, а не XML. Фор-
мат JSON удобен для анализа клиентом JavaScript. К сожалению, мы не смогли
настроить механизм преобразования JSON в JAX-RS без использования нестан-
дартных фреймворков. Хотя JAX-RS может быть стандартизован, но его процеду-
ра создания и чтения JSON пока не стандартизована: некоторые реализации JAXRS
используют Jackson, другие выбирают Jettison. Кроме того, появился новый
интерфейс Java для обработки JSON (JSONP), который в будущем может быть
включен в некоторые реализации JAX-RS.
Чтобы использовать JSON с Hibernate, вам потребуется написать такое же рас-
ширение, как мы сделали для JAXB, но только для своего любимого инструмента
преобразования JSON. Вы должны будете настроить обработку прокси-объектов,
способ отправки данных прокси-объекта клиенту и способ превращения прокси-
объекта в ссылку на сущность с помощью em.getReference(). Очевидно, вам при-
дется использовать какой-то API для расширения вашего фреймворка, как мы по-
ступили в случае с JAXB.
19.5. Резюме
 Вы увидели несколько способов интеграции Hibernate и JPA в среде веб-
приложений. Использовали EntityManager для внедрения в CDI и добавили
в уровень хранения обобщенные средства сортировки и постраничной выбор-
ки результатов запросов с помощью CDI.
 Рассмотрели применение JPA в приложениях JSF; узнали, как создавать служ-
бы с областью видимости запросов и диалоговых взаимодействий, используя
JPA в контексте хранения.
 Мы обсудили проблемы, связанные с сериализацией данных, и способы их ре-
шения в среде с клиентом без состояния и сервером JAX-RS.
Глава 20
Масштабирование
Hibernate
В этой главе:
 выполнение массовых и пакетных операций;
 улучшение масштабирования с помощью общего кэша.
Объектно-реляционное отображение помогает загрузить данные в приложение,
чтобы в дальнейшем использовать объектно-ориентированный язык программи-
рования для их обработки. Эта стратегия хорошо подходит для реализации много-
пользовательского приложения, работающего с маленьким или средним набором
данных в каждой отдельной единице работы.
С другой стороны, операции, требующие обработки большого объема данных,
не очень подходят для уровня приложения. Такие операции следует размещать
как можно ближе к данным, а не наоборот. В SQL-системах для реализации опе-
раций, затрагивающих тысячи строк, обычно хватает выражений UPDATE и DELETE,
выполняемых непосредственно в базе данных. Более сложные операции могут
потребовать выполнения дополнительных процедур внутри базы данных; сле-
довательно, хранимые процедуры можно рассматривать как одну из возможных
стратегий. В приложении с Hibernate в любой момент можно вернуться обратно
к JDBC и SQL. Мы уже обсудили некоторые варианты в главе 17. В этой главе мы
покажем, как избежать возврата к JDBC и как выполнять массовые и пакетные
операции с помощью Hibernate и JPA.
Главным основанием для заявления, что приложения, использующие объектно-
реляционный уровень хранения с объектно-реляционным отображением, должны
выигрывать в производительности у обычных приложений JDBC, является кэши-
рование. Хотя мы абсолютно уверены, что большинство приложений должно про-
ектироваться так, чтобы иметь приемлемую производительность без кэширова-
ния, без сомнения, найдутся такие типы приложений (особенно те, что в основном
читают данные или хранят в базе значительный объем метаданных), для которых
кэширование окажет значительное влияние на производительность. Более того,
масштабирование приложений с высоким уровнем конкурентного доступа, для
600  Масштабирование Hibernate
поддержки тысяч транзакций в секунду, как правило, требует применения како-
го-либо механизма кэширования для снижения нагрузки на сервер базы данных.
После рассмотрения массовых и пакетных операций мы обсудим систему кэши-
рования Hibernate.
Главные нововведения в JPA 2
• Операции массового удаления и изменения, которые преобразуются в SQL-
выражения DELETE и UPDATE, теперь стандартизованы и доступны в запросах на
основе критериев, в интерфейсах JPQL и SQL.
• Параметры конфигурации и аннотации для настройки общего кэша сущностей
теперь стандартизированы.
20.1. Массовые и пакетные операции
обработки данных
Сначала мы рассмотрим стандартизированные массовые операции в JPQL, такие
как UPDATE и DELETE, а также их эквиваленты в запросах на основе критериев. После
этого реализуем некоторые из этих операций с помощью обычных выражений
SQL. Затем вы узнаете, как добавлять и изменять большое количество экземпля-
ров сущностей, разделяя их на порции (пакеты). Наконец, мы покажем специаль-
ный интерфейс org.hibernate.StatelessSession.
20.1.1. Массовые операции в запросах
на основе критериев и JPQL
Язык JPQL (язык запросов механизма Java Persistence) очень похож на SQL. Ос-
новное различие заключается в том, что вместо имен таблиц JPQL использует
имена классов и вместо имен столбцов – имена свойств. JPQL также может рабо-
тать с наследованием, т. е. дает возможность использовать в запросах суперклассы
и интерфейсы. Механизм запросов на основе критериев JPA поддерживает те же
конструкции, что и JPQL, дополнительно давая возможность программного соз-
дания типизированных выражений.
Следующие выражения, которые мы вам покажем, поддерживают изменение
и удаление прямо в базе данных, без необходимости загрузки данных в память.
Мы также познакомим вас с выражением, которое может выбирать данные и на
этой основе далать вставку новых сущностей прямо на стороне базы данных.
Изменение и удаление экземпляров сущностей
JPA поддерживает операции управления данными, не уступающие по возмож-
ностям своим аналогам в SQL. Давайте посмотрим на первую JPQL-операцию:
UPDATE.
Массовые и пакетные операции обработки данных  601
Листинг 20.1  Выполнение JPQL-выражения UPDATE
Query query = em.createQuery(
"update Item i set i.active = true where i.seller = :s"
).setParameter("s", johndoe);
int updatedEntities = query.executeUpdate();
assertEquals(updatedEntities, 2); Экземпляры сущностей, а не «записи»
Выражения JPQL выглядят как выражения SQL, но используют имена сущ-
ностей (классов) и свойств. Поскольку псевдонимы необязательны, можно напи-
сать update Item set active = true. Для связывания именованных и позиционных
параметров можно использовать стандартный API запросов. Метод executeUpdate
вернет количество измененных экземпляров сущностей, которое может отличать-
ся от количества измененных записей в базе данных, в зависимости от стратегии
отображения.
Выражение UPDATE выполняется на стороне базы данных; Hibernate не изменит
никаких экземпляров Item, загруженных в текущий контекст хранения. В преды-
дущих главах мы многократно повторяли, что беспокоиться следует только об
управлении состоянием экземпляров сущностей, а не о выражениях SQL. Такая
стратегия подразумевает, что экземпляры сущностей, на которые вы ссылаетесь,
находятся в памяти. Если информацию, загруженную в память приложения, изме-
нить или удалить прямо в базе данных, она не будет изменена или удалена в кон-
тексте хранения.
Прагматичное решение такой проблемы заключается в простом соглашении:
выполняйте все операции в свежем контексте хранения. Затем вызовите Entity-
Manager для загрузки и сохранения экземпляров. Такое соглашение гарантирует,
что никакие ранее выполненные выражения не повлияют на контекст хранения.
С другой стороны, можно выборочно использовать метод refresh() для повторной
загрузки экземпляров сущностей в контекст хранения из базы данных, если из-
вестно, что данные были изменены вне контекста.
Выражения JPQL/критерии для массовых операций
и кэш второго уровня
Выполнение операций прямо в базе данных автоматически очищает необязатель-
ный кэш второго уровня в Hibernate. Hibernate анализирует массовые операции
JPQL или запросов на основе критериев, определяя, какие области кэша будут
затронуты. Затем очищает эти области в кэше второго уровня. Обратите внима-
ние, что этот анализ не отличается детальностью: даже если изменить или удалить
лишь несколько строк таблицы ITEM, Hibernate очистит все области кэша, где хра-
нятся данные класса Item.
Ниже показан такой же запрос, но описанный с помощью API запросов на ос-
нове критериев:
602  Масштабирование Hibernate
CriteriaUpdate<Item> update =
criteriaBuilder.createCriteriaUpdate(Item.class);
Root<Item> i = update.from(Item.class);
update.set(i.get(Item_.active), true);
update.where(
criteriaBuilder.equal(i.get(Item_.seller), johndoe)
);
int updatedEntities = em.createQuery(update).executeUpdate();
Еще одно преимущество заключается в том, что JPQL-выражение UPDATE и объ-
ект CriteriaUpdate могут работать с иерархиями наследования. Следующее вы-
ражение отмечает все кредитные карты как украденные, если имя пользователя
начинается с «J»:
Query query = em.createQuery( Для этого изменения Hibernate даже создаст временную таблицу
"update CreditCard c set c.stolenOn = :now where c.owner like 'J%'"
).setParameter("now", new Date());
Hibernate знает, как выполнить это изменение, даже если потребуется сгене-
рировать несколько выражений SQL или скопировать какие-либо данные во вре-
менную таблицу; он изменит строки в нескольких таблицах (поскольку сущность
CreditCard отображается в несколько таблиц суперкласса и подклассов).
JPQL-выражение UPDATE может ссылаться только на один класс сущности,
а массовая операция в запросе на основе критериев должна иметь лишь один кор-
невой объект; к примеру, нельзя изменить данные Item и CreditCard одновременно.
В предложении WHERE можно использовать подзапросы; любые соединения разре-
шается использовать только там.
Вы можете изменять значения встроенных типов: например, update User u set
u.homeAddress.street = .... Но нельзя изменять значения встраиваемых типов
в коллекциях. Так делать нельзя: update Item i set i.images.title = ....
Особенности Hibernate
По умолчанию операции не меняют никаких версий или меток времени в моди-
фицируемых сущностях (согласно стандарту JPA). Но расширение Hibernate по-
зволяет увеличить номера версий модифицируемых экземпляров сущностей:
int updatedEntities =
em.createQuery("update versioned Item i set i.active = true")
.executeUpdate();
Версия каждого обновляемого экземпляра сущности Item теперь будет увели-
чена прямо в базе данных, сообщая всем остальным транзакциям, использующим
оптимистическое управление параллельным доступом, что данные изменились.
(Hibernate не позволит использовать ключевое слово versioned, если поле с вер-
сией или меткой времени имеет тип org.hibernate.usertype.UserVersionType.)
В API запросов на основе критериев JPA версию придется менять вручную:
Массовые и пакетные операции обработки данных  603
CriteriaUpdate<Item> update =
criteriaBuilder.createCriteriaUpdate(Item.class);
Root<Item> i = update.from(Item.class);
update.set(i.get(Item_.active), true);
update.set(
i.get(Item_.version),
criteriaBuilder.sum(i.get(Item_.version), 1)
);
int updatedEntities = em.createQuery(update).executeUpdate();
Следующей массовой операцией, которую мы рассмотрим, будет операция DELETE:
em.createQuery("delete CreditCard c where c.owner like 'J%'")
.executeUpdate();
CriteriaDelete<CreditCard> delete =
criteriaBuilder.createCriteriaDelete(CreditCard.class);
Root<CreditCard> c = delete.from(CreditCard.class);
delete.where(
criteriaBuilder.like(
c.get(CreditCard_.owner),
"J%"
)
);
em.createQuery(delete).executeUpdate();
К DELETE и CriteriaDelete применяются те же правила: никаких соединений,
единственный корневой класс, необязательные псевдонимы, а подзапросы допускаются
только в предложении WHERE.
Существует еще одна массовая операция JPQL, позволяющая создавать экзем-
пляры сущностей прямо в базе данных.
Особенности Hibernate
Создание новых экземпляров сущностей
Предположим, что какие-то кредитные карты ваших клиентов были похищены.
Вы должны выполнить массовую операцию, чтобы отметить день, когда они были
похищены (скорее, день, когда это стало известно), и удалить скомпрометирован-
ные данные из ваших записей. Поскольку вы работаете в добросовестной компа-
нии, то должны сообщить о происшествии властям и пострадавшим клиентам.
Следовательно, прежде чем удалять записи, вам нужно извлечь всю информацию
о похищенных данных и создать сотни (а то и тысячи) объектов StolenCreditCard.
Специально
для этих целей вы создадите отображение класса сущности:
604  Масштабирование Hibernate
@Entity
public class StolenCreditCard {
@Id
public Long id;
public String owner;
public String cardNumber;
public String expMonth;
public String expYear;
public Long userId;
public String username;
public StolenCreditCard() {
}
public StolenCreditCard(Long id,
String owner, String cardNumber,
String expMonth, String expYear,
Long userId, String username) {
}
}
Hibernate отобразит этот класс в таблицу STOLENCREDITCARD. Затем нужно прямо
в базе выполнить выражение, извлекающее данные скомпрометированных кре-
дитных карт и создающее новые объекты StolenCreditCard. Это можно сделать
с помощью выражения INSERT ... SELECT, доступного только в Hibernate:
int createdRecords =
em.createQuery(
"insert into" +
" StolenCreditCard(id, owner, cardNumber, expMonth, expYear,
➥userId, username)" +
" select c.id, c.owner, c.cardNumber, c.expMonth, c.expYear, u.id,
➥u.username" +
" from CreditCard c join c.user u where c.owner like 'J%'"
).executeUpdate();
Эта операция, во-первых, выбирает данные объектов CreditCard, принадлежа-
щие соответствующему пользователю (User). Во-вторых, вставляет отображае-
мый класс StolenCreditCard прямо в таблицу.
Обратите внимание на следующее:
 свойства, принадлежащие целевому классу выражения INSERT ... SELECT
(в данном случае это StolenCreditCard), должны принадлежать конкретно-
му подклассу, но не (абстрактному) суперклассу. Поскольку класс Stolen-
CreditCard не является частью иерархии наследования, здесь это неважно;
 типы, возвращаемые проекцией в предложении SELECT, должны соответ-
ствовать типам аргументов в предложении INSERT;
 в данном примере свойство идентификатора сущности StolenCreditCard на-
ходится в списке вставляемых свойств и извлекается с помощью выборки;
его значение будет совпадать с оригинальным идентификатором сущности
Массовые и пакетные операции обработки данных  605
CreditCard. С другой стороны, можно отобразить генератор идентификатора
класса StolenCreditCard; но это подходит только для генераторов, работаю-
щих непосредственно на стороне базы данных, таких как последовательно-
сти или поля идентичности;
 если для целевого класса настроено версионирование (с помощью поля вер-
сии или метки времени), также будет сгенерировано новое значение версии
(ноль или текущий момент времени). Также можно выбрать номер версии
(или метку времени) и добавить свойство версии (или метки времени)
в список вставляемых свойств.
На момент написания этой книги выражение INSERT ... SELECT не поддержива-
лось ни в JPA, ни в API запросов на основе критериев Hibernate.
Массовые операции JPQL и запросов на основе критериев покрывают боль-
шинство ситуаций, в которых часто используется обычный SQL. В некоторых
случаях может понадобиться выполнить массовые операции SQL, не обращаясь
при этом к JDBC.
20.1.2. Массовые операции в SQL
В предыдущем разделе вы видели JPQL-выражения UPDATE и DELETE. Главное их
преимущество заключается в том, что они используют имена классов и свойств,
а также в том, что Hibernate умеет работать с иерархиями наследования и версионированием
при формировании запросов SQL. Поскольку Hibernate выполняет
анализ JPQL, он знает, как эффективно выполнять проверку состояния объектов
и выталкивать контекст хранения перед выполнением запроса, а также очищать
области кэша второго уровня.
Если в JPQL отсутствует нужная функциональность, массовые операции мож-
но выполнить с помощью SQL:
Query query = em.createNativeQuery(
"update ITEM set ACTIVE = true where SELLER_ID = :sellerId"
).setParameter("sellerId", johndoe.getId());
int updatedEntities = query.executeUpdate(); Все области кэша второго уровня будут очищены
assertEquals(updatedEntities, 2); Количество измененных записей, а не сущностей
Используя массовые операции в JPA, следует помнить о важной особенности:
Hibernate не выполняет анализа SQL для определения изменяемых таблиц. Это
значит, что Hibernate не знает, нужно ли выталкивать контекст хранения перед
выполнением запроса. В предыдущем примере Hibernate не знал, что вы изменя-
ли таблицу ITEM. Hibernate должен проверить изменение состояния и сохранить
любые экземпляры сущностей, присутствующие в контексте хранения, перед вы-
полнением запроса; он не может проверить и сбросить только сущности Item.
Если вы активировали кэш второго уровня, вам нужно побеспокоиться о сле-
дующем (в противном случае вам не о чем волноваться): Hibernate должен под-
606  Масштабирование Hibernate
держивать кэш второго уровня в актуальном состоянии, чтобы не возвращать
устаревших данных, поэтому он очистит все области кэша при выполнении SQL-
выражения UPDATE или DELETE. Следовательно, после выполнения операции кэш
второго уровня окажется пустым!
Особенности Hibernate
Но вы можете получить более полный контроль над проверкой состояния объек-
тов выталкиванием контекста и очисткой кэша второго уровня, прибегнув к API
для запросов SQL в Hibernate:
org.hibernate.SQLQuery query =
em.unwrap(org.hibernate.Session.class).createSQLQuery(
"update ITEM set ACTIVE = true where SELLER_ID = :sellerId"
);
query.setParameter("sellerId", johndoe.getId());
query.addSynchronizedEntityClass(Item.class);
int updatedEntities = query.executeUpdate();
assertEquals(updatedEntities, 2); Количество измененных записей, а не сущностей
Вызывая метод addSynchronizedEntityClass(), вы сообщаете Hibernate, какие
таблицы будут изменены выражением SQL, и Hibernate очистит только соответ-
ствующие области кэша. Hibernate также понимает, что перед выполнением за-
проса он должен вытолкнуть лишь измененные экземпляры сущностей Item.
Порой при выполнении массовых операций нельзя обойти слой приложения.
Приходится загружать данные в память приложения, взаимодействуя с объектом
EntityManager для изменения и удаления, что приводит к необходимости обраба-
тывать данные порциями (пакетами).
20.1.3. Пакетная обработка данных
Чтобы создать или изменить сотню или тысячу экземпляров сущностей в одной
транзакции и одной единице работы, может не хватить памяти. Более того, тре-
буется учитывать время, необходимое для завершения транзации. Большинство
диспетчеров транзакций имеет малое время ожидания, в пределах секунд или ми-
нут. Диспетчер транзакций Bitronix, который использовался в примерах в этой
книге, по умолчанию устанавливает время ожидания, равное 60 секундам. Если
ваша единица работы требует больше времени для завершения, вы должны снача-
ла переопределить этот предел:
tx.setTransactionTimeout(300); 5 минут
Это метод класса UserTransaction. Только будущие транзакции, запущенные
в этом потоке выполнения, станут использовать новое значение времени ожида-
ния. Вы должны установить его до вызова метода begin().
Будут очищены только области кэша
второго уровня с данными сущности Item
Массовые и пакетные операции обработки данных  607
Давайте попробуем записать несколько тысяч экземпляров Item в базу пакетами.
Запись наборов экземпляров сущностей
Каждый отсоединенный экземпляр сущности, передаваемый в метод EntityManager#
persist(), помещается в кэш контекста хранения, как объяснялось в раз-
деле 10.2.8. Чтобы предотвратить полное расходование памяти, нужно вызывать
методы flush() и clear(), выталкивая и очищая контекст хранения, после опреде-
ленного количества вставок, осуществляя тем самым пакетную запись данных.
Листинг 20.2  Вставка большого количества экземпляров сущностей
tx.begin();
EntityManager em = JPA.createEntityManager();
for (int i = 0; i < ONE_HUNDRED_THOUSAND; i++) {  Создание экземпляров
Item item = new Item(
// ...
);
em.persist(item);
if (i % 100 == 0) {  Выполнение выражений INSERT
em.flush();
em.clear();
}
}
tx.commit();
em.close();
 Создание и сохранение 100 000 экземпляров Item.
 После 100 операций контекст хранения выталкивается и очищается. Вследствие этого
SQL-выражения INSERT будут выполнены для 100 экземпляров Item; а поскольку они
окажутся в отсоединенном состоянии и на них нигде не будет ссылок, механизм сборки
мусора JVM сможет повторно использовать занимаемую ими область памяти.
В настройках единицы хранения вы должны будете присвоить параметру hibernate.
jdbc.batch_size значение, равное размеру пакета, – в данном случае 100. Ис-
пользуя эту настройку, Hibernate будет накапливать выражения INSERT на уровне
JDBC с помощью метода PreparedStatement#addBatch().
Пакетное выполнение смешанных выражений SQL
Процедура, сохраняющая пакеты из экземпляров различных сущностей, где по-
следовательно идет экземпляр Item, потом User, а затем снова Item и снова User
и т. д., будет не очень эффективно накапливать выражения на уровне JDBC. Во вре-
мя выталкивания контекста Hibernate сначала сгенерирует SQL-выражение insert
into ITEM, затем insert into USERS, а потом опять insert into ITEM и т. д. Но Hibernate не
сможет выполнить большого пакета выражений за один раз, поскольку каждое сле-
дующее выражение отлично от предыдущего. Но если в настройках единицы хра-
608  Масштабирование Hibernate
нения активировать параметр hibernate.order_inserts, Hibernate отсортирует опе-
рации перед созданием наборов выражений. После этого он сначала выполнит все
выражения INSERT для таблицы ITEM, а затем выражения INSERT для таблицы USERS.
Следовательно, Hibernate сможет создать наборы выражений на уровне JDBC.
Если для сущности Item используется кэш второго уровня, для выполнения
вставки пакетов данных его нужно обойти: см. раздел 20.2.5.
Серьезную проблему для массовой вставки данных представляет нагрузка на
генератор идентификаторов, потому что каждый вызов EntityManager#persist()
должен получить новое значение идентификатора. Обычно генератором является
последовательность в базе данных, обращение к которой происходит отдельно для
каждого экземпляра сущности. Для эффективной реализации процедуры пакет-
ных изменений следует сократить количество обращений к базе данных.
Особенности Hibernate
В разделе 4.2.5 мы советовали применять доступный только в Hibernate генератор
enhanced-sequence, поскольку он поддерживает некоторые оптимизации, идеально
подходящие для обработки пакетов данных. Во-первых, нужно описать генератор
в файле метаданных package-info.java:
@org.hibernate.annotations.GenericGenerator(
name = "ID_GENERATOR_POOLED",
strategy = "enhanced-sequence",
parameters = {
@org.hibernate.annotations.Parameter(
name = "sequence_name",
value = "JPWH_SEQUENCE"
),
@org.hibernate.annotations.Parameter(
name = "increment_size",
value = "100"
),
@org.hibernate.annotations.Parameter(
name = "optimizer",
value = "pooled-lo"
)
})
Теперь в отображаемых классах сущностей можно воспользоваться генерато-
ром, применив аннотацию @GeneratedValue.
Если параметру increment_size присвоить значение 100, последовательность
будет выдавать значения 100, 200, 300, 400 и т. д. Оптимизатор pooled-lo генери-
рует промежуточные значения каждый раз, когда вызывается persist() без лиш-
него обращения к базе данных. Следовательно, если следующее значение, полу-
ченное от последовательности, равняется 100, на уровне приложения Hibernate
сгенерирует значения идентификаторов 101, 102, 103 и т. д. Как только набор из
Массовые и пакетные операции обработки данных  609
100 идентификаторов закончится, база данных вернет следующее значение после-
довательности, и процедура повторится снова. Следовательно, чтобы получить
набор идентификаторов для пакета из 100 операций вставки, нужно обратиться
к базе данных лишь один раз. Есть и другие оптимизаторы генераторов, но оп-
тимизатор pooled-lo эффективен практически в любых вариантах использования
и прост для понимания и настройки.
Однако помните, что шаг увеличения, равный 100, будет оставлять большие
промежутки между числовыми идентификаторами, если приложение будет ис-
пользовать ту же последовательность, но иной алгоритм. Однако не стоит сильно
об этом беспокоиться; если генерировать новый идентификатор каждую миллисе-
кунду, все доступные значения исчерпаются за 3 млн лет, а не за 300.
Этот же прием пакетной обработки данных можно использовать для изменения
большого количества экземпляров сущностей.
Особенности Hibernate
Изменение наборов экземпляров сущностей
Представьте, что нужно обработать множество экземпляров Item и изменения
не такие простые, как изменение флага (что вы уже делали ранее с помощью един-
ственного выражения UPDATE в JPQL). Предположим также, что по каким-то при-
чинам нельзя создать хранимую процедуру в базе данных (возможно, из-за того,
что приложение работает с СУБД, не поддерживающей хранимых процедур).
Остается лишь один выход – написать Java-код, загружающий большое количество
данных в память и обрабатывающий с помощью процедуры.
Это требует обработки пакетов данных и перемещения по результатам запроса
с помощью курсора, что доступно только в Hibernate. Пожалуйста, перечитайте
наше объяснение, как работать с курсорами, в разделе 14.3.3 и проверьте, поддер-
живаются ли курсоры вашей СУБД и драйвером JDBC. Следующий код будет
загружать 100 экземпляров Item за один раз.
Листинг 20.3  Изменение большого количества экземпляров сущностей
tx.begin();
EntityManager em = JPA.createEntityManager();
org.hibernate.ScrollableResults itemCursor =  Открыть курсор
em.unwrap(org.hibernate.Session.class)
.createQuery("select i from Item i")
.scroll(org.hibernate.ScrollMode.SCROLL_INSENSITIVE);
int count = 0;
while (itemCursor.next()) {  Переместиться по курсору
Item item = (Item) itemCursor.get(0);  Извлечь экземпляр
modifyItem(item);
if (++count % 100 == 0) {  Вытолкнуть контекст хранения
610  Масштабирование Hibernate
em.flush();
em.clear();
}
}
itemCursor.close();
tx.commit();
em.close();
 Здесь выполняется запрос JPQL, загружающий все экземпляры Item из базы данных.
Чтобы не загружать сразу всех результатов в память, открывается курсор.
 Управлять курсором и перемещаться по нему можно с помощью ScrollableResults API.
Каждый вызов метода next() выполняет переход к следующей записи в курсоре.
 Вызов get(int i) загружает в память приложения одну сущность (запись, на которую
указывает курсор).
 Чтобы не допустить переполнения памяти, перед загрузкой следующих 100 записей
нужно вытолкнуть и очистить контекст хранения.
Для лучшей производительности следует присвоить параметру hibernate.jdbc.
batch_size в настройках единицы хранения значение 100, равное размеру обраба-
тываемого пакета. На уровне JDBC Hibernate накапливает все выражения UPDATE,
которые будут выполнены в момент выталкивания контекста. Если для класса
сущности не настроено версионирование, по умолчанию Hibernate не будет на-
капливать изменений на уровне JDBC – некоторые драйверы JDBC возвращают
некорректное число записей, измененных выражением UPDATE (в частности, такое
поведение наблюдается в Oracle). Если вы уверены, что ваш драйвер JDBC кор-
ректно поддерживает это поведение, а класс сущности Item имеет аннотацию @Version,
чтобы активировать пакетную обработку данных в JDBC, нужно присвоить
параметру hibernate.jdbc.batch_versioned_data значение true. Если для сущности
Item используется кэш второго уровня, для вставки (изменения) порций данных
его нужно обойти: см. раздел 20.2.5.
Другой способ, позволяющий избежать переполнения памяти в контексте хра-
нения (по сути, отключая его), состоит в применении интерфейса org.hibernate.
StatelessSession.
Особенности Hibernate
20.1.4. Интерфейс StatelessSession
Контекст хранения является важнейшей частью механизма Hibernate. Без него не
получится управлять состоянием сущности, а Hibernate не сможет автоматически
отслеживать изменения. Многое другое также окажется невозможным.
Однако в Hibernate имеется альтернативный интерфейс для тех, кто предпо-
читает работать с базой данных, просто выполняя выражения. Интерфейс org.
hibernate.StatelessSession ориентирован на выражения и очень похож на обыч-
Массовые и пакетные операции обработки данных  611
ный JDBC, за исключением возможности работы с отображаемыми хранимыми
классами и совместимости с базами данных. Наибольший интерес представляют
методы insert(), update() и delete(), которые немедленно отображаются в соот-
ветствующие операции JDBC/SQL.
Давайте напишем такую же процедуру, изменяющую все товары, но с примене-
нием этого интерфейса.
Листинг 20.4  Изменение данных с помощью StatelessSession
tx.begin();
org.hibernate.SessionFactory sf =  Создание экземпляра StatelessSession
JPA.getEntityManagerFactory().unwrap(org.hibernate.SessionFactory.class);
org.hibernate.StatelessSession statelessSession = sf .openStatelessSession();
org.hibernate.ScrollableResults itemCursor =  Загрузка экземпляров Item
statelessSession
.createQuery("select i from Item i")
.scroll(org.hibernate.ScrollMode.SCROLL_INSENSITIVE);
while (itemCursor.next()) {  Получение экземпляра
Item item = (Item) itemCursor.get(0);
modifyItem(item);
statelessSession.update(item);  Выполнение операции UPDATE
}
itemCursor.close();
tx.commit();
statelessSession.close();
 Создание экземпляра StatelessSession с помощью фабрики SessionFactory, которую
можно получить из объекта EntityManagerFactory.
 Здесь выполняется запрос JPQL, загружающий все экземпляры Item из базы данных.
Вместо загрузки сразу всех результатов в память здесь открывается курсор.
 Последовательное перемещение по результатам с помощью курсора и извлечение эк-
земпляра сущности Item. Экземпляр находится в отсоединенном состоянии; контекст
хранения отсутствует!
 Поскольку в отсутствие контекста хранения Hibernate не может автоматически обнару-
живать изменения, приходится выполнять SQL-выражение UPDATE вручную.
Отключение контекста хранения и применение интерфейса StatelessSession
влекут за собой серьезные последствия и существенные ограничения (по крайней
мере, по сравнению с обычными объектами EntityManager и org.hibernate.Session):
 экземпляр StatelessSession не имеет кэша контекста хранения и не взаимо-
действует с другими кэшами второго уровня или кэшем запросов. Отсут-
ствует автоматическая проверка изменения состояния объектов или выпол-
нение кода SQL во время подтверждения транзакции. Все действия влекут
немедленное выполнение операций SQL;
612  Масштабирование Hibernate
 никакие изменения в экземплярах сущностей и никакие операции не пе-
редаются каскадно к связанным сущностям. Hibernate игнорирует любые
настройки каскадирования в отображениях. Вы работаете с экземплярами
одного класса сущности;
 отсутствует область гарантированной идентичности объектов. Один и тот
же запрос, выполненный дважды в рамках одного экземпляра StatelessSession,
вернет два отсоединенных объекта, находящихся в разных областях
памяти. Это может привести к эффекту зеркалирования данных (data aliasing),
когда два экземпляра сущности будут неразличимы, если неправильно
реализовать методы equals() и hashCode() в хранимом классе;
 Hibernate игнорирует любые изменения коллекций, отображаемых в виде
связей сущностей (один ко многим, многие ко многим). В расчет берутся
только коллекции базовых или встраиваемых типов. Следовательно, не
нужно отображать связей сущностей с помощью коллекций (кроме от-
ношений многие к одному или один к одному) и работать с отношением
только на другой стороне ассоциации. Вместо последовательного обхода
отображаемой коллекции лучше выполнить запрос для получения тех же
данных;
 Hibernate не оповещает обработчиков событий JPA и не вызывает методов
обратного вызова во время выполнения операций с помощью Stateless-
Session. StatelessSession обходит любые перехватчики типа org.hibernate.
Interceptor, поэтому не следует полагаться на базовый механизм событий
Hibernate.
Хороших примеров использования StatelessSession немного; к этому способу
лучше обращаться, когда обработка пакетов данных с помощью обычного экзем-
пляра EntityManager становится слишком запутанной.
В следующем разделе мы представим систему общего кэша Hibernate. Кэширо-
вание данных на уровне приложения – это дополнительная оптимизация, кото-
рую можно применять в сложных многопользовательских приложениях.
20.2. Кэширование данных
В этом разделе мы покажем, как подключать, настраивать и управлять общим кэ-
шем данных в Hibernate. Общий кэш данных не является кэшем контекста хра-
нения, который Hibernate никогда не разделяет между потоками выполнения
в приложении. Это не оптимально по причинам, указанным в разделе 10.1.2. Мы
называем контекст хранения кэшем первого уровня. Общий кэш данных – кэш
второго уровня – является необязательным, и хотя JPA стандартизует некоторые
параметры настройки и отображения метаданных для общего кэша, каждая реали-
зация использует свое решение для оптимизации. Начнем с обзора архитектуры
общего кэша Hibernate.
Кэширование данных  613
Особенности Hibernate
20.2.1. Архтектура общего кэша в Hibernate
Кэш хранит представление текущего состояния базы данных на стороне приложе-
ния в памяти или на диске сервера приложений. Кэш представляет собой локаль-
ную копию данных, находящихся между приложением и базой данных. Проще
говоря, кэш Hibernate очень похож на словарь с ключами и значениями. Hibernate
может хранить в кэше данные в виде пары ключ/значение и находить требуемое
значение по ключу.
В Hibernate есть несколько типов общих кэшей. Кэш можно использовать, что-
бы лишний раз не обращаться к базе данных, в одном из следующих случаев:
 приложение выполняет поиск экземпляра сущности по идентификатору
(первичному ключу); здесь может произойти обращение к кэшу данных сущ-
ностей. Такая же операция нужна для инициализации прокси-объекта сущ-
ности, поэтому она так же может обратиться к кэшу сущностей, а не к базе
данных. В роли ключа выступает значение идентификатора экземпляра
сущности, а в роли значения – данные экземпляра сущности (значения его
свойств). Эти данные хранятся в разобранном виде, и во время чтения из
кэша Hibernate соберет их в один экземпляр;
 механизм хранения выполняет отложенную инициализацию коллекции;
кэш коллекций может хранить соответствующие элементы. В качестве ключа
будет выступать роль коллекции: например, «Item[1234]#bids» будет пред-
ставлять коллекцию bids экземпляра Item с идентификатором 1234. Значе-
нием в данном случае будет множество идентификаторов объектов Bid, на-
ходящихся в коллекции (обратите внимание, что кэш коллекций не хранит
данных сущностей Bid, а только их идентификаторы!);
 приложение выполняет поиск экземпляра сущности по значению уникаль-
ного атрибута. Это особый кэш естественных идентификаторов для клас-
сов сущностей с уникальными полями, такими как User#username. В роли
ключа выступает уникальное поле, такое как username, а в роли значения –
идентификатор сущности User;
 приложение выполняет запрос JPQL, SQL или запрос на основе критериев,
а результат итогового запроса SQL уже находится в кэше результатов за-
проса. В роли ключа выступает сам запрос SQL, включающий значения всех
параметров, а в роли значения – некоторое представление результата запро-
са SQL, которое может содержать значения идентификаторов сущностей.
Важно понимать, что кэш данных сущностей – это единственный кэш, где хра-
нятся фактические данные. Три других кэша хранят лишь идентификаторы сущ-
ностей. Следовательно, без подключения кэша данных сущностей нет смысла,
например, подключать кэш естественных идентификаторов. За удачным поиском
в кэше естественных идентификаторов всегда следует обращение к кэшу данных
сущностей. Мы подробнее разберем это поведение далее на конкретных примерах.
614  Масштабирование Hibernate
Как уже упоминалось, кэш в Hibernate имеет двухуровневую организацию.
Хранилище ссылок на неизменяемые данные
Hibernate сохраняет данные в кэше второго уровня в виде разобранной копии,
которую он затем собирает во время чтения из кэша. Копирование данных – до-
рогостоящая операция; поэтому для оптимизации Hibernate может хранить сами
неизменяемые данные, не создавая копии в кэше второго уровня. Это очень под-
ходит для ссылочных данных. Предположим, есть класс сущности City с полями
zipcode и name, отмеченный как неизменяемый с помощью аннотации @Immutable.
Если активировать параметр конфигурации единицы хранения hibernate.cache.
use_reference_entries, Hibernate будет пытаться (за исключением некоторых особых
случаев) сохранить ссылку на объект City прямо в кэше данных второго уровня.
Но если в приложении случайно изменить экземпляр City, это изменение коснется
всех пользователей (локальной) области кэша, поскольку все будут иметь одну и ту
же ссылку.
Кэш второго уровня
На рис. 20.1 показаны различные элементы системы кэширования в Hibernate.
В роли кэша первого уровня выступает контекст хранения, как объяснялось в раз-
деле 10.1.2, Hibernate не разделяет этот кэш между потоками выполнения; каж-
дый поток имеет свою копию данных в этом кэше. Следовательно, при обращении
к этому кэшу не будет никаких проблем с изоляцией транзакций и многопоточ-
ностью.
Система кэша второго уровня в Hibernate может быть ограничена одним про-
цессом JVM, а может быть распределена по кластеру JVM. Многочисленные пото-
ки приложения могут обращаться к кэшу второго уровня одновременно. Страте-
гия многопоточного кэширования определяет настройку изоляции транзакций для
кэша данных сущностей, кэша элементов коллекции и кэша естественных иден-
тификаторов. Во время загрузки или сохранения записи в одном из этих кэшей
Hibernate согласует операцию доступа с одной из выбранных стратегий. Выбрать
правильную стратегию многопоточного кэширования классов сущностей может
быть непросто, но немного позже мы покажем, как это делается, на нескольких
примерах.
Кэш результатов запроса имеет свою внутреннюю стратегию поддержки парал-
лельного доступа и актуальности данных. Мы покажем, как работает кэш резуль-
татов запросов и для каких запросов его применение имеет смысл.
Реализация механизма кэширования имеет вид подключаемого модуля. В настоящий
момент Hibernate вынуждает выбрать одну реализацию механизма кэширо-
вания для всей единицы хранения. Реализация механизма кэширования отвечает
за управление физическими областями кэширования – ячейками, хранящими
данные в слое приложения (в памяти, в индексных файлах или даже в репликах
на кластере). Реализация механизма кэширования управляет временем жизни
записей
и удаляет их по его истечении, сохраняя только самые последние изме-
Кэширование данных  615
ненные данные, когда кэш уже переполнен. Реализация поставщика механизма кэ-
ширования может взаимодействовать с другими своими экземплярами в кластере
JVM для синхронизации данных в ячейках каждого экземпляра. Сам Hibernate не
управляет кластером кэшей; это берет на себя механизм кэширования.
Рис. 20.1  Двухуровневая организация кэша в Hibernate
В этом разделе мы добавим кэширование для одной виртуальной машины JVM,
используя реализацию Ehcache – простой, но мощный механизм (изначально раз-
работанный для Hibernate в качестве простого кэша Hibernate). Мы рассмотрим
лишь некоторые из базовых настроек Ehcache; за более подробной информацией
обращайтесь к руководству.
Чаще всего первый вопрос, который задают разработчики: «Будет ли кэш знать,
что данные изменились в базе?» Давайте попробуем ответить на него прежде, чем
приступим к настройке и использованию кэша.
Кэширование и многопоточность
Если приложение не имеет исключительного доступа к базе данных, примене-
ние общего кэша целесообразно лишь для редко изменяющихся данных, когда не-
большой период рассогласования некритичен. Если другое приложение изменит
данные в базе, ваш кэш будет хранить устаревшую версию, пока срок ее жизни не
подойдет к концу. Другим приложением может оказаться хранимая процедура, вы-
616  Масштабирование Hibernate
зываемая триггером, или даже настройка внешнего ключа ON DELETE или ON UPDATE.
Кэш в Hibernate просто не имеет возможности узнать, что другое приложение или
триггер базы данных что-то изменили; база данных не может послать сообщения
об этом. (Вы можете реализовать такую возможность с помощью триггеров базы
данных и JMS, и сделать это довольно просто.) Следовательно, использование
кэша зависит от типа данных и требований к их актуальности для конкретного
варианта использования.
Предположим на минуту, что приложение имеет исключительный доступ к базе
данных. Но даже в этом случае вы должны задать себе те же вопросы, посколь-
ку данные, загружаемые в общий кэш из базы данных в одной транзакции, могут
стать видимы для другой транзакции. Какую изоляцию транзакций должен обеспечивать
механизм кэширования? Наличие общего кэша повлияет на уровень изо-
ляции ваших транзакций независимо от того, читаете вы только подтвержденные
данные или используете повторяющееся чтение. Для некоторых данных может
быть допустимо, чтобы обновления в одном потоке приложения не становились
сразу видимы другим потокам, создавая приемлемый интервал рассогласования.
Это позволит применить более эффективную и агрессивную стратегию кэширо-
вания.
Начните проектирование с рассмотрения диаграммы моделей предметной об-
ласти и классов сущностей. Для кэширования отлично подойдут классы, пред-
ставляющие:
 редко изменяющиеся данные;
 некритичные данные (например, данные управления контентом);
 локальные данные приложения, которые не могут быть изменены другими
приложениями.
Плохими кандидатами являются:
 часто изменяемые данные;
 финансовые данные, когда решения принимаются на основе последних из-
менений;
 данные, разделяемые с другими приложениями, которые могут изменяться.
Но это не все правила, которые мы обычно применяем. В большинстве прило-
жений есть классы со следующими свойствами:
 небольшое количество экземпляров (тысячи, но не миллионы), легко уме-
щающееся в памяти;
 на каждый экземпляр класса есть множество ссылок из экземпляров других
классов или
 экземпляров классов, изменяемых редко (или никогда).
Мы называем такой тип данных ссылочными данными. В качестве примера мож-
но привести классы представления почтовых кодов, адресов, статического текста
сообщений и т. д. Ссылочные данные идеально подходят для хранения в общем
кэше, а приложения, использующие такие данные, могут получить большие пре-
имущества от их кэширования. Данные должны обновляться по истечении опре-
деленного времени, а после обновления будет небольшой, но приемлемый период
Кэширование данных  617
рассогласования. Фактически для некоторых ссылочных данных (таких как коды
стран) допустим очень большой период рассогласования, и их можно вообще не
обновлять, если они доступны только для чтения.
Вы должны тщательно анализировать каждый класс или коллекцию, для ко-
торой хотите использовать кэширование. Также вы должны выбрать правильную
стратегию многопоточного кэширования доступа.
Выбор стратегии многопоточного кэширования
Реализация стратегии многопоточного кэширования является посредником:
она отвечает за сохранение данных в кэше и их последующее извлечение из него.
Эта важная роль определяет семантику изоляции транзакций для конкретного
объекта. Для каждого хранимого класса или коллекции придется выбрать, какую
стратегию многопоточного кэширования использовать в случае использования
общего кэша.
В Hibernate поддерживаются четыре стратегии многопоточного кэширования,
соответствующие убывающим уровням строгости в терминах изоляции транзакций:
 TRANSACTIONAL – доступная только в средах с диспетчером системных транзакций,
эта стратегия гарантирует полную изоляцию транзакций вплоть до
уровня повторяемого чтения, если такой уровень поддерживается механиз-
мом кэширования. При использовании этой стратегии Hibernate предпола-
гает, что механизм кэширования знает о системных транзакциях и принима-
ет в них участие. Hibernate не предпринимает никаких попыток блокировать
или проверить версии; изоляцию данных в параллельных транзакциях он
целиком доверяет механизму кэширования. Эту стратегию лучше исполь-
зовать для данных, которые в основном читаются, когда важно предотвра-
тить чтение их устаревших значений в параллельных транзакциях и когда
изменения происходят достаточно редко. Такая стратегия будет работать
и в кластере, если механизм кэширования поддерживает синхронное рас-
пределенное кэширование;
 READ_WRITE – поддерживает уровень изоляции с чтением подтвержденных
данных, когда Hibernate может использовать метки времени; такая стра-
тегия уже не может применяться в кластерах. Hibernate также может ис-
пользовать для блокировки нестандартный API механизма кэширования.
Используйте эту стратегию для данных, которые обычно только читаются,
когда важно предотвратить чтение устаревших значений в параллельных
транзакциях, а изменения редки. Эту стратегию не стоит использовать, ког-
да данные параллельно меняются на стороне базы данных;
 NONSTRICT_READ_WRITE – не дает никаких гарантий согласованности между
кэшем и базой данных. Транзакция может извлечь из кэша устаревшие дан-
ные. Используйте эту стратегию, если данные практически не меняются
(скажем, не каждые 10 секунд), а период рассогласования не сильно важен.
Период рассогласования настраивается с помощью политики обновления
618  Масштабирование Hibernate
данных в механизме кэширования. Такая стратегия может применяться
и в кластере, даже если он использует асинхронное распределенное кэши-
рование. Другие приложения вполне могут менять те же данные в базе;
 READ_ONLY – подходит для неизменяемых данных. Вы получите исключение
при попытке изменения. Используйте ее только для ссылочных данных.
По мере уменьшения строгости увеличиваются производительность и возмож-
ность масштабирования. Асинхронный кэш кластера со стратегией NONSTRICT_
READ_WRITE сможет поддерживать куда больше транзакций, чем синхронный со
стратегией TRANSACTIONAL. Прежде чем использовать полную изоляцию транзак-
ций в рабочем окружении, тщательно исследуйте производительность кэша кластера
с ее применением. Если ни в коем случае нельзя получать устаревшие дан-
ные, в большинстве случаев стоит отключить распределенное кэширование для
конкретного класса!
Начните измерять производительность приложения с отключенным общим
кэшем. Затем подключайте его для подходящих классов, постоянно тестируя
масштабируемость системы, оценивая различные стратегии многопоточного кэ-
ширования. Для оценки влияния изменений на настройку кэша вам понадобятся
автоматические тесты. Мы советуем заранее написать тесты на производитель-
ность и масштабирование критических участков приложения до подключения
разделяемого кэша.
Теперь, зная теорию, пришло время узнать, как кэширование работает на прак-
тике.
Сначала настроим общий кэш.
20.2.2. Настройка общего кэша
Общий кэш настраивается в файле конфигурации persistence.xml.
Листинг 20.5  Настройка общего кэша в файле persistence.xml
Файл: /model/src/main/resources/META-INF/persistence.xml
<persistence-unit name="CachePU">
...
<shared-cache-mode>ENABLE_SELECTIVE</shared-cache-mode>  Режим общего кэша
<properties>
<property name="hibernate.cache.use_second_level_cache"
value="true"/>  Подключение кэша второго уровня
<property name="hibernate.cache.use_query_cache"
value="true"/>
<property name="hibernate.cache.region.factory_class"
value="org.hibernate.cache.ehcache.  Механизм кэша второго уровня
➥SingletonEhCacheRegionFactory"/>
<property name="net.sf.ehcache.configurationResourceName"
value="/cache/ehcache.xml"/>  Местоположение файла конфигурации
<property name="hibernate.cache.use_structured_entries"
value="false"/>  Управление сборкой экземпляров сущностей
Кэширование данных  619
<property name="hibernate.generate_statistics"
value="true"/>  Сбор статистики
</properties>
</persistence-unit>
 Режим общего кэша влияет на способ активации кэширования для классов сущностей
в единице хранения. Обычно кэш подключается избирательно, лишь для некоторых
классов сущностей. Варианты: DISABLE_SELECTIVE, ALL и NONE.
 Кэш второго уровня в Hibernate нужно подключать явно; по умолчанию он отключен.
Кэш результатов запросов также подключается отдельно; по умолчанию он отключен.
 Выбор реализации кэша второго уровня. Для использования Ehcache добавьте зависи-
мость от Maven-артефакта org.hibernate:hibernate-ehcache в путь к классам. Затем в на-
стройках фабрики для данной области кэширования выберите способ взаимодействия
Hibernate с Ehcache; здесь Hibernate будет использовать в качестве механизма кэширо-
вания второго уровня единственный экземпляр Ehcache.
 Hibernate передаст местоположение файла конфигурации механизму Ehcache во время
запуска. В этом файле находятся все настройки физических областей кэширования.
 Эта настройка управляет сборкой и разборкой экземпляров сущностей во время за-
грузки и сохранения в кэше второго уровня. Структурированный формат записей кэша
менее эффективен, но необходим для работы в условиях кластера. Для кэша второго
уровня, работающего вне кластера, такого как объект-одиночка Ehcache в данной виртуальной
машине JVM, можно отключить эту настройку для применения более эффек-
тивного формата.
 Экспериментируя с кэшем второго уровня, обычно требуется знать, что происходит
внутри.
В Hibernate есть механизм сбора статистики и средства ее извлечения. Из сооб-
ражений производительности он по умолчанию выключен (и должен оставаться таким
в рабочем окружении).
Теперь кэш второго уровня настроен, и Hibernate запустит Ehcache во время
создания объекта EntityManagerFactory для данной единицы хранения. По умолча-
нию Hibernate ничего не кэширует; для классов сущностей и их коллекций нужно
настраивать кэширование избирательно.
20.2.3. Кэширование коллекций и сущностей
Сейчас мы рассмотрим классы сущностей и коллекции из предметной модели
приложения CaveatEmptor и настроим кэширование, выбрав оптимальную стра-
тегию. Параллельно настроим необходимые физические области кэша в файле
конфигурации Ehcache.
Начнем с сущности User: эти данные меняются сравнительно редко, тем не ме-
нее пользователь может периодически менять свое имя или адрес. Это не важные
данные в финансовом отношении; немногие станут принимать решения о покупке
на основании имени пользователя или его адреса. Небольшой период рассогласо-
вания вполне допустим, если пользователь поменяет имя или адрес. Предполо-
жим, что если в течение максимум одной минуты другие транзакции будут видеть
устаревшую информацию, никаких проблем не возникнет. Это значит, что можно
применить стратегию кэширования NONSTRICT_READ_WRITE:
620  Масштабирование Hibernate
Файл: /model/src/main/java/org/jpwh/model/cache/User.java
@Entity
@Table(name = "USERS")
@Cacheable
@org.hibernate.annotations.Cache(
usage = org.hibernate.annotations
.CacheConcurrencyStrategy.NONSTRICT_READ_WRITE,
region = "org.jpwh.model.cache.User" Имя по умолчанию
)
@org.hibernate.annotations.NaturalIdCache
public class User {
@NotNull Не используется при генерации схемы из-за аннотации @NaturalId
@org.hibernate.annotations.NaturalId(mutable = true)
@Column(nullable = false) Для генерации схемы
protected String username;
// ...
}
Особенности Hibernate
Аннотация @Cacheable активирует общий кэш для этого класса сущности, но для
выбора стратегии нужно использовать аннотации Hibernate. Hibernate будет со-
хранять данные из сущности User в кэше второго уровня, в области с именем your.
packag.name.User. Переопределить имя можно с помощью атрибута region анно-
тации @Cache. (Также можно задать глобальный префикс для имени области с по-
мощью параметра hibernate.cache.region_prefix в настройках единицы хранения.)
Еще включим для сущности User кэш естественных идентификаторов, добавив
аннотацию @org.hibernate.annotations.NaturalIdCache. Свойства, определяющие
естественный идентификатор, отмечены аннотацией @org.hibernate.annotations.
NaturalId, и вы должны сообщить Hibernate, меняется ли значение каждого поля.
Это позволит выполнять поиск экземпляров User по полю username без обращения
к базе данных.
Далее в Ehcache нужно настроить области как для кэша данных сущности, так
и для кэша естественных идентификаторов:
Файл: /model/src/main/resources/cache/ehcache.xml
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd">
<cache name="org.jpwh.model.cache.User"
maxElementsInMemory="500"
eternal="false"
timeToIdleSeconds="30"
timeToLiveSeconds="60"/>
<cache name="org.jpwh.model.cache.User##NaturalId"
Добавляет ограничение
уникальности UNIQUE
Кэширование данных  621
maxElementsInMemory="500"
eternal="false"
timeToIdleSeconds="30"
timeToLiveSeconds="60"/>
</ehcache>
В каждом из кэшей можно хранить не более 500 записей, и Ehcache не будет
хранить их постоянно. Ehcache удалит элемент, если к нему не было обращений
в течение 30 секунд, а любой активный элемент он удалит через 1 минуту. Это
обеспечивает период рассогласования данных при чтении из кэша не более одной
минуты. Иначе говоря, области кэша будут содержать 500 последних использо-
вавшихся записей, каждая не старше 1 минуты, и они будут автоматически со-
кращаться.
Перейдем к классу сущности Item. Эти данные меняются часто, но читаются
гораздо чаще, чем записываются. Если поменялось название или описание товара,
параллельная транзакция должна немедленно увидеть это изменение. Пользова-
тели принимают финансовые решения о покупке товара на основании его описа-
ния. Следовательно, подходящей стратегией будет READ_WRITE:
Файл: /model/src/main/java/org/jpwh/model/cache/Item.java
@Entity
@Cacheable
@org.hibernate.annotations.Cache(
usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE
)
public class Item {
// ...
}
Hibernate будет согласовывать чтение и запись при изменении данных Item, га-
рантируя чтение из общего кэша только подтвержденных данных. Но если другое
приложение изменит данные Item прямо в базе, ждать можно чего угодно! Область
кэша в Ehcache настраивается так, чтобы последние использованные экземпляры
Item удалялись через час, чтобы не допустить заполнения ячеек кэша устаревши-
ми данными:
Файл: /model/src/main/resources/cache/ehcache.xml
<cache name="org.jpwh.model.cache.Item"
maxElementsInMemory="5000"
eternal="false"
timeToIdleSeconds="600"
timeToLiveSeconds="3600"/>
Рассмотрим коллекцию bids класса сущности Item: конкретный объект Bid
в коллекции Item#bids не меняется, но сама коллекция может, поэтому параллель-
ные единицы работы должны сразу же видеть все добавления и удаления:
622  Масштабирование Hibernate
Файл: /model/src/main/java/org/jpwh/model/cache/Item.java
public class Item {
@OneToMany(mappedBy = "item")
@org.hibernate.annotations.Cache(
usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE
)
protected Set<Bid> bids = new HashSet<>();
// ...
}
Область кэша настраивается с теми же параметрами, что и для класса сущно-
сти-владельца, поскольку каждый объект Item имеет коллекцию bids:
Файл: /model/src/main/resources/cache/ehcache.xml
<cache name="org.jpwh.model.cache.Item.bids"
maxElementsInMemory="5000"
eternal="false"
timeToIdleSeconds="600"
timeToLiveSeconds="3600"/>
Но помните, что кэш коллекции не хранит данных из объектов Bid. В кэше кол-
лекции хранятся только идентификаторы объектов Bid. Следовательно, необхо-
димо также настроить кэширование сущностей Bid. В противном случае во время
обхода коллекции Item#bids Hibernate будет сначала обращаться к кэшу, но затем,
из-за отсутствия данных, будет читать данные каждого отдельного объекта Bid из
базы. Это тот случай, когда включение кэширования увеличит нагрузку на сервер
базы данных!
Поскольку класс Bid неизменяемый, для него подойдет стратегия READ_ONLY:
Файл: /model/src/main/java/org/jpwh/model/cache/Bid.java
@Entity
@org.hibernate.annotations.Immutable
@Cacheable
@org.hibernate.annotations.Cache(
usage = CacheConcurrencyStrategy.READ_ONLY
)
public class Bid {
// ...
}
Хотя экземпляры Bid не изменяются, нужно настроить политику обновления
области кэша, чтобы устаревшие данные не заполнили кэш целиком:
Файл: /model/src/main/resources/cache/ehcache.xml
<cache name="org.jpwh.model.cache.Bid"
maxElementsInMemory="100000"
Кэширование данных  623
eternal="false"
timeToIdleSeconds="600"
timeToLiveSeconds="3600"/>
Теперь мы готовы проверить работу кэша и узнать, как работает кэширование
в Hibernate.
20.2.4. Проверка работы разделяемого кэша
Работу внутреннего кэширования в Hibernate бывает трудно проанализировать.
Для сохранения и загрузки данных по-прежнему используется EntityManager,
а Hibernate самостоятельно записывает данные в кэш и читает их из него. Ко-
нечно, обращения к базе данных можно увидеть, активировав журналирование
SQL-выражений Hibernate, но вам также стоит познакомиться с классом org.hibernate.
stat.Statistics, помогающим получить больше информации о единице
работы и происходящим за кулисами. Давайте на примерах посмотрим, как он
работает.
Мы уже настроили сбор статистики ранее, в конфигурации единицы хранения,
в разделе 20.2.2. Статистику единицы хранения можно получить с помощью org.
hibernate.SessionFactory:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
Statistics stats =
JPA.getEntityManagerFactory()
.unwrap(SessionFactory.class)
.getStatistics();
SecondLevelCacheStatistics itemCacheStats =
stats.getSecondLevelCacheStatistics(Item.class.getName());
assertEquals(itemCacheStats.getElementCountInMemory(), 3);
assertEquals(itemCacheStats.getHitCount(), 0);
Здесь мы также получаем статистику области кэша с данными сущностей Item,
и, как видите, в кэше уже есть несколько записей. Это теплый кэш; Hibernate по-
ложил данные в кэш, когда приложение сохраняло экземпляры сущностей Item.
Чтения сущностей из кэша, однако, не происходило, поэтому счетчик успешных
чтений равен нулю.
Если теперь выполнить поиск экземпляра Item по идентификатору, Hibernate
попытается прочитать данные из кэша, не выполняя SQL-выражения SELECT:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
Item item = em.find(Item.class, ITEM_ID);
assertEquals(itemCacheStats.getHitCount(), 1);
В кэше также имеются данные из сущностей User, поэтому при инициализации
коллекции Item#seller также произойдет чтение из кэша:
624  Масштабирование Hibernate
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
SecondLevelCacheStatistics userCacheStats =
stats.getSecondLevelCacheStatistics(User.class.getName());
assertEquals(userCacheStats.getElementCountInMemory(), 3);
assertEquals(userCacheStats.getHitCount(), 0);
User seller = item.getSeller();
assertEquals(seller.getUsername(), "johndoe"); Инициализация прокси-объекта
assertEquals(userCacheStats.getHitCount(), 1);
Hibernate будет использовать кэш также при обходе коллекции Item#bids:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
SecondLevelCacheStatistics bidsCacheStats =  Подсчет элементов коллекции Item#bids
stats.getSecondLevelCacheStatistics(Item.class.getName() + ".bids");
assertEquals(bidsCacheStats.getElementCountInMemory(), 3);
assertEquals(bidsCacheStats.getHitCount(), 0);
SecondLevelCacheStatistics bidCacheStats =  Подсчет элементов Bid
stats.getSecondLevelCacheStatistics(Bid.class.getName());
assertEquals(bidCacheStats.getElementCountInMemory(), 5);
assertEquals(bidCacheStats.getHitCount(), 0);
Set<Bid> bids = item.getBids();  Чтение из кэшей
assertEquals(bids.size(), 3);
assertEquals(bidsCacheStats.getHitCount(), 1);  Результаты обращения к кэшам
assertEquals(bidCacheStats.getHitCount(), 3);
 Статистика говорит о том, что в кэше находятся три коллекции Item#bids (по одной для
каждого объекта Item). Пока к кэшу не было успешных обращений.
 В кэше сущностей Bid есть пять записей, которые также еще не читались.
 Инициализация коллекции влечет чтение из обоих кэшей.
 Из кэша была прочитана одна коллекция, а также три ее элемента Bid.
Работа специального кэша естественных идентификаторов сущностей User не
полностью скрыта внутри. Для поиска по естественному идентификатору нужно
вызвать метод интерфейса org.hibernate.Session:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
NaturalIdCacheStatistics userIdStats =  Подсчет объектов User
stats.getNaturalIdCacheStatistics(User.class.getName() + "##NaturalId");
assertEquals(userIdStats.getElementCountInMemory(), 1);
User user = (User) session.byNaturalId(User.class)  Поиск по естественному идентификатору
.using("username", "johndoe")
.load();
assertNotNull(user);
Кэширование данных  625
assertEquals(userIdStats.getHitCount(), 1);  Естественный идентификатор найден
SecondLevelCacheStatistics userStats =  Сущность найдена
stats.getSecondLevelCacheStatistics(User.class.getName());
assertEquals(userStats.getHitCount(), 1);
 В области кэша естественных идентификаторов сущности User имеется одна запись.
 org.hibernate.Session выполняет поиск по естественному идентификатору; это един-
ственный API для работы с кэшем естественных идентификаторов.
 Поиск по естественному идентификатору завершился успехом. Кэш вернул идентифи-
катор для значения «johndoe».
 Поиск данных сущности User также оказался успешным.
API для работы со статистикой предлагает гораздо больше информации, чем
было показано в этих простых примерах; мы советуем глубже изучить его. Hibernate
собирает информацию обо всех операциях, и эта статистика может помочь
найти узкие места приложения: например, запросы, выполняющиеся дольше все-
го, или сущности и коллекции, к которым чаще всего происходит обращение.
Получение статистики с помощью JMX
Статистику Hibernate во время выполнения можно получать, используя стандарт-
ное расширение управления Java (Java Management Extension, JMX). Для этого
нужно лишь зарегистрировать объект Statistics в качестве экземпляра MBean;
с помощью динамического прокси-объекта для этого понадобится лишь несколько
строк кода. Мы добавили пример в org.jpwh.test.cache.SecondLevel.
Как упоминалось в начале этого раздела, Hibernate неявно записывает данные
в кэш и читает их из него. В некоторых случаях может понадобиться получить
больший контроль над использованием кэша либо явно отказаться от его исполь-
зования. Здесь в игру вступают режимы кэширования.
20.2.5. Установка режимов кэширования
JPA стандартизует управление общим кэшем с помощью нескольких режимов
кэширования. Следующий вызов EntityManager#find(), к примеру, не ищет данных
в кэше, а обращается к базе напрямую:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
Map<String, Object> properties = new HashMap<String, Object>();
properties.put("javax.persistence.cache.retrieveMode",
CacheRetrieveMode.BYPASS);
Item item = em.find(Item.class, ITEM_ID, properties); Обращение к базе данных
По умолчанию используется значение USE перечисления CacheRetrieveMode, от-
вечающего за режим чтения из кэша; здесь мы заменили его на BYPASS для выпол-
нения отдельной операции.
626  Масштабирование Hibernate
Но чаще для задания режима кэширования используются значения перечисле-
ния CacheStoreMode, отвечающего за сохранение в кэш. По умолчанию Hibernate
сохраняет данные в кэше при вызове EntityManager#persist(). То же самое про-
исходит при извлечении экземпляра сущности из базы. Но если сохраняется или
извлекается большое количество экземпляров сущностей, может наступить пере-
полнение кэша. Это особенно важно в случае пакетной обработки данных, пока-
занной ранее в этой главе.
Сохранение данных в разделяемом кэше сущностей можно отключить для всей
единицы работы, передав значение перечисления CacheStoreMode объекту Entity-
Manager:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
em.setProperty("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
Item item = new Item(
// ...
);
em.persist(item); Не сохраняется в кэш
Давайте рассмотрим особый режим кэширования – CacheStoreMode.REFRESH.
При загрузке экземпляра сущности из базы по умолчанию выбирается режим
CacheStoreMode.USE, и Hibernate сначала пытается найти загружаемый экземпляр
сущности в кэше. Затем, если кэш уже содержит то, что нужно, Hibernate не со-
хранит загруженных данных в кэш. Это позволяет избежать записи в кэш и удеше-
вить операцию чтения из кэша. Работая в режиме REFRESH, Hibernate всегда будет
сохранять загружаемые данные в кэш, не читая его перед этим.
В кластере с синхронным распределенным кэшированием запись в каждый из
узлов кэша часто является довольно дорогостоящей операцией. Фактически, ис-
пользуя распределенный кэш, вы должны установить значение параметра кон-
фигурации hibernate.cache.use_minimal_puts в true. Это позволяет оптимизиро-
вать операции с кэшем второго уровня путем уменьшения количества операций
записи,
но ценой большего количества операций чтения. С другой стороны, если
для вашего механизма кэширования и архитектуры нет разницы между чтени-
ем и записью, можно избавиться от дополнительного чтения с помощью режима
CacheStoreMode.REFRESH. (Обратите внимание, что некоторые механизмы кэширо-
вания могут устанавливать значение параметра use_minimal_puts самостоятельно:
например, в Ehcache эта настройка по умолчанию активна.)
Как вы уже видели, режим кэширования может устанавливаться для метода
find() или для всего объекта EntityManager. Также можно задать режим для опера-
ции refresh() или для отдельного запроса Query, как обсуждалось в разделе 14.5.
Режим отдельного запроса или метода переопределяет режим, установленный для
EntityManager.
Режим кэширования влияет лишь на внутреннюю работу Hibernate с кэшем. Но
иногда может понадобиться управлять кэшем программно: например, для удале-
ния данных из него.
Кэширование данных  627
20.2.6. Управление разделяемым кэшем
Стандартный инструмент JPA для управления кэшем – интерфейс Cache:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
EntityManagerFactory emf = JPA.getEntityManagerFactory();
Cache cache = emf.getCache();
assertTrue(cache.contains(Item.class, ITEM_ID));
cache.evict(Item.class, ITEM_ID);
cache.evict(Item.class);
cache.evictAll();
Это простой API, который позволяет обращаться только к областям кэша с дан-
ными сущностей. Для доступа к другим областям, таким как области коллекций
или естественных идентификаторов, нужно использовать org.hibernate.Cache:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
org.hibernate.Cache hibernateCache =
cache.unwrap(org.hibernate.Cache.class);
assertFalse(hibernateCache.containsEntity(Item.class, ITEM_ID));
hibernateCache.evictEntityRegions();
hibernateCache.evictCollectionRegions();
hibernateCache.evictNaturalIdRegions();
hibernateCache.evictQueryRegions();
Этот механизм управления редко бывает полезен. Также обратите внимание,
что удаление записей из кэша второго уровня происходит вне транзакции: т. е.
Hibernate не блокирует областей кэша во время удаления.
Перейдем к последней части системы кэширования в Hibernate – кэшу резуль-
татов запроса.
20.2.7. Кэш результатов запросов
Кэш результатов запроса по умолчанию выключен, и любой запрос на основе кри-
териев, JPA-запрос или обычный запрос SQL обращается непосредственно к базе
данных. В этом разделе мы покажем, почему Hibernate по умолчанию не исполь-
зует кэша результатов запросов и как включить его для конкретных запросов, если
потребуется.
Следующая процедура выполняет запрос JPQL, сохраняя результат в особой
области кэша результатов запросов:
Файл: /examples/src/test/java/org/jpwh/test/cache/SecondLevel.java
String queryString = "select i from Item i where i.name like :n";
Query query = em.createQuery(queryString)  Включение кэширования
.setParameter("n", "I%")
.setHint("org.hibernate.cacheable", true);
List<Item> items = query.getResultList();  Выполнение запроса
628  Масштабирование Hibernate
assertEquals(items.size(), 3);
QueryStatistics queryStats = stats.getQueryStatistics(queryString);
assertEquals(queryStats.getCacheHitCount(), 0);
assertEquals(queryStats.getCacheMissCount(), 1);
assertEquals(queryStats.getCachePutCount(), 1);
SecondLevelCacheStatistics itemCacheStats =  Сохранение данных в кэше сущностей
stats.getSecondLevelCacheStatistics(Item.class.getName());
assertEquals(itemCacheStats.getElementCountInMemory(), 3);
 Нужно включить кэширование для конкретного запроса. Без рекомендации org.hibernate.
cachable результат не будет помещен в кэш результатов запроса.
 Hibernate выполняет запрос SQL, извлекая результат запроса в память.
 Нужную информацию можно получить, используя механизм сбора статистики. По-
скольку запрос выполняется впервые, кэш обнаружит промах. Hibernate поместит за-
прос с результатами в кэш. Если выполнить этот запрос снова, результат уже вернется из
кэша.
 Данные экземпляра сущности, полученные в виде результата запроса, будут сохранены
в области кэша сущностей, а не в кэше результатов запроса.
Рекомендация org.hibernate.cachable передается Query API, поэтому она будет
работать и с обычными запросами SQL, и с запросами на основе критериев. Внутри,
в качестве ключа кэша Hibernate использует сам запрос SQL, в котором сим-
волы подстановки заменены фактическими аргументами.
Кэш результатов запросов не хранит результатов целиком. В последнем приме-
ре результаты содержали данные из таблицы ITEM. Hibernate игнорирует большую
часть информации в этом результате; в кэше сохранятся только значения атрибута
ID для каждой строки таблицы ITEM. Значения полей каждого экземпляра Item со-
хранятся в области кэша данных сущностей.
Если теперь выполнить тот же запрос, подставляя те же значения аргументов
для параметров, Hibernate сначала обратится к кэшу результатов запроса. Он из-
влечет значения идентификаторов записей ITEM из области кэша данных запро-
са. Затем выполнит поиск по идентификатору и сборку экземпляров сущностей
Item, обращаясь к области кэша данных сущностей. Если вы решили применить
кэширование для запросов, извлекающих сущности, не забудьте включить обыч-
ное кэширование для этих сущностей. В противном случае вы получите больше
обращений к базе данных после подключений кэша результатов запроса!
Если кэшировать запросы, возвращающие скалярные или встраиваемые значе-
ния, а не экземпляры сущностей (например, select i.name from Item i или select
u.homeAddress from User), эти значения будут храниться прямо в области кэша ре-
зультатов запроса.
Кэш результатов запроса состоит из двух физических областей:
Файл: /model/src/main/resources/cache/ehcache.xml
<cache name="org.hibernate.cache.internal.StandardQueryCache"
maxElementsInMemory="500"
 Получение
информации
Кэширование данных  629
eternal="false"
timeToIdleSeconds="600"
timeToLiveSeconds="3600"/>
<cache name="org.hibernate.cache.spi.UpdateTimestampsCache"
maxElementsInMemory="50"
eternal="true"/>
В первой области хранятся результаты запроса. Вы должны обеспечить удале-
ние записей по истечении определенного времени, чтобы свободное место исполь-
зовалось для самых последних запросов.
Вторая область, org.hibernate.cache.spi.UpdateTimestampsCache, играет особую
роль: Hibernate использует ее, чтобы определить, когда устареют результаты запро-
са в кэше. Если повторно выполнить запрос с активным кэшированием, Hibernate
проверит область меток времени, чтобы узнать о самом последнем добавлении, из-
менении или удалении, сделанном в таблице (таблицах), участвующей в запросе.
Если найденная метка времени больше метки последнего сохраненного результата,
Hibernate избавится от него и выполнит новый запрос к базе данных. Это гаран-
тирует, что Hibernate не будет использовать результатов кэша запросов, если хотя
бы одна из таблиц содержит обновленные данные; следовательно, результат в кэше
мог устареть. Чтобы механизм кэширования всегда хранил устаревшие записи
в кэше меток времени, нужно отключить их удаление. Максимальное количество
записей в этой области кэша определяется числом таблиц в отображаемой модели.
Большинство запросов ничего не выиграет от кэширования. Это может пока-
заться удивительным. В конце концов, уменьшение количества обращений к базе
данных – это всегда хорошо. Но есть две причины, из-за которых кэширование
произвольных запросов не всегда работает, в отличие от поиска сущности по иден-
тификатору или инициализации коллекции.
Во-первых, нужно понимать, как часто этот запрос будет выполняться с одними
и теми же аргументами. Очевидно, что приложение может последовательно вы-
полнять несколько запросов с одинаковыми аргументами, связанными с параметрами,
и одинаковым текстом запроса SQL. Мы считаем, такое встречается редко,
но если вы уверены, что запрос будет выполняться повторно, он станет отличным
кандидатом для кэширования результатов.
Во-вторых, для приложений, выполняющих много запросов, но мало вставок,
изменений и удалений, кэширование результатов запросов может улучшить про-
изводительность и масштабирование. С другой стороны, если приложение дела-
ет много записей, Hibernate не сможет эффективно использовать результаты из
кэша. Кэш результатов запросов очищается после любой вставки, удаления или
обновления в таблице, записи которой попали в кэш. Это значит, что результаты
могут находиться в кэше очень недолго, и даже при повторном выполнении запро-
са Hibernate не будет использовать результаты кэша из-за параллельных измене-
ний в таблицах, строки которых попали в кэш.
Для большинства запросов польза от кэширования результатов несущественна
или не приносит ожидаемого эффекта. Но если ограничение в запросе использует
630  Масштабирование Hibernate
естественный идентификатор, как, например, select u from User u where u.username
= ?, мы советуем использовать кэширование естественных идентификаторов, как
было показано ранее в этой главе.
20.3. Резюме
 Вы узнали возможности масштабирования приложений и способы взаимодей-
ствий с большими наборами данных и параллельно работающими пользова-
телями.
 Используя массовые операции UPDATE и DELETE, можно изменять данные прямо
в базе, не теряя преимуществ JPQL и запросов на основе критериев и не ис-
пользуя обычного SQL.
 Вы узнали про пакетные операции с данными, позволяющие обрабатывать
большие количества записей на уровне приложения.
 Мы подробно рассмотрели систему кэширования Hibernate: выборочное при-
менение и оптимизацию общего кэша сущностей, коллекций и результатов за-
просов.
 Мы настроили Ehcache как механизм кэширования и узнали, как получать ин-
формацию о работе Hibernate с помощью API для сбора статистики.
Библиография
1. Ambler S. W. 2002. Data Modeling 101. Agile Data // www.agiledata.org/essays/dataModeling101.
html.
2. Bernard E. 2008. Hibernate Search in Action. Manning Publications.
3. Bloch J. 2008. Effective Java. 2nd ed. Prentice Hall. (Блох Д. Java. Эффективное програм-
мирование. М.: Лори, 2016. ISBN: 978-5-85582-348-6. – Прим. ред.)
4. Booch G., Rumbaugh J., Jacobson I. 2005. The Unified Modeling Language User Guide.
2nd ed. Addison-Wesley Professional.
5. Codd E. F. 1970. A Relational Model of Data for Large Shared Data Banks. Communications
of the ACM 13 (6): 377-87 // www.acm.org/classics/nov95/toc.html.
6. Date C. J. 2003. An Introduction to Database Systems. 8th ed. Addison-Wesley. (Дейт К. Дж.
Введение в системы баз данных. 8-е изд. М.: Вильямс, 2005. ISBN: 5-8459-0788-8. –
Прим. ред.)
7. Date C. J. 2009. SQL and Relational Theory. O’Reilly Media. (Дейт К. Дж. SQL и реля-
ционная теория. Как грамотно писать код на SQL. СПб.: Символ-Плюс, 2010. ISBN:
978-5-93286-173-8. – Прим. ред.)
8. Fowler M. 1999. Refactoring: Improving the Design of Existing Code. Addison-Wesley Professional.
(Фаулер М., Бек К., Брант Дж., Робертс Д., Апдайк У. Рефакторинг: улучшение
существующего кода. СПб.: Символ-Плюс, 2009. ISBN: 5-93286-045-6. – Прим. ред.)
9. Fowler M. 2003. Patterns of Enterprise Application Architecture. Addison-esley Professional.
(Фаулер М. Шаблоны корпоративных приложений. М.: Вильямс, 2009. ISBN:
978-5-8459-1611-2. – Прим. ред.)
10. Gamma E., Helm R., Johnson R., Vlissides J. 1995. Design Patterns: Elements of Reusable
Object-Oriented Software. Addison-Wesley Professional. (Гамма Э., Хелм Р., Джонсон Р.,
Влиссидес Дж. Приемы объектно-ориентированного проектирования. М.: ДМК Пресс,
2011. ISBN: 978-5-9370-0023-1. – Прим. ред.)
11. Karwin B. 2010. SQL Antipatterns: Avoiding the Pitfalls of Database Programming. The
Pragmatic Bookshelf. (Карвин Б. Программирование баз данных SQL. М.: Рид Групп,
2011. ISBN: 978-5-4252-0510-0. – Прим. ред.)
12. Morgan T. D. 2010. Weaning the Web off of Session Cookies: Making Digest Authentication
Viable. Virtual Security Research // www.vsecurity.com/download/papers/WeaningTheWebOffOfSessionCookies.
pdf.
13. Pascal F. 2000. Practical Issues in Database Management: A Reference for the Thinking
Practitioner. Addison-Wesley Professional.
14. Richardson L., Amundsen М., Ruby S. 2013. RESTful Web APIs. O’Reilly Media.
15. Shute J., et al. 2012. F1 – The Fault-Tolerant Distributed RDBMS Supporting Google’s Ad
Business. Research at Google // http://research.google.com/pubs/pub38125.html.
16. Tow D. 2003. SQL Tuning. O’Reilly Media. (Тоу Д. Настройка SQL: для профессионалов.
СПб.: Питер, 2004. ISBN: 5-94723-959-0. – Прим. ред.)
17. Walls C., Richards N. 2004. XDoclet in Action. Manning Publications.
18. Watterson B. 1992. The Indispensable Calvin and Hobbes: A Calvin and Hobbes Treasury.
Andrews McMeel Publishing.
Книги издательства «ДМК Пресс» можно заказать
в торгово-издательском холдинге «Планета Альянс» наложенным платежом,
выслав открытку или письмо по почтовому адресу:
115487, г. Москва, 2-й Нагатинский пр-д, д. 6А.
При оформлении заказа следует указать адрес (полностью),
по которому должны быть высланы книги;
фамилию, имя и отчество получателя.
Желательно также указать свой телефон и электронный адрес.
Эти книги вы можете заказать и в интернет-магазине: www.alians-kniga.ru.
Оптовые закупки: тел. (499) 782-38-89.
Электронный адрес: books@alians-kniga.ru.