После этого следующий запрос будет совместим с JPA. Как обычно, ключевое
слово as является необязательным. Следующий запрос аналогичен предыдущему:
select i from Item i
Извлекаемым экземплярам класса Item присваивается псевдоним i. Это похоже
на объявление временной переменной в следующем коде на Java:
for(Iterator i = result.iterator(); i.hasNext();) {
Item item = (Item) i.next();
// ...
}
Псевдонимы в запросах нечувствительны к регистру, поэтому запрос select
iTm from Item itm также будет работать. Мы предпочитаем использовать короткие
и простые псевдонимы; они должны быть уникальными в пределах запроса (или
подзапроса).
Переносимые запросы на основе критериев должны вызывать метод select():
CriteriaQuery criteria = cb.createQuery();
Root<Item> i = criteria.from(Item.class);
criteria.select(i);
В большинстве примеров с использованием запросов на основе критериев мы
будем убирать строку cb.createQuery(); она всегда выглядит одинаково. Каждый
раз, встречая переменную criteria, знайте, что она получена с помощью вызова
CriteriaBuilder#createQuery(). Как получить экземпляр CriteriaBuilder, расска-
зывалось в предыдущей главе.
Экземпляр Root всегда ссылается на сущность. Позже вы увидите запросы с не-
сколькими корневыми элементами. Этот запрос можно записать короче, если не
создавать дополнительной переменной типа Root:
criteria.select(criteria.from(Item.class));
Тип сущности также можно указать динамически, с помощью Metamodel API:
EntityType entityType = getEntityType(
em.getMetamodel(), "Item"
);
criteria.select(criteria.from(entityType));
Выборка  427
Мы написали метод getEntityType() исключительно для удобства: он обходит
все экземпляры коллекции Metamodel#getEntities() и находит сущность с соответ-
ствующим именем.
Сущность Item не имеет подклассов, поэтому в следующем разделе мы рассмотрим
полиморфные запросы.
15.1.2. Полиморфные запросы
JPQL, как и подобает объектно-ориентированному языку запросов, поддерживает
полиморфные запросы, извлекающие не только экземпляры класса, но и все экзем-
пляры подклассов. Рассмотрим следующие запросы:
select bd from BillingDetails bd
criteria.select(criteria.from(BillingDetails.class));
Они возвращают все экземпляры типа BillingDetails, который сам является аб-
страктным классом. В этом случае каждый экземпляр будет относиться к одному
из подтипов BillingDetails: CreditCard или BankAccount. Чтобы получить только
экземпляры конкретного подкласса, можно написать следующий запрос:
select cc from CreditCard cc
criteria.select(criteria.from(CreditCard.class));
Класс, указанный в предложении FROM, не обязан быть отображаемым храни-
мым классом; подойдет любой класс. Следующий запрос возвращает все сохра-
ненные объекты:
select o from java.lang.Object o
Особенности Hibernate
Да, вы можете выбрать записи из всех таблиц базы данных и загрузить их в па-
мять! Это работает и с интерфейсами – можно, к примеру, выбрать все сериализуемые
экземпляры:
select s from java.io.Serializable s
Плохая новость в том, что JPA не стандартизует полиморфных запросов JPQL
с использованием интерфейсов. Они работают только в Hibernate, но переноси-
мое приложение должно ссылаться в предложении FROM лишь на отображаемые
классы сущностей, такие как BillingDetails или CreditCard. Метод from() из API
запросов на основе критериев принимает только типы отображаемых сущностей.
Можно выполнить неполиморфный запрос, ограничив набор возвращаемых
типов с помощью функции TYPE. Чтобы извлечь только экземпляры конкретного
подкласса, можно выполнить такой запрос:
428  Языки запросов
select bd from BillingDetails bd where type(bd) = CreditCard
Root<BillingDetails> bd = criteria.from(BillingDetails.class);
criteria.select(bd).where(
cb.equal(bd.type(), CreditCard.class)
);
Для параметризации этого запроса нужно добавить предложение IN с имено-
ванным параметром:
select bd from BillingDetails bd where type(bd) in :types
Root<BillingDetails> bd = criteria.from(BillingDetails.class);
criteria.select(bd).where(
bd.type().in(cb.parameter(List.class, "types"))
);
Связывание аргумента с параметром запроса происходит во время передачи
списка (List) возвращаемых типов:
Query query = // ...
query.setParameter("types", Arrays.asList(CreditCard.class,
BankAccount.class));
Чтобы выбрать все экземпляры подкласса, кроме конкретного класса, можно
выполнить следующий запрос:
select bd from BillingDetails bd where not type(bd) = BankAccount
Root<BillingDetails> bd = criteria.from(BillingDetails.class);
criteria.select(bd).where(
cb.not(cb.equal(bd.type(), BankAccount.class))
);
Полиморфизм в запросах применяется не только к конкретным классам, но
и к полиморфным ассоциациям, как вы увидите далее.
На этом мы заканчиваем описание первого этапа создания запросов – определе-
ние выборки. Мы определили таблицы, из которых будем извлекать данные. Далее
вам может понадобиться уменьшить количество извлекаемых записей с помощью
ограничения.
15.2. Ограничения
Как правило, извлекать все экземпляры класса из базы данных не требуется. По-
этому вы должны уметь описывать критерии отбора данных, возвращаемых за-
просом. Такие описания мы называем ограничениями. В SQL и JPQL ограничения
описываются с помощью предложения WHERE, а в API на основе критериев анало-
гичную функцию выполняет метод where().
Ограничения  429
Ниже показан пример типичного предложения WHERE, ограничивающего набор
результатов только экземплярами Item с конкретным именем.
select i from Item i where i.name = 'Foo'
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.equal(i.get("name"), "Foo")
);
Ограничение в запросе выражается в терминах поля name класса Item.
Ниже показан код SQL, сгенерированный данным запросом:
select i.ID, i.NAME, ... from ITEM i where i.NAME = 'Foo'
В выражениях и условиях можно использовать строковые литералы, заклю-
чая их в одиночные кавычки. Для литералов, представляющих дату, время и мет-
ки времени, нужно использовать синтаксис экранирования JDBC: ... where
i.auctionEnd = {d '2013-26-06'}. Обратите внимание, что способ обработки такого
литерала, а также различные варианты его написания определяются драйвером
JDBC и СУБД. И не забудьте совет из предыдущей главы: не внедряйте непрове-
ренных входных данных пользователя в строку запроса – используйте параметры.
В JDBC также часто встречаются литералы true и false:
select u from User u where u.activated = true
Root<User> u = criteria.from(User.class);
criteria.select(u).where(
cb.equal(u.get("activated"), true)
);
В SQL (а также в JPQL и запросах на основе критериев) ограничения описыва-
ются с помощью троичной логики. Предложение WHERE – это логическое выраже-
ние, результатом которого может быть true, false или null.
Что такое троичная логика?
Запись будет добавлена в результат SQL-запроса тогда и только тогда, когда вы-
ражение в предложении WHERE вернет true. В языке Java результатом выражения
nonNullObject == null является false, а null == null – true. В языке SQL оба выра-
жения – NOT_NULL_COLUMN = null и null = null – вернут null, а не true. Поэтому для
проверки выражения на равенство null в SQL приходится использовать дополни-
тельные операторы IS NULL и IS NOT NULL. Троичная логика нужна для работы с вы-
ражениями со столбцами, которые могут содержать null. Интерпретируйте null
не как специальную метку, а как обычное значение – это расширение знакомой
двоичной логики реляционной модели в языке SQL. Hibernate поддерживает тро-
ичную логику с помощью троичных операторов как в JPQL, так и в запросах на
основе критериев.
430  Языки запросов
Рассмотрим наиболее распространенные операторы сравнения в логических
выражениях, включая троичные операторы.
15.2.1. Выражения сравнения
JQPL и API запросов на основе критериев поддерживают такой же набор опера-
торов сравнения, как и SQL. Ниже представлено несколько примеров, которые
должны быть знакомы всем, кто знает язык SQL.
Следующий запрос возвращает все ставки с ценой в заданном диапазоне:
select b from Bid b where b.amount between 99 and 110
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.between(
b.<BigDecimal>get("amount"), Нужно указать тип атрибута
new BigDecimal("99"), new BigDecimal("110") Аргументы должны быть того же типа
)
);
Запрос на основе критериев может показаться несколько странным; вероят-
но, вы нечасто видите параметризацию в середине выражений на Java. Метод
Root#get() возвращает объект Path<X>, описывающий путь к атрибуту сущности.
Для обеспечения типобезопасности требуется явно указать тип атрибута для этого
пути Path, как в выражении <BigDecimal>get("amount"). Два оставшихся аргумента
метода between() должны иметь тот же тип, иначе сравнение будет бессмысленным
или вовсе не скомпилируется.
Следующий запрос возвращает все ставки с ценой выше заданной:
select b from Bid b where b.amount > 100
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.gt(
b.<BigDecimal>get("amount"),
new BigDecimal("100")
)
);
Метод gt() принимает только аргументы подтипов Number, таких как BigDecimal
или Integer. Чтобы сравнить значения других типов, например Date, используйте
метод greaterThan():
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.greaterThan(
i.<Date>get("auctionEnd"),
tomorrowDate
)
);
Метод gt() работает только с подклассами Number;
для других типов используйте метод greaterThan()
Ограничения  431
Следующий запрос возвращает всех пользователей с именами «johndoe»
и «janeroe».
select u from User u where u.username in ('johndoe', 'janeroe')
Root<User> u = criteria.from(User.class);
criteria.select(u).where(
cb.<String>in(u.<String>get("username"))
.value("johndoe")
.value("janeroe")
);
В ограничениях с перечислениями следует указывать полное квалифицирован-
ное значение:
select i from Item i
where i.auctionType = org.jpwh.model.querying.AuctionType.HIGHEST_BID
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.equal(
i.<AuctionType>get("auctionType"),
AuctionType.HIGHEST_BID
)
);
Из-за того, что SQL использует троичную логику, проверка значений на равен-
ство null требует специального подхода. JPQL предоставляет операторы IS [NOT]
NULL, а в API запросов на основе критериев – методы isNull() и isNotNull().
В следующем запросе IS NULL и isNull() используются для поиска товаров без
текущей цены:
select i from Item i where i.buyNowPrice is null
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.isNull(i.get("buyNowPrice"))
);
Используя IS NOT NULL и isNotNull(), можно получить все товары с указанной
текущей ценой:
select i from Item i where i.buyNowPrice is not null
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.isNotNull(i.get("buyNowPrice"))
);
Оператор LIKE позволяет организовать поиск, в котором часть шаблона может
быть произвольной; как и в SQL, для этого применяются символы % и _:
432  Языки запросов
select u from User u where u.username like 'john%'
Root<User> u = criteria.from(User.class);
criteria.select(u).where(
cb.like(u.<String>get("username"), "john%")
);
Выражение john% истинно только для пользователей, имена которых начина-
ются со строки «john». Также с оператором LIKE можно использовать отрицание:
select u from User u where u.username not like 'john%'
Root<User> u = criteria.from(User.class);
criteria.select(u).where(
cb.like(u.<String>get("username"), "john%").not()
);
Можно выполнить поиск всех вхождений подстроки, окружив искомую строку
символами процента:
select u from User u where u.username like '%oe%'
Root<User> u = criteria.from(User.class);
criteria.select(u).where(
cb.like(u.<String>get("username"), "%oe%")
);
Символ процента означает «произвольная последовательность символов»; под-
черкивание – «произвольный символ». Если понадобится использовать литералы
процента и подчеркивания, их можно экранировать любым символом:
select i from Item i
where i.name like 'Name\_with\_underscores' escape :escapeChar
query.setParameter("escapeChar", "\\");
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.like(i.<String>get("name"), "Name\\_with\\_underscores", '\\')
);
Эти запросы найдут товар с именем имя_с_подчеркиваниями. В строках языка Java
для экранирования используется символ \, который тоже нужно экранировать,
поэтому в предыдущем примере этот символ удвоен.
JPA также поддерживает арифметические выражения:
select b from Bid b where (b.amount / 2) - 0.5 > 49
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.gt(
cb.diff(
cb.quot(b.<BigDecimal>get("amount"), 2),
0.5
Ограничения  433
),
49
)
);
Выражения объединяются с помощью логических операторов (и группирую-
щих скобок):
select i from Item i
where (i.name like 'Fo%' and i.buyNowPrice is not null)
or i.name = 'Bar'/
Root<Item> i = criteria.from(Item.class);
Predicate predicate = cb.and(
cb.like(i.<String>get("name"), "Fo%"),
cb.isNotNull(i.get("buyNowPrice"))
);
predicate = cb.or(
predicate,
cb.equal(i.<String>get("name"), "Bar")
);
criteria.select(i).where(predicate);
Особенности Hibernate
Если нужно объединить все предикаты с помощью логического И, для этого мы
выбираем более удобный API запросов на основе критериев:
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.like(i.<String>get("name"), "Fo%"),
// и
cb.isNotNull(i.get("buyNowPrice"))
// и ...
);
Ниже, в табл. 15.1, перечислены все операторы в порядке убывания приоритета.
Таблица 15.1. Приоритет операторов JPQL
Оператор JPQL
API запросов
на основе критериев
Описание
. Н/А Оператор в выражении,
описывающем путь к атрибуту
+, - neg() Унарный плюс или минус
(все беззнаковые числовые значения
считаются положительными)
434  Языки запросов
Таблица 15.1 (окончание)
Оператор JPQL API запросов
на основе критериев Описание
*, / prod(), quot() Умножение и деление числовых
выходых параметров
+, - sum(), diff() Сложение и вычитание числовых
выходых параметров
=, <>, <, >, >=, < equal(), notEqual(), lessThan(),
lt(), greaterThan(), gt(),
greaterThanEqual(), ge(),
lessThan(), lt()
Операторы сравнения с семантикой
SQL
[NOT] BETWEEN, [NOT] LIKE,
[NOT] IN, IS [NOT] NULL
between(), like(), in(),
isNull(), isNotNull()
Операторы сравнения с семантикой
SQL
IS [NOT] EMPTY, [NOT] isEmpty(), isNotEmpty(),
isMember(), isNotMember()
Операторы для хранимых коллекций
MEMBER [OF] NOT, AND, OR not(), and(), or() Логические операторы для управле-
ния порядком вычислений
Вы уже знаете, что двухместные операторы сравнения обладают такой же се-
мантикой, как их аналоги в SQL, и могут группироваться и упорядочиваться с по-
мощью логических операторов. Давайте посмотрим на работу с коллекциями.
15.2.2. Выражения с коллекциями
В каждом выражении из предыдущего раздела были только пути к атрибутам,
имеющим единственное значение: user.username, item.buyNowPrice и т. д. Но можно
также написать выражение, указывающее на коллекцию, и применить к ней неко-
торые операторы и функции.
Предположим, к примеру, что требуется найти все категории – экземпляры
Catergory, – имеющие хотя бы один товар в коллекции items:
select c from Category c
where c.items is not empty
Root<Category> c = criteria.from(Category.class);
criteria.select(c).where(
cb.isNotEmpty(c.<Collection>get("items"))
);
Результат выражения c.items в запросе JPQL ссылается на коллекцию items
экземпляра Category. Обратите внимание, что нельзя обращаться к атрибутам эле-
ментов коллекции в подобном выражении: нельзя написать c.items.buyNowPrice.
Отфильтровать категории по количеству входящих в них товаров можно, ис-
пользуя функцию size():
select c from Category c
where size(c.items) > 1
Root<Category> c = criteria.from(Category.class);
Ограничения  435
criteria.select(c).where(
cb.gt(
cb.size(c.<Collection>get("items")),
1
)
);
Также можно найти категорию, содержащую конкретный товар:
select c from Category c
where :item member of c.items
Root<Category> c = criteria.from(Category.class);
criteria.select(c).where(
cb.isMember(
cb.parameter(Item.class, "item"),
c.<Collection<Item>>get("items")
)
);
Для хранимых словарей определены дополнительные операторы key(), value()
и entry(). Предположим, что каждый экземпляр Item (товар) имеет хранимый
словарь встроенных объектов Image (изображений), как показано в разделе 7.2.4.
Имена файлов изображений являются ключами словаря. Следующий запрос из-
влекает все экземпляры Image с именами, оканчивающимися на .jpg:
select value(img)
from Item i join i.images img
where key(img) like '%.jpg'
Оператор value() возвращает значения из словаря Map, а оператор key() – набор
ключей. Для получения записей из словаря – экземпляров Map.Entry – используй-
те оператор entry().
Рассмотрим далее оставшиеся функции, применимые не только к коллекциям.
15.2.3. Вызовы функций
Возможность вызова функций в предложении WHERE – одна из самых сильных сто-
рон языков запросов. Следующие запросы вызывают функцию lower() для поиска
подстроки без учета регистра:
select i from Item i where lower(i.name) like 'ba%'
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.like(cb.lower(i.<String>get("name")), "ba%")
);
Все доступные функции перечислены в табл. 15.2. Запросы на основе крите-
риев имеют аналогичные методы в CriteriaBuilder, лишь немного отличающиеся
способом записи имен (используется «верблюжийРегистр» без подчеркиваний).
436  Языки запросов
Таблица 15.2. Функции запросов JPA (перегруженные методы не показаны)
Функция Область применения
upper(s), lower(s) Строковые значения; возвращает строку
concat(s, s) Строковые значения; возвращает строку
current_date, current_time,
current_timestamp
Возвращает дату и/или время на сервере управления базами
данных
substring(s, offset, length) Строковые значения (смещение начинается с 1); возвращает
строку
trim([[both|leading|trailing]
char [from]] s)
Удаляет пробелы с обеих (both) сторон строки s, если не указан
иной символ char или не заданы другие правила; возвращает
строку
length(s) Строковое значение; возвращает число
locate(search, s, offset) Возвращает позицию подстроки search в строке s, начиная
поиск с позиции offset; возвращает числовое значение
abs(n), sqrt(n), mod(dividend,
divisor)
Числовые значения; возвращает абсолютное значение того же
типа, что и аргумент, квадратный корень как Double и остаток от
деления как Integer
treat(x as Type) Приведение типа к подтипу в ограничениях; например, когда
нужно найти всех пользователей с кредитными картами, срок
действия которых заканчивается в 2013: select u from User u
where treat(u.billingDetails as CreditCard).expYear = '2013'.
(Обратите внимание, что это необязательно делать
в Hibernate. Он автоматически выполнит приведение типа
к подтипу, если используется поле подкласса)
size(c) Коллекция выражений; возвращает Integer или 0, когда
коллекция пуста
index(orderedCollection) Выражение, возвращающее коллекцию, отображаемую
с помощью @OrderColumn; возвращает значение типа Integer,
соответствующее позиции аргумента в коллекции. Например,
запрос select i.name from Category c join c.items i where index(i)
= 0 вернет названия для каждого первого товара в каждой
категории
Особенности Hibernate
Как показано в табл. 15.3, Hibernate поддерживает дополнительные функции для
JPQL. Стандартный JPA API запросов на основе критериев не имеет аналогов этих
функций.
Таблица 15.3. Функции запросов Hibernate
Функция Описание
bit_length(s) Возвращает количество бит в s
second(d), minute(d), hour(d),
day(d), month(d), year(d)
Извлекает время и дату из аргумента, представляющего
время
minelement(c), maxelement(c),
minindex(c), maxindex(c),
elements(c), indices(c)
Возвращает элемент коллекции или индекс для коллекций,
поддерживающих индексирование (словарей, списков,
массивов)
str(x) Выполняет приведение аргумента к строковому типу
Ограничения  437
Большинство этих функций транслируется в соответствующие функции SQL,
которые вы видели ранее. Также можно вызывать функции SQL, поддерживаемые
вашей СУБД и не показанные здесь.
Особенности Hibernate
Любая функция, встреченная в предложении WHERE запроса JPQL и неизвестная
Hibernate, передается напрямую в базу данных в виде вызова функции SQL. Сле-
дующий запрос, например, вернет товары, аукцион для которых длился больше
одного дня:
select i from Item i
where
datediff('DAY', i.createdOn, i.auctionEnd)
> 1
Здесь вызывается нестандартная функция datediff(), доступная в базе данных
H2, возвращающая разницу в днях между датами создания товара и окончания
аукциона для данного экземпляра Item. Такой синтаксис может использоваться
только с Hibernate; в JPA для вызова произвольных функций SQL стандартизован
следующий синтаксис:
select i from Item i
where
function('DATEDIFF', 'DAY', i.createdOn, i.auctionEnd)
> 1
Первый аргумент функции function() – имя вызываемой функции SQL в оди-
нарных кавычках. За ним должны следовать необходимые операнды, если имеют-
ся. Такой же запрос, но на основе критериев:
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(
cb.gt(
cb.function(
"DATEDIFF",
Integer.class,
cb.literal("DAY"),
i.get("createdOn"),
i.get("auctionEnd")
),
1
)
);
Аргумент Integer.class определяет тип возвращаемого значения функции
datediff(), но здесь он бесполезен, поскольку результат вызова функции в огра-
ничении не возвращается.
438  Языки запросов
Вызов функции в предложении SELECT передаст возвращаемое значение на
сторону Java; в предложении SELECT также можно вызывать произвольные SQL-
функции
базы данных. Но, прежде чем говорить о проекциях, мы сначала узнаем,
как упорядочивать результаты.
15.2.4. Упорядочение результатов запроса
В любом языке запросов есть механизм упорядочения результатов. В JPQL эту
роль играет предложение ORDER BY, как в SQL.
Следующий запрос найдет всех пользователей и упорядочит их по именам (по
умолчанию в порядке возврастания):
select u from User u order by u.username
Возрастание или убывание определяется ключевым словом asc или desc:
select u from User u order by u.username desc
В API запросов на основе критериев порядок сортировки должен указываться
обязательно, с помощью функции asc() или desc():
Root<User> u = criteria.from(User.class);
criteria.select(u).orderBy(
cb.desc(u.get("username"))
);
Упорядочивать можно по нескольким атрибутам:
select u from User u order by u.activated desc, u.username asc
Root<User> u = criteria.from(User.class);
criteria.select(u).orderBy(
cb.desc(u.get("activated")),
cb.asc(u.get("username"))
);
Упорядочение атрибутов со значением null
Если столбец, по которому производится упорядочение, может содержать NULL,
записи с NULL могут оказаться в начале или в конце результатов. Это поведение
определяется СУБД, поэтому для создания переносимого приложения всегда
нужно указывать, должны ли записи с NULL находиться в конце или начале, доба-
вив предложение ORDER BY ... NULLS FIRST|LAST. Hibernate поддерживает это предло-
жение в JPQL, однако в JPA оно не стандартизовано. Вместо этого можно задать
порядок по умолчанию, установив параметр конфигурации единицы хранения
hibernate.order_by.default_null_ordering в значение none (по умолчанию), first или
last.
Проекции  439
Особенности Hibernate
Спецификация JPA позволяет использовать в предложении ORDER BY только те
свойства/пути, которые присутствуют в предложении SELECT. Следующие запро-
сы не переносимы, но зато работают в Hibernate:
select i.name from Item i order by i.buyNowPrice asc
select i from Item i order by i.seller.username desc
Будьте осторожнее с неявными внутренними соединениями в выражениях,
представляющих пути, и предложениях ORDER BY: последний запрос вернет только
экземпляры Item с заполненным полем seller. Это может оказаться неожиданным,
поскольку тот же запрос, но без предложения ORDER BY, вернет все экземпляры Item
(давайте на секунду забудем, что в нашей модели поле seller любого объекта Item
всегда заполнено). Более подробное обсуждение внутренних соединений и выра-
жений, описывающих пути, вы найдете в следующей главе.
Вы уже знаете, как писать предложения FROM, WHERE и ORDER BY. Вы умеете извле-
кать нужные сущности, применяя различные выражения для ограничения и упо-
рядочивания результатов. Теперь осталось только определить набор возвращае-
мых атрибутов с помощью проекции.
15.3. Проекции
Говоря простым языком, выборки и ограничения в запросе определяют, из ка-
ких таблиц и какие записи будут извлекаться. Проекция же определяет, какие
«столбцы» нужно вернуть приложению. В JPQL за проекцию отвечает предло-
жение SELECT.
15.3.1. Проекция сущностей и скалярных значений
Рассмотрим, к примеру, следующие запросы:
select i, b from Item i, Bid b
Root<Item> i = criteria.from(Item.class);
Root<Bid> b = criteria.from(Bid.class);
criteria.select(cb.tuple(i, b));
/* Удобная альтернатива:
criteria.multiselect(
criteria.from(Item.class),
criteria.from(Bid.class)
);
*/
440  Языки запросов
Как упоминалось ранее, с помощью такого запроса на основе критериев можно
выбирать экземпляры разных сущностей, представленных объектами Root, вы-
зывая метод from() несколько раз. Для добавления в проекцию нескольких эле-
ментов нужно вызвать метод tuple() объекта CriteriaBuilder или более удобный
метод multiselect().
Ниже создается декартово произведение всех экземпляров Item и Bid. Запросы
возвращают упорядоченные пары экземпляров сущностей Item и Bid:
List<Object[]> result = query.getResultList();
Set<Item> items = new HashSet();
Set<Bid> bids = new HashSet();
for (Object[] row : result) {
assertTrue(row[0] instanceof Item);  Индекс 0
items.add((Item) row[0]);
assertTrue(row[1] instanceof Bid);  Индекс 1
bids.add((Bid)row[1]);
}
assertEquals(items.size(), 3);
assertEquals(bids.size(), 4);
assertEquals(result.size(), 12); Декартово произведение
Запрос вернет коллекцию (List) с элементами типа Object[] . Элемент с ин-
дексом 0 будет хранить объект Item , а элемент с индексом 1 – объект Bid .
Будучи произведением, результат содержит все возможные комбинации записей
из таблиц, соответствующих сущностям Item и Bid. Очевидно, что в таком
запросе нет практического смысла, но вас не должна удивлять возможность по-
лучения коллекции элементов Object[] в качестве результата запроса. Hibernate
управляет всеми экземплярами сущностей Item и Bid, которые находятся в храни-
мом состоянии, в контекст хранения. Также обратите внимание, что два множества
HashSet устраняют повторяющиеся экземпляры Item и Bid.
В API запросов на основе критериев имеется также возможность получения
типизированного списка результатов с помощью интерфейса Tuple. Для этого
сначала нужно создать объект типа CriteriaQuery<Tuple>, вызвав метод createTupleQuery().
Затем завершить определение запроса, присвоив классам сущностей
псевдонимы:
CriteriaQuery<Tuple> criteria = cb.createTupleQuery();
// Или: CriteriaQuery<Tuple> criteria = cb.createQuery(Tuple.class);
criteria.multiselect(
criteria.from(Item.class).alias("i"), Задавать псевдонимы необязательно
criteria.from(Bid.class).alias("b")
);
TypedQuery<Tuple> query = em.createQuery(criteria);
List<Tuple> result = query.getResultList();
 Возвращает коллекцию List
с элементами типа Object[]
Проекции  441
Интерфейс Tuple поддерживает несколько способов обращения к результатам:
по индексу, по псевдониму или с использованием нетипизированного доступа че-
рез метаданные:
for (Tuple tuple : result) {
Item item = tuple.get(0, Item.class); По индексу
Bid bid = tuple.get(1, Bid.class);
item = tuple.get("i", Item.class); По псевдониму
bid = tuple.get("b", Bid.class);
for (TupleElement<?> element : tuple.getElements()) { Через метаданные
Class clazz = element.getJavaType();
String alias = element.getAlias();
Object value = tuple.get(element);
}
}
Следующая проекция также возвращает коллекцию элементов Object[]:
select u.id, u.username, u.homeAddress from User u
Root<User> u = criteria.from(User.class);
criteria.multiselect( Возвращает коллекцию List элементов Object[]
u.get("id"), u.get("username"), u.get("homeAddress")
);
Каждый элемент Object[], возвращаемый этим запросом, содержит объект
типа Long по индексу 0, объект String по индексу 1 и объект Address по индексу 2.
Первые два – скалярные значения; третий – экземпляр встроенного класса. Ни
один из этих объектов не является управляемым экземпляром сущности! Следо-
вательно, ни один не находится в хранимом состоянии, в отличие от экземпляров
сущностей. Они не пересекают границу транзакции, и, очевидно, изменение их
состояния не проверяется автоматически. Мы называем такие объекты временны-
ми (transient). Подобный запрос обычно требуется для создания простого отчета,
который бы показывал все имена пользователей и их домашние адреса.
Вы уже несколько раз сталкивались с выражениями для описания путей к атри-
бутам: с помощью точечной нотации можно ссылаться на такие поля сущностей, как
User#username в виде u.username. Для вложенного поля встраиваемого типа, к примеру,
можно указать путь u.homeAddress.city.zipcode. Этот путь ссылается на единствен-
ное значение, поскольку не завершается именем поля с отображаемой коллекцией.
По сравнению с использованием объектов Object[] или Tuple (особенно для соз-
дания отчетов), лучше использовать способ динамического создания экземпляров
в проекциях, который будет продемонстрирован далее.
15.3.2. Динамическое создание экземпляров
Предположим, что существует отчет, в котором нужно отобразить некоторые дан-
ные в виде списка. Допустим, нужно показать все аукционные товары с датами
442  Языки запросов
окончания каждого аукциона. При этом не хочется загружать управляемые экзем-
пляры сущности Item, поскольку никакие данные меняться не будут.
Сначала нужно создать класс ItemSummary с конструктором, принимающим ар-
гументы Long, String и Date, соответствующие идентификатору товара, его назва-
нию и отметке времени окончания аукциона:
public class ItemSummary {
public ItemSummary(Long itemId, String name, Date auctionEnd) {
// ...
}
// ...
}
Иногда экземпляры таких классов называются объектами передачи данных
(Data Transfer Objects, DTO), поскольку их главной целью является передача
данных из одной части приложения в другую. Класс ItemSummary не отображается
в базу данных, и в нем можно определять любые методы (чтения, записи, вывода
значений), необходимые для вашего отчета.
Hibernate может сразу вернуть из запроса новые экземпляры ItemSummary с по-
мощью оператора new в JPQL и метода construct() в критериях:
select new org.jpwh.model.querying.ItemSummary(
i.id, i.name, i.auctionEnd
) from Item i
Root<Item> i = criteria.from(Item.class);
criteria.select(
cb.construct(
ItemSummary.class, Должен быть подходящий конструктор
i.get("id"), i.get("name"), i.get("auctionEnd")
)
);
Каждый элемент в списке результатов этого запроса будет экземпляром Item-
Summary. Обратите внимание, что в JPQL нужно указывать полное квалифициро-
ванное имя класса, т. е. добавлять имя пакета. Также отметьте, что использование
вложенных конструкторов не поддерживается – нельзя написать new ItemSummary(...,
new UserSummary(...)).
Динамическое создание экземпляров работает не только с неуправляемыми
объектами передачи данных вроде экземпляров ItemSummary. Можно создать но-
вый объект Item или User, уже являющийся экземпляром отображаемого класса
сущности. Самое главное, чтобы класс имел подходящий конструктор для исполь-
зования в проекции. Но при динамическом создании экземпляров сущностей в за-
просе они не будут находиться в хранимом состоянии! Они будут возвращаться
либо во временном, либо в отсоединенном состоянии, в зависимости от значения
идентификатора. Как вариант этот прием можно использовать для копирования
данных: извлечь «новый» временный экземпляр Item, в конструктор которого
Проекции  443
передается часть значений из базы данных, в часть из приложения, чтобы затем
сохранить его в базу, вызвав метод persist().
Если класс объекта DTO не имеет подходящего конструктора, но вы хотите за-
полнить свойства объекта значениями из результата запроса, используйте Result-
Transformer, как показано в разделе 16.1.3. Другие примеры группировки и агреги-
рования вы увидите далее.
А пока рассмотрим одну особенность проекций, которая сбивает с толку многих
разработчиков, – обработку повторяющихся записей.
15.3.3. Извлечение уникальных результатов
Проекция в запросе не гарантирует уникальности элементов в наборе результатов.
Например, имена товаров могут быть неуникальными, поэтому следующий запрос
может вернуть одно имя несколько раз:
select i.name from Item i
CriteriaQuery<String> criteria = cb.createQuery(String.class);
criteria.select(
criteria.from(Item.class).<String>get("name")
);
Трудно представить, какую пользу могли бы принести две одинаковые запи-
си в результате, поэтому если есть вероятность появления одинаковых записей,
для их фильтрации обычно используется ключевое слово DISTINCT или метод distinct():
select distinct i.name from Item i
CriteriaQuery<String> criteria = cb.createQuery(String.class);
criteria.select(
criteria.from(Item.class).<String>get("name")
);
criteria.distinct(true);
Они удалят повторяющиеся значения из возвращаемого списка имен экземпля-
ров Item и будут преобразованы в SQL-оператор DISTINCT. Фильтрация осуществляется
на уровне базы данных. Далее вы увидите, что так происходит не всегда.
Вы уже видели, как вызывать функции в ограничениях, в предложении WHERE.
Аналогично можно вызывать функции в проекциях для изменения возвращаемых
результатов.
15.3.4. Вызов функций в проекциях
Следующие запросы возвращают строки (String), полученные путем вызова
функции concat() внутри проекции:
select concat(concat(i.name, ': '), i.auctionEnd) from Item i
Root<Item> i = criteria.from(Item.class);
criteria.select(
444  Языки запросов
cb.concat(
cb.concat(i.<String>get("name"), ":"),
i.<String>get("auctionEnd") Обратите внимание на приведение типа Date к строке
)
);
Запрос вернет список (List) строк (String), каждая из которых будет иметь вид
«[имя товара]:[дата окончания аукциона]». Из примера видно, что можно также
описывать вложенные вызовы функций.
Функция coalesce() возвращает null, если все ее аргументы равны null; в про-
тивном случае она вернет первый непустой аргумент:
select i.name, coalesce(i.buyNowPrice, 0) from Item i
Root<Item> i = criteria.from(Item.class);
criteria.multiselect(
i.get("name"),
cb.coalesce(i.<BigDecimal>get("buyNowPrice"), 0)
);
Если товар (Item) не имеет текущей цены покупки (buyNowPrice), вместо null
будет возвращено нулевое значение типа BigDecimal.
Похожим образом действует выражение case/when, но его возможности гораз-
до шире. Следующий запрос вернет имя (username) каждого пользователя (User),
а также строку (String) с текстом «Германия», «Швейцария» или «Другое» в за-
висимости от длины индекса (zipcode) пользователя:
select
u.username,
case when length(u.homeAddress.zipcode) = 5 then 'Germany'
when length(u.homeAddress.zipcode) = 4 then 'Switzerland'
else 'Other'
end
from User u
// Проверьте поддержку строковых литералов; см. описание ошибки в Hibernate
// под номером HHH-8124
Root<User> u = criteria.from(User.class);
criteria.multiselect(
u.get("username"),
cb.selectCase()
.when(
cb.equal(
cb.length(u.get("homeAddress").<String>get("zipcode")), 5
), "Germany"
)
.when(
cb.equal(
cb.length(u.get("homeAddress").<String>get("zipcode")), 4
), "Switzerland"
Проекции  445
)
.otherwise("Other")
);
За информацией о стандартных встроенных функциях обращайтесь к таблицам
в предыдущем разделе. В отличие от вызовов функций в ограничениях, встретив
неизвестную функцию в проекции, Hibernate не будет отправлять ее в базу дан-
ных в виде простого вызова SQL-функции. Любая функция, которая вызывается
в проекции, должна быть известна Hibernate и вызываться с помощью специаль-
ного JPQL-оператора function().
Следующая проекция вернет имя каждого аукционного товара (Item) и коли-
чество дней между датой его создания и датой окончания аукциона с помощью
SQL-функции datediff() базы данных H2:
select
i.name,
function('DATEDIFF', 'DAY', i.createdOn, i.auctionEnd)
from Item i
Root<Item> i = criteria.from(Item.class);
criteria.multiselect(
i.get("name"),
cb.function(
"DATEDIFF",
Integer.class,
cb.literal("DAY"),
i.get("createdOn"),
i.get("auctionEnd")
)
);
Если, напротив, потребуется вызвать функцию посредственно, сначала нужно
сообщить Hibernate тип ее возвращаемого значения, чтобы он мог корректно об-
работать запрос. Функции для использования в проекциях должны определяться
в экземпляре диалекта базы данных org.hibernate.Dialect. Функция datediff(),
к примеру, уже определена в диалекте базы данных H2. После этого функцию
можно вызвать либо с помощью оператора function(), который будет работать
с любыми реализациями JPA при обращении к базе H2, либо напрямую, как datediff(),
что, скорее всего, будет работать только с Hibernate. Загляните в исходный
код диалекта вашей базы данных – скорее всего, вы найдете множество других
зарегистрированных там нестандартных функций SQL.
Кроме того, функции SQL можно добавлять программно, при загрузке Hibernate,
вызывая метод applySqlFunction() интерфейса MetadataBuilder. В следующем
примере показано, как добавить SQL-функцию lpad() во время загрузки Hibernate:
...
MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();
metadataBuilder.applySqlFunction(
446  Языки запросов
"lpad",
new org.hibernate.dialect.function.StandardSQLFunction(
"lpad", org.hibernate.type.StringType.INSTANCE
)
);
За более подробной информацией обращайтесь к документации Javadoc с опи-
санием SQLFunction и его подклассов.
Далее мы рассмотрим агрегирующие функции, самые востребованные при соз-
дании отчетов.
15.3.5. Агрегирующие функции
Запросы, созданные для получения отчетов, часто используют встроенные воз-
можности баз данных по группировке и агрегации данных. Например, в отчете
можно показать самую большую начальную стоимость товара в каждой категории.
Эти вычисления будут выполнены на уровне базы данных, и вам не нужно будет
загружать много экземпляров сущностей Item в память.
В JPA стандартизованы следующие функции агрегирования: count(), min(),
max(), sum() и avg().
Следующий запрос подсчитает количество экземпляров Item:
select count(i) from Item i
criteria.select(
cb.count(criteria.from(Item.class))
);
Он вернет результат в виде объекта Long:
Long count = (Long)query.getSingleResult();
Функция count(distinct) в JPQL и метод countDistinct() удаляют дубликаты:
select count(distinct i.name) from Item i
criteria.select(
cb.countDistinct(
criteria.from(Item.class).get("name")
)
);
Следующий запрос вычислит сумму всех ставок (Bid):
select sum(b.amount) from Bid b
CriteriaQuery<Number> criteria = cb.createQuery(Number.class);
criteria.select(
cb.sum(
criteria.from(Bid.class).<BigDecimal>get("amount")
)
);
Проекции  447
Запрос вернет значение типа BigDecimal, поскольку свойство amount имеет тип
BigDecimal. Функция sum() также распознает тип BigInteger, а для всех остальных
числовых типов возвращает значение типа Long.
Следующий запрос вернет минимальную и максимальную ставки для конкрет-
ного экземпляра Item:
select min(b.amount), max(b.amount) from Bid b
where b.item.id = :itemId
Root<Bid> b = criteria.from(Bid.class);
criteria.multiselect(
cb.min(b.<BigDecimal>get("amount")),
cb.max(b.<BigDecimal>get("amount"))
);
criteria.where(
cb.equal(
b.get("item").<Long>get("id"),
cb.parameter(Long.class, "itemId")
)
);
Результатом этого запроса будет кортеж объектов BigDecimal (два экземпляра
BigDecimal в массиве типа Object[]).
Когда агрегирующая функция в предложении SELECT используется без группи-
ровки в предложении GROUP BY, в результате будет возвращена единственная запись
с агрегированным значением. Это значит, что в отсутствие предложения GROUP BY
любое предложение SELECT с агрегирующими функциями должно состоять только
из них.
Для получения более сложных данных для отчетов нужно выполнить группи-
ровку данных.
15.3.6. Группировка данных
В JPA определяется поддержка нескольких особенностей SQL, часто используемых
при создании отчетов (хотя они могут применяться и в других случаях).
В запросах для создания отчетов сначала записывается предложение SELECT, опре-
деляющее проекцию, а затем предложения GROUP BY и HAVING, описыващие агреги-
рование.
Так же как в SQL, любое свойство или псевдоним, стоящие в предложении SELECT
отдельно от агрегирующих функций, должны также присутствовать в пред-
ложении GROUP BY. Рассмотрим запрос, который подсчитывает количество пользо-
вателей с одинаковой фамилией:
select u.lastname, count(u) from User u
group by u.lastname
Root<User> u = criteria.from(User.class);
criteria.multiselect(
448  Языки запросов
u.get("lastname"),
cb.count(u)
);
criteria.groupBy(u.get("lastname"));
В данном примере поле u.lastname находится вне агрегирующей функции, по-
этому данные в проекции должны быть сгруппированы по u.lastname. Также не
нужно указывать свойство, которое должно подсчитываться, поскольку выраже-
ние count(u) будет автоматически преобразовано в count(u.id).
Следующий запрос вычислит средний размер ставки (Bid#amount) для каждого
товара Item:
select i.name, avg(b.amount)
from Bid b join b.item i
group by i.name
Root<Bid> b = criteria.from(Bid.class);
criteria.multiselect(
b.get("item").get("name"),
cb.avg(b.<BigDecimal>get("amount"))
);
criteria.groupBy(b.get("item").get("name"));
Особенности Hibernate
При использовании группировок можно столкнуться с некоторыми ограничениями
в Hibernate. Следующий запрос полностью соответствует спецификации,
но Hibernate обрабатывает его некорректно:
select i, avg(b.amount)
from Bid b join b.item i
group by i
Спецификация JPA разрешает указывать в группировке псевдонимы сущностей:
group by i. Но Hibernate не подставит свойства сущности Item в сгенерированное
предложение SQL GROUP BY, что вызовет несоответствие с предложением SELECT. Все
свойства вам придется указывать вручную, пока эта ошибка не будет исправлена
в Hibernate (это одна из самых старых ошибок под номером HHH-1615):
select i, avg(b.amount)
from Bid b join b.item i
group by i.id, i.name, i.createdOn, i.auctionEnd,
i.auctionType, i.approved, i.buyNowPrice,
i.seller
Root<Bid> b = criteria.from(Bid.class);
Join<Bid, Item> i = b.join("item");
criteria.multiselect(
i,
cb.avg(b.<BigDecimal>get("amount"))
Соединения  449
);
criteria.groupBy(
i.get("id"), i.get("name"), i.get("createdOn"), i.get("auctionEnd"),
i.get("auctionType"), i.get("approved"), i.get("buyNowPrice"),
i.get("seller")
);
Иногда требуется исключить некоторые группировки, выбирая только кон-
кретные агрегированные значения. Ограничение для записей описывается в пред-
ложении WHERE. А предложение HAVING описывает ограничение для группировок.
Например, следующий запрос подсчитает количество пользователей с фамили-
ей, начинающейся на букву «D»:
select u.lastname, count(u) from User u
group by u.lastname
having u.lastname like 'D%'
Root<User> u = criteria.from(User.class);
criteria.multiselect(
u.get("lastname"),
cb.count(u)
);
criteria.groupBy(u.get("lastname"));
criteria.having(cb.like(u.<String>get("lastname"), "D%"));
Предложения SELECT и HAVING подчиняются общему правилу: вне агрегирующих
функций могут находиться только свойства, по которым осуществляется группи-
ровка.
В предыдущих разделах вы познакомились с основами запросов. Пришло время
изучить более продвинутые возможности. У большинства инженеров наибольшие
затруднения вызывает соединение произвольных данных с помощью оператора
join – мощного механизма реляционной модели.
15.4. Соединения
Оператор join соединяет данные из двух (или более) отношений. Соединение
данных позволяет извлечь несколько связанных экземпляров и коллекций в од-
ном запросе: например, загрузить экземпляр Item и его коллекцию bids за одно
обращение к базе данных. Сейчас мы продемонстрируем, как работают основные
операции соединения и как они используются для определения стратегий дина-
мического извлечения. Рассмотрим сначала, как соединения работают в обычном
SQL, оставив на минуту JPA.
15.4.1. Соединения в SQL
Рассмотрим упомянутый выше пример: соединение таблиц ITEM (товары) и BID
(ставки), показанных на рис. 15.1. В базе данных находятся три товара: для первого
450  Языки запросов
имеются три ставки, для второго – одна, а для третьего нет ни одной. Обратите вни-
мание, что показаны только некоторые столбцы, остальные заменены многоточиями.
Рис. 15.1  Таблицы ITEM и BID –
первые кандидаты для соединения
Большинство думает об операции join в контексте баз данных SQL как о внутреннем
соединении (inner join). Внутреннее соединение является наиболее важ-
ным типом соединений и самым простым для понимания. Рассмотрим выражение
SQL и его результат (рис. 15.2). Это выражение SQL содержит в предложении FROM
оператор inner join в стиле ANSI.
select i.*, b.*
from ITEM i
inner join BID b on i.ID = b.ITEM_ID
i.NAME
Foo
... b.ID
...
i.ID
1
b.AMOUNT
1 99.00
1 Foo ...
1 Foo ...
2 Bar ...
2
3
4
b.ITEM_ID
1
1
1
2
100.00
101.00
4.99
Рис. 15.2  Результат внутреннего соединения
двух таблиц в стиле ANSI
Выполняя внутреннее соединение таблиц ITEM и BID по условию равенства атри-
бута ID из таблицы ITEM атрибуту ITEM_ID из таблицы BID, вы получите все товары
с их ставками. Обратите внимание, что в результат этого запроса попадут только
товары, имеющие ставки.
Операцию соединения можно представить следующим образом: сначала бе-
рется произведение двух таблиц, т. е. все возможные комбинации записей из ITEM
и BID. Затем объединенные записи фильтруются с использованием условия соеди-
нения: выражения в предложении ON (любой хороший движок базы данных ис-
пользует более сложный алгоритм для создания соединения; он обычно не создает
затратного произведения, чтобы затем его отфильтровать). Условие соединения –
это логическое выражение, возвращающее true, если объединенная запись должна
попасть в результат запроса.
Соединения  451
Важно понимать, что условием соединения может быть любое выражение, воз-
вращающее true. Данные можно соединять по-разному; вы не ограничены только
сравнением значений идентификаторов. Например, условие соединения on i.ID =
b.ITEM_ID and b.AMOUNT > 100 будет истинным только для записей в BID со значени-
ем атрибута AMOUNT больше 100. На столбец ITEM_ID таблицы BID наложено огра-
ничение внешнего ключа, гарантирующее присутствие в записи из BID ссылки на
запись в ITEM. Но это не означает, что соединение можно выполнять, используя
только столбцы первичного и внешнего ключей. Ключевые столбцы, безусловно,
чаще других выступают в роли операндов в условиях соединений, поскольку часто
требуется извлекать связанную информацию.
Чтобы извлечь все товары, а не только со ставками, нужно использовать левое
внешнее соединение ((left) outer join), как показано на рис. 15.3.
select i.*, b.*
from ITEM i
left outer join BID b on i.ID = b.ITEM_ID
i.NAME
Foo
... b.ID
...
i.ID
1
b.AMOUNT
1 99.00
1 Foo ...
1 Foo ...
2 Bar ...
3 Baz ...
2
3
4
b.ITEM_ID
1
1
1
2
100.00
101.00
4.99
Рис. 15.3  Результат левого внешнего соединения
двух таблиц в стиле ANSI
В случае левого внешнего соединения каждая запись в (левой) таблице ITEM,
не удовлетворяющая условию соединения, также будет добавлена в результат,
а все столбцы таблицы BID будут содержать для нее значения NULL. Правые внеш-
ние соединения применяются редко; разработчики обычно думают слева направо
и в операции соединения помещают основную таблицу вначале. На рис. 15.4 по-
казан такой же результат, но только с применением правого внешнего соединения,
где ведущей выступает таблица BID, а не ITEM.
В SQL условия соединения обычно указываются явно. К сожалению, в качестве
условия нельзя использовать имя ограничения внешнего ключа: select * from ITEM
join BID on FK_BID_ITEM_ID не сработает.
Условие соединения должно быть указано либо в предложении ON, в соответ-
ствии с синтаксисом ANSI, либо в предложении WHERE, при использовании так на-
зываемого тета-соединения: select * from ITEM i, BID b where i.ID = b.ITEM_ID. Это
пример внутреннего соединения; как видите, в предложении FROM сначала создает-
ся произведение таблиц.
Теперь пришло время изучить возможности JPA. Не забывайте, что в конечном
итоге Hibernate превращает все запросы в их SQL-эквиваленты, поэтому даже
452  Языки запросов
если синтаксис будет слегка отличаться, вы всегда сможете вернуться к примерам
из этого раздела, чтобы проверить свое понимание итогового кода SQL и резуль-
татов запросов.
select b.*, i.*
from BID b
right outer join ITEM i on b.ITEM_ID = i.ID
i.NAME
Foo
b.ID ...
...
i.ID
1
b.AMOUNT
1 99.00
1 Foo ...
1 Foo ...
2 Bar ...
3 Baz ...
2
3
4
b.ITEM_ID
1
1
1
2
100.00
101.00
4.99
Рис. 15.4  Результат правого внешнего соединения
двух таблиц в стиле ANSI
15.4.2. Соединение таблиц в JPA
JPA поддерживает четыре способа описания соединений (внешних и внутренних)
в запросе:
 неявное соединение по связи с использованием выражений для представле-
ния путей к атрибутам;
 обычное соединение в предложении FROM с помощью оператора join;
 немедленное соединение в предложении FROM с использованием оператора
join и ключевого слова fetch для немедленного извлечения;
 тета-соединение в предложении WHERE.
Рассмотрим сначала неявные соединения по связи.
15.4.3. Неявные соединения по связи
В запросах JPA необязательно явно указывать условия соединения. Достаточно
указать имя связи, отображаемой в классе Java. Как этого недостает в SQL – воз-
можности описывать условие соединения с помощью ограничения внешнего клю-
ча. Поскольку большинство отношений по внешнему ключу описывается в схеме
базы данных, имена этих отображаемых связей можно использовать в языке за-
просов. Пусть это всего лишь синтаксический сахар, но он очень удобен.
Например, класс сущности Bid имеет отображаемую связь многие к одному
с классом Item (с именем item). Если указать эту связь в запросе, Hibernate получит
достаточно информации, чтобы сформировать условие соединения со сравнением
ключевых столбцов. Благодаря этому запросы становятся короче и понятнее.
Ранее в этой главе вы уже сталкивались с выражениями, описывающими пути
к атрибутам с помощью точечной нотации: выражения, ссылающиеся на един-
ственное значение, такие как user.homeAddress.zipcode, и выражения, ссылающие-
Соединения  453
ся на коллекцию, такие как item.bids. Такие выражения можно использовать в за-
просах с неявными соединениями:
select b from Bid b where b.item.name like 'Fo%'
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.like(
b.get("item").<String>get("name"),
"Fo%"
)
);
Путь b.item.name создаст неявное соединение по связи многие к одному от сущ-
ности Bid к сущности Item; эта связь называется item. Hibernate знает, что вы
отобразили
эту связь с помощью внешнего ключа ITEM_ID в таблице BID, и сможет
правильно сформировать условие соединения в SQL. Неявные соединения всегда
работают для ассоциаций многие к одному и один ко многим, но не для ассоциаций
с коллекциями (нельзя написать item.bids.amount).
Одному выражению пути может соответствовать несколько соединений:
select b from Bid b where b.item.seller.username = 'johndoe'
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.equal(
b.get("item").get("seller").get("username"),
"johndoe"
)
);
Этот запрос соединяет таблицы BID, ITEM и USER.
Мы не советуем применять этот стиль в более сложных запросах. Соединения
играют важную роль в SQL, поэтому во время оптимизации запросов очень важно
иметь возможность с ходу определять количество соединений. Рассмотрим следующий
запрос:
select b from Bid b where b.item.seller.username = 'johndoe'
and b.item.buyNowPrice is not null
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.and(
cb.equal(
b.get("item").get("seller").get("username"),
"johndoe"
),
cb.isNotNull(b.get("item").get("buyNowPrice"))
)
);
454  Языки запросов
Сколько соединений потребуется, чтобы выразить этот запрос на языке SQL?
Даже если вы правильно ответите на вопрос, это отнимет у вас несколько секунд.
Правильный ответ – два. Сформированный код SQL будет выглядеть примерно так:
select b.*
from BID b
inner join ITEM i on b.ITEM_ID = i.ID
inner join USER u on i.SELLER_ID = u.ID
where u.USERNAME = 'johndoe'
and i.BUYNOWPRICE is not null;
Альтернативой соединениям с такими сложными выражениями для описания
путей служат обычные соединения с предложениями FROM.
15.4.4. Явные соединения
JPA различает цели соединений. Предположим, что вы выбираете все товары; со-
единение с таблицей ставок может преследовать две цели.
Вы можете ограничить количество товаров, возвращаемое запросом, на осно-
ве какого-либо критерия, применяемого к ставкам. Например, можно получить
все товары со ставками больше 100, что потребует внутреннего соединения. В этом
случае вас не будут интересовать товары без ставок.
С другой стороны, главной целью может быть получение всех товаров, а ставки
присоединяются только затем, чтобы получить все данные в одном выражении
SQL, что мы ранее назвали немедленным извлечением через соединение. Помните,
что по умолчанию мы отображаем все связи как отложенные, поэтому немедлен-
ное извлечение переопределит стратегию извлечения по умолчанию в конкретном
запросе во время выполнения.
Давайте сначала напишем несколько запросов, использовав соединения для
ограничения результатов. Чтобы извлечь все экземпляры Item, оставив только со
ставками, превышающими определенное значение, нужно присвоить псевдоним
связи соединения. Затем на него можно будет сослаться в предложении WHERE для
описания ограничения:
select i from Item i
join i.bids b
where b.amount > 100
Root<Item> i = criteria.from(Item.class);
Join<Item, Bid> b = i.join("bids");
criteria.select(i).where(
cb.gt(b.<BigDecimal>get("amount"), new BigDecimal(100))
);
В этом запросе коллекции bids присвоен псевдоним b, с помощью которого опи-
сывается ограничение для экземпляров Item, чтобы извлечь только те, которые
имеют значение Bid#amount больше 100.
До сих пор в этом разделе вы видели только внутренние соединения. Внешние
соединения в основном применяются для динамического извлечения, которое мы
Соединения  455
скоро обсудим. Но иногда бывает нужно написать простой запрос с внешним со-
единением без применения динамической стратегии извлечения. Следующий за-
прос, к примеру, извлечет товары без ставок и со ставками больше минимального
значения:
select i, b from Item i
left join i.bids b on b.amount > 100
Root<Item> i = criteria.from(Item.class);
Join<Item, Bid> b = i.join("bids", JoinType.LEFT);
b.on(
cb.gt(b.<BigDecimal>get("amount"), new BigDecimal(100))
);
criteria.multiselect(i, b);
Запрос вернет кортеж объектов Item и Bid в виде коллекции List<Object[]>.
Первое, что бросается в глаза, – ключевое слово LEFT и аргумент JoinType.LEFT
в запросе на основе критериев. Вы можете использовать форму LEFT OUTER JOIN
и RIGHT OUTER JOIN в запросах JPQL, но мы предпочитаем короткий вариант.
Вторая особенность – дополнительное условие соединения после ключевого
слова ON. Если поместить в предложение WHERE условие b.amount > 100, в результат
запроса попадут только экземпляры Item, имеющие ставки. Но это не то, что нам
надо: нам нужно извлечь товары и ставки, а также товары без ставок. Если товар
имеет ставку, она должна быть больше 100. Добавляя дополнительное условие
соединения в предложение FROM, мы накладываем ограничение на экземпляры Bid,
по-прежнему возвращая все экземпляры Item, независимо от наличия ставок.
Дополнительное условие соединения будет преобразовано в код SQL:
... from ITEM i
left outer join BID b
on i.ID = b.ITEM_ID and (b.AMOUNT > 100)
Запрос SQL всегда будет содержать неявное условие соединения отображаемой
связи i.ID = b.ITEM_ID. В условие соединения можно добавить лишь дополнитель-
ное выражение. JPA и Hibernate не поддерживают произвольных внешних соеди-
нений без применения отображаемых связей сущностей или коллекций.
В Hibernate есть нестандартное ключевое слово WITH – эквивалент ON в JPQL.
Его можно встретить в старом коде, поскольку поддержка ON в JPA была стандар-
тизована лишь недавно.
Можно написать запрос, возвращающий те же данные, но с помощью правого
внешнего соединения, поменяв ведущую таблицу:
select b, i from Bid b
right outer join b.item i
where b is null or b.amount > 100
Root<Bid> b = criteria.from(Bid.class);
Join<Bid, Item> i = b.join("item", JoinType.RIGHT);
criteria.multiselect(b, i).where(
456  Языки запросов
cb.or(
cb.isNull(b),
cb.gt(b.<BigDecimal>get("amount"), new BigDecimal(100)))
);
Правое внешнее соединение гораздо важнее, чем вы могли бы подумать. Ранее
в этой книге мы советовали избегать по мере возможности отображения хранимых
коллекций. Поэтому если у вас нет коллекции типа один ко многим Item#bids, вам
понадобится правое внешнее соединение, чтобы извлечь все экземпляры Item с со-
ответствующими им экземплярами Bid. Запрос начинается с «другой» стороны –
отображения многие к одному Bid#item.
Отложенные внешние соединения также играют важную роль в немедленном
динамическом извлечении.
15.4.5. Динамическое извлечение с помощью соединений
Все запросы из предыдущих разделов имели кое-что общее: все возвращаемые
экземпляры Item имели коллекцию bids. Когда коллекция, отмеченная аннота-
цией @OneToMany, отображается с параметром FetchType.LAZY (по умолчанию для
коллекций), она будет инициализирована с помощью отдельного выражения
SQL при первом обращении к ней. Так же работают все отношения, связанные
только с одной сущностью, такие как связь seller с аннотацией @ManyToOne у каж-
дого экземпляра Item. По умолчанию Hibernate создаст прокси-объект и выпол-
нит отложенную загрузку связанного экземпляра User только при первом об-
ращении.
Но что делать, если нужно изменить это поведение? Во-первых, можно поме-
нять план извлечения в метаданных и отобразить коллекцию или связь с пара-
метром FetchType.EAGER. После этого Hibernate выполнит весь необходимый код
SQL, чтобы обеспечить загрузку требуемого графа объектов. Это, в свою очередь,
означает, что один запрос в JPA может привести к выполнению нескольких опе-
раций в SQL! Например, простой запрос select i from Item i может привести к вы-
полнению дополнительных выражений SQL для загрузки коллекции bids каждого
объекта Item, свойства seller каждого объекта Item и т. д.
В главе 12 мы показали пример с глобальным планом отложенного извлече-
ния, который определялся в метаданных отображения, где мы не должны были
использовать параметра FetchType.EAGER для коллекций и связей. Но затем, для
конкретного варианта использования, динамически переопределили план отло-
женного извлечения и написали запрос, извлекающий данные самым эффектив-
ным способом. Например, не нужно выполнять несколько выражений SQL, чтобы
извлечь все экземпляры Item с инициализированными коллекциями bids и уста-
новленным значением seller каждого экземпляра Item. Это можно сделать одним
выражением SQL с помощью операции соединения.
Немедленное извлечение связанных данных осуществляется с помощью клю-
чевого слова FETCH в JPQL и с помощью метода fetch() в API запросов на основе
критериев.
Соединения  457
select i from Item i
left join fetch i.bids
Root<Item> i = criteria.from(Item.class);
i.fetch("bids", JoinType.LEFT);
criteria.select(i);
Вы уже видели код SQL, в который транслируется этот запрос, а также резуль-
тат запроса на рис. 15.3.
Запрос возвращает список List<Item>; каждый экземпляр Item вместе со своей
коллекцией bids полностью инициализирован. Это отличается от тех кортежей,
что вы получали в предыдущем разделе!
Но будьте внимательны – возможно, вы не ожидаете получить от предыдущего
запроса повторяющихся результатов:
List<Item> result = query.getResultList();
assertEquals(result.size(), 5); 3 товара, 4 ставки, 5 записей в результате
Set<Item> distinctResult = new LinkedHashSet<Item>(result); Всего лишь три товара
assertEquals(distinctResult.size(), 3); Удаление дубликатов в памяти
Убедитесь, что понимаете, почему повторяющиеся записи появились в резуль-
тирующей коллекции List. Проверьте еще раз количество «записей» Item в резуль-
тате, как показано на рис. 15.3. Hibernate превратит записи в элементы списка; но
вам может понадобиться точное количество записей для вывода таблицы в отчете.
Вы можете избавиться от повторяющихся экземпляров Item, передав получив-
шийся список List в конструктор множества LinkedHashSet, которое удалит дубли-
каты, но сохранит порядок элементов. Также Hibernate может удалять повторяю-
щиеся элементы с помощью операции DISTINCT и метода distinct() в запросе на
основе критериев:
select distinct i from Item i
left join fetch i.bids
Root<Item> i = criteria.from(Item.class);
i.fetch("bids", JoinType.LEFT);
criteria.select(i).distinct(true);
Обратите внимание, что в данном случае операция DISTINCT выполнится не
в базе данных. В запросе SQL не будет ключевого слова DISTINCT. Фактически вы
не можете удалить повторяющихся записей на уровне объекта ResultSet в SQL.
Hibernate удалит их в памяти так же, как вы делали это с помощью LinkedHashSet.
Такой же синтаксис может использоваться для немедленного извлечения свя-
зей многие к одному и один к одному:
select distinct i from Item i
left join fetch i.bids b
join fetch b.bidder
left join fetch i.seller
Root<Item> i = criteria.from(Item.class);
458  Языки запросов
Fetch<Item, Bid> b = i.fetch("bids", JoinType.LEFT);
b.fetch("bidder");
i.fetch("seller", JoinType.LEFT);
criteria.select(i).distinct(true);
Этот запрос вернет список List<Item>, и каждый экземпляр Item получит ини-
циализированную коллекцию bids. Свойство seller каждого экземпляра Item так-
же будет загружено. И наконец, будет инициализировано свойство bidder (поль-
зователь, сделавший ставку) каждого экземпляра Bid. Это можно сделать в одном
запросе SQL, соединив таблицы ITEM, BID и USERS.
Если написать JOIN FETCH без ключевого слова LEFT, будет выполнена отложенная
загрузка с внутренним соединением (как если бы вы написали INNER JOIN FETCH).
Немедленное внутреннее соединение логично использовать, когда извлекаемые
объекты гарантированно существуют: экземпляр Item должен иметь установлен-
ное свойство seller, а экземпляр Bid – свойство bidder.
Количество одновременно извлекаемых связей при немедленной загрузке, как
и число возвращаемых запросом записей, ограничено. Рассмотрим следующий за-
прос, который инициализирует коллекции Item#bids и Item#images:
select distinct i from Item i
left join fetch i.bids
left join fetch i.images
Root<Item> i = criteria.from(Item.class);
i.fetch("bids", JoinType.LEFT);
i.fetch("images", JoinType.LEFT); Декартово произведение – это плохо
criteria.select(i).distinct(true);
Этот запрос плох тем, что создает декартово произведение коллекций bids и images
и может вернуть результат огромного объема. Мы рассмотрели эту проблему
в разделе 12.2.2.
Стратегия немедленного динамического извлечения в запросах имеет следую-
щие подводные камни.
 Никогда не присваивайте псевдонимы любым связям, извлекаемым немед-
ленно, для использования в ограничениях или проекциях. Запрос left join
fetch i.bids b where b.amount ... не сработает. Нельзя сказать Hibernate: «За-
грузи экземпляры Item и инициализируй коллекцию bids только экземпля-
рами Bid с определенным значением». Вы можете присваивать псевдонимы
немедленно извлекаемым связям для дальнейшего уточнения, например
для извлечения поля bidder каждого объекта Bid: left join fetch i.bids b
join fetch b.bidder.
 Не извлекайте более одной коллекции; в противном случае вы получите
декартово произведение. Но связей с единственным значением можно из-
влечь любое количество – это не приведет к созданию произведения.
 Запросы игнорируют любые стратегии извлечения, определяемые в мета-
данных отображения с помощью аннотации @org.hibernate.annotations.
Столбцы внешних ключей не могут
содержать null. Внутреннее соединение
или внешнее – в данном случае не важно
Соединения  459
Fetch. Например, отображение коллекции bids с параметром org.hibernate.
annotations.FetchMode.JOIN никак не повлияет на выполняемые запросы.
Динамическая стратегия извлечения игнорирует глобальную стратегию из-
влечения. С другой стороны, Hibernate никогда не игнорирует отображае-
мого плана извлечения: Hibernate всегда выбирает параметр FetchType.EAGER,
и во время выполнения запроса вы можете увидеть несколько дополнитель-
ных выражений SQL.
 При немедленном извлечении коллекции возвращаемый Hibernate список
List содержит столько же записей, сколько вернул запрос SQL, в том числе
повторяющиеся ссылки. Вы можете избавиться от дубликатов в памяти –
вручную, с помощью LinkedHashSet, или с помощью ключевого слова DISTINCT
в запросе.
Есть еще один нюанс, заслуживающий внимания. При немедленном извлече-
нии коллекции вы не сможете извлекать результаты запроса из базы данных по-
странично. Как, например, должен отреагировать запрос select i from Item i fetch
i.bids на параметры Query#setFirstResult(21) и Query#setMaxResults(10)?
Очевидно, что вы ожидаете извлечь 10 товаров, начиная с 21-го. Но при этом вы
хотите немедленно извлечь всю коллекцию bids экземпляра Item. В таком случае
база данных не сможет обеспечить постраничного вывода; вы не сможете ограни-
чить результат запроса SQL десятью произвольными записями. Если в запросе
коллекция извлекается немедленно, Hibernate выполнит постраничную выборку
в памяти приложения. Это означает, что в памяти окажутся все экземпляры Item,
и каждый будет иметь инициализированную коллекцию bids. После этого Hibernate
вернет требуемую страницу результатов, например только товары с 21 по 30.
Но в памяти могут поместиться не все товары, и вы, написав такой запрос, ве-
роятно, ожидали, что постраничная выборка будет выполняться на стороне базы
данных! Поэтому Hibernate запишет в журнал предупреждение, если встретит в за-
просе fetch [collectionPath] и вы вызвали setFirstResult() или setMaxResults().
Мы не рекомендуем использовать fetch [collectionPath] вместе с вызовами
setMaxResults() и setFirstResult(). Как правило, всегда можно написать более
простой запрос, извлекающий данные, необходимые для отображения, – мы на-
деемся, что вы не станете использовать постраничную выборку для изменения
данных. Если вам, к примеру, потребуется показать несколько страниц с товарами
и напротив каждого указать количество сделанных ставок, используйте следую-
щий запрос:
select i.id, i.name, count(b)
from Item i left join i.bids b
group by i.id, i.name
Результат этого запроса база данных сможет вывести постранично после вызова
методов setFirstResult() и setMaxResults(). Это будет гораздо эффективнее, чем
извлечение любых экземпляров Item или Bid в память; пусть всю работу сделает
база данных.
Последним способом соединения в JPA является тета-соединение.
460  Языки запросов
15.4.6. Тета-соединения
В традиционном SQL тета-соединение – это декартово произведение с условием
соединения в предложении WHERE, ограничивающим это произведение. В запросах
JPA синтаксис тета-соединения применяется, когда условие соединения не явля-
ется связью по внешнему ключу, отображаемой на связь класса.
Предположим, что вы используете имя пользователя (User) для записи в жур-
нал, а не отображаете связь между LogRecord и User. Этим классам ничего не из-
вестно друг о друге, поскольку они не связаны. Вы можете найти все экземпляры
User и соответствующие им записи в таблице LogRecord с помощью следующего
тета-соединения:
select u, log from User u, LogRecord log
where u.username = log.username
Root<User> u = criteria.from(User.class);
Root<LogRecord> log = criteria.from(LogRecord.class);
criteria.where(
cb.equal(u.get("username"), log.get("username")));
criteria.multiselect(u, log);
Условие соединения в данном случае сравнивает атрибуты username обоих клас-
сов. Если обе записи будут иметь одинаковое значение username, они попадут в ре-
зультат. Результат запроса будет состоять из кортежей:
List<Object[]> result = query.getResultList();
for (Object[] row : result) {
assertTrue(row[0] instanceof User);
assertTrue(row[1] instanceof LogRecord);
}
Возможно, вы будете прибегать к тета-соединениям не слишком часто. Обрати-
те внимание, что в настоящий момент в JPA нельзя задать внешнее соединение для
таблиц, не связанных отображаемой связью; тета-соединения – это внутренние
соединения.
Другим распространенным случаем применения тета-соединений является
сравнение первичного или внешнего ключа с параметрами запроса или с другими
внешними ключами в предложении WHERE:
select i, b from Item i, Bid b
where b.item = i and i.seller = b.bidder
Root<Item> i = criteria.from(Item.class);
Root<Bid> b = criteria.from(Bid.class);
criteria.where(
cb.equal(b.get("item"), i),
cb.equal(i.get("seller"), b.get("bidder"))
);
criteria.multiselect(i, b);
Соединения  461
Этот запрос вернет пары экземпляров Item (товар) и Bid (ставка), где пользо-
ватель, сделавший ставку (bidder), является также продавцом (seller). Для CaveatEmptor
этот запрос играет важную роль, поскольку позволяет вычислить поль-
зователей, делающих ставки за свой собственный товар. Возможно, этот запрос
стоит преобразовать в ограничение базы данных, чтобы не допустить сохранения
подобных экземпляров Bid.
В предыдущем запросе также присутствует интересное выражение сравнения:
i.seller = b.bidder. Это сравнение идентификаторов, которое рассматривается
в следующем разделе.
15.4.7. Сравнение идентификаторов
JPA поддерживает синтаксис неявного сравнения идентификаторов в запросах:
select i, u from Item i, User u
where i.seller = u and u.username like 'j%'
Root<Item> i = criteria.from(Item.class);
Root<User> u = criteria.from(User.class);
criteria.where(
cb.equal(i.get("seller"), u),
cb.like(u.<String>get("username"), "j%")
);
criteria.multiselect(i, u);
В этом запросе свойство i.seller ссылается на столбец внешнего ключа SELLER_
ID таблицы ITEM, который ссылается на таблицу USERS. Псевдоним u ссылается на
первичный ключ таблицы USERS (столбец ID). Следовательно, этот запрос с тета-
соединением является более простым эквивалентом следующего:
select i, u from Item i, User u
where i.seller.id = u.id and u.username like 'j%'
Root<Item> i = criteria.from(Item.class);
Root<User> u = criteria.from(User.class);
criteria.where(
cb.equal(i.get("seller").get("id"), u.get("id")),
cb.like(u.<String>get("username"), "j%")
);
criteria.multiselect(i, u);
Особенности Hibernate
Выражение пути к атрибуту, оканчивающееся на id, имеет особое значение в Hibernate:
имя id всегда ссылается на свойство идентификатора сущности. Не важно,
какое имя на самом деле имеет свойство идентификатора, отмеченное аннотацией
@Id; к нему всегда можно обратиться как псевдонимСущности.id. Поэтому мы совету-
ем всегда давать свойству идентификатора имя id, чтобы избежать путаницы в за-
462  Языки запросов
просах. Обратите внимание, что это не является требованием JPA; особое значение
имени id придается только в Hibernate.
Также может понадобиться сравнить свойство с параметром запроса, например
чтобы найти товары (Item) конкретного продавца (User):
select i from Item i where i.seller = :seller
Root<Item> i = criteria.from(Item.class);
criteria.where(
cb.equal(
i.get("seller"),
cb.parameter(User.class, "seller")
)
);
criteria.select(i);
query.setParameter("seller", someUser);
List<Item> result = query.getResultList();
Этот запрос также можно выразить в терминах идентификаторов, а не ссылок
на объекты. Следующие запросы эквивалентны предыдущим:
select i from Item i where i.seller.id = :sellerId
Root<Item> i = criteria.from(Item.class);
criteria.where(
cb.equal(
i.get("seller").get("id"),
cb.parameter(Long.class, "sellerId")
)
);
criteria.select(i);
query.setParameter("sellerId", USER_ID);
List<Item> result = query.getResultList();
Что касается идентификаторов, есть существенная разница межу этой парой
запросов
select b from Bid b where b.item.name like 'Fo%'
Root<Bid> b = criteria.from(Bid.class);
criteria.select(b).where(
cb.like(
b.get("item").<String>get("name"),
"Fo%"
)
);
и этой:
select b from Bid b where b.item.id = :itemId
CriteriaQuery<Bid> criteria = cb.createQuery(Bid.class);
Root<Bid> b = criteria.from(Bid.class);
Подзапросы  463
criteria.where(
cb.equal(
b.get("item").get("id"),
cb.parameter(Long.class, "itemId")
)
);
criteria.select(b);
В первой паре используется неявное соединение таблиц; во второй – соедине-
ний нет вообще!
На этом мы заканчиваем обсуждение запросов с соединениями. Нашей послед-
ней темой станут запросы внутри запросов, т. е. подзапросы.
15.5. Подзапросы
Подзапросы – это важная и мощная возможность SQL. Подзапрос – это запрос,
встроенный в другой запрос, как правило, в предложении SELECT, FROM или WHERE.
JPA допускает применение подзапросов только в предложении WHERE. Подза-
просы в предложении FROM не поддерживаются, поскольку в языках запросов от-
сутствует транзитивное замыкание. Результат запроса может быть непригоден
для дальнейшей выборки в предложении FROM. Подзапросы в предложении SELECT
также не поддерживаются, но можно отображать подзапросы на вычисляемые
свойства с помощью аннотации @org.hibernate.annotations.Formula, как показано
в разделе 5.1.3.
Подзапросы также могут быть коррелированными.
15.5.1. Коррелированные и некореллированные подзапросы
Подзапрос может вернуть одну или несколько записей. Как правило, подзапросы,
возвращающие одну запись, выполняют агрегацию. Следующий подзапрос вернет
количество товаров, проданных пользователем; внешний запрос вернет всех поль-
зователей, продавших более одного товара:
select u from User u
where (
select count(i) from Item i where i.seller = u
) > 1
Root<User> u = criteria.from(User.class);
Subquery<Long> sq = criteria.subquery(Long.class);
Root<Item> i = sq.from(Item.class);
sq.select(cb.count(i))
.where(cb.equal(i.get("seller"), u)
);
criteria.select(u);
criteria.where(cb.greaterThan(sq, 1L));
464  Языки запросов
Внутренний запрос является коррелированным – он обращается к псевдониму
u из внешнего запроса.
В следующем примере используется некоррелированный подзапрос:
select b from Bid b
where b.amount + 1 >= (
select max(b2.amount) from Bid b2
)
Root<Bid> b = criteria.from(Bid.class);
Subquery<BigDecimal> sq = criteria.subquery(BigDecimal.class);
Root<Bid> b2 = sq.from(Bid.class);
sq.select(cb.max(b2.<BigDecimal>get("amount")));
criteria.select(b);
criteria.where(
cb.greaterThanOrEqualTo(
cb.sum(b.<BigDecimal>get("amount"), new BigDecimal(1)),
sq
)
);
Здесь подзапрос возвращает самую большую ставку во всем приложении; внеш-
ний запрос найдет все ставки со значениями, отличающимися от наибольшей не
более чем на единицу (долларов, евро и т. д.). Обратите внимание, что в обоих при-
мерах подзапрос в JPQL окружают скобки. Это обязательное требование.
Некоррелированные подзапросы безвредны, поэтому используйте их, когда это
удобно. Такие запросы всегда можно разделить на два отдельных запроса, посколь-
ку они не ссылаются друг на друга. Но не забывайте оценивать производительность
коррелированных подзапросов. В больших базах данных стоимость простого кор-
релированного подзапроса сравнима со стоимостью соединения. Но переписать
коррелированный подзапрос в виде двух отдельных запросов возможно не всегда.
В случае, когда подзапрос возвращает несколько записей, к нему применяются
кванторы.
15.5.2. Кванторы
В стандарте определены следующие кванторы:
 ALL – выражение вернет true, если результат сравнения будет истинным для
всех значений в результатах подзапроса. Если хотя бы для одного значения
условие не выполнится, выражение вернет false;
 ANY – выражение вернет true, если результат сравнения будет истинным
хотя бы для одного (любого) значения в результате подзапроса. Если подза-
прос не вернет результатов или ни одно значение не удовлетворяет условию
сравнения, выражение вернет false. Ключевое слово SOME является синони-
мом для ANY;
 EXISTS – выражение вернет true, если подзапрос вернет одно или более зна-
чений.
Подзапросы  465
Например, следующий запрос найдет товары со ставками не выше 10:
select i from Item i
where 10 >= all (
select b.amount from i.bids b
)
Root<Item> i = criteria.from(Item.class);
Subquery<BigDecimal> sq = criteria.subquery(BigDecimal.class);
Root<Bid> b = sq.from(Bid.class);
sq.select(b.<BigDecimal>get("amount"));
sq.where(cb.equal(b.get("item"), i));
criteria.select(i);
criteria.where(
cb.greaterThanOrEqualTo(
cb.literal(new BigDecimal(10)),
cb.all(sq)
)
);
Следующий запрос вернет товары со ставками, равными 101:
select i from Item i
where 101.00 = any (
select b.amount from i.bids b
)
Root<Item> i = criteria.from(Item.class);
Subquery<BigDecimal> sq = criteria.subquery(BigDecimal.class);
Root<Bid> b = sq.from(Bid.class);
sq.select(b.<BigDecimal>get("amount"));
sq.where(cb.equal(b.get("item"), i));
criteria.select(i);
criteria.where(
cb.equal(
cb.literal(new BigDecimal("101.00")),
cb.any(sq)
)
);
Чтобы найти все товары со ставками, примените к результату подзапроса кван-
тор EXISTS:
select i from Item i
where exists (
select b from Bid b where b.item = i
)
Root<Item> i = criteria.from(Item.class);
Subquery<Bid> sq = criteria.subquery(Bid.class);
466  Языки запросов
Root<Bid> b = sq.from(Bid.class);
sq.select(b).where(cb.equal(b.get("item"), i));
criteria.select(i);
criteria.where(cb.exists(sq));
Этот запрос гораздо важнее, чем кажется. Найти все товары со ставками мож-
но также с помощью запроса: select i from Item i where i.bids is not empty. Но это
требует наличия отображаемой коллекции типа один ко многим Item#bids. Если
вы следуете нашим рекомендациям, вы, скорее всего, отобразили «обратную» сто-
рону отношения: связь типа многие к одному Bid#item. Но тот же результат можно
получить с помощью квантора exists() и подзапроса.
Подзапросы – это продвинутая технология; вас всегда должно настораживать
большое количество подзапросов, поскольку запросы с ними часто можно пере-
писать с использованием соединений и функций. Но иногда и они могут быть по-
лезными.
15.6. Резюме
 Если до прочтения этой главы вы уже были знакомы с SQL, теперь вы сможе-
те писать различные запросы с помощью JPQL или API запросов на основе
критериев. Если вы чувствуете себя неуверенно с SQL, обращайтесь к спра-
вочному разделу.
 С помощью выборки описывается источник(и) данных – «таблицы», для ко-
торых пишется запрос. Затем применяются критерии ограничения, чтобы по-
лучить из источника требуемое подмножество «записей». Проекция опреде-
ляет, какие «столбцы» будут возвращены запросом. Также есть возможность
эффективно агрегировать данные на уровне базы данных.
 Мы рассмотрели соединения: как выбирать, ограничивать и объединять дан-
ные из нескольких таблиц. Приложению, использующему JPA, соединения
нужны для немедленной загрузки экземпляров сущностей и коллекций за
одно обращение к базе данных. Это особенно важно, когда требуется умень-
шить нагрузку на базу данных, и мы советуем вам еще раз просмотреть все
примеры, чтобы точно понимать работу соединений и стратегии немедленного
извлечения данных.
 Запросы можно вкладывать в другие запросы, создавая подзапросы.
Глава 16
Дополнительные
возможности запросов
В этой главе:
 преобразование результатов запросов;
 фильтрация коллекций;
 создание запросов на основе критериев с помощью Hibernate.
В этой главе рассматриваются дополнительные возможности запросов: преобра-
зование результатов, фильтрация коллекций и средства в Hibernate для создания
запросов на основе критериев. Сначала рассмотрим интерфейс ResultTransformer,
который позволяет применять преобразования, отличные от используемых в Hibernate
по умолчанию.
В предыдущих главах мы советовали быть осторожнее при отображении кол-
лекций, поскольку это овчинка редко стоит выделки. В этой главе мы познакомим
вас с фильтрами для коллекций – оригинальной функциональностью Hibernate,
позволяющей более эффективно использовать хранимые коллекции. Наконец, мы
познакомим вас с нестандартным интерфейсом org.hibernate.Criteria, а также
рассмотрим ситуации, когда его лучше использовать вместо стандартных запро-
сов на основе критериев JPA.
Начнем с преобразования результатов запросов.
Особенности Hibernate
16.1. Преобразование результатов запросов
С помощью специального преобразователя можно отфильтровать результат за-
проса или обработать его с помощью своей процедуры. В Hibernate определено
несколько преобразователей, которые можно замещать или настраивать.
Мы предполагаем преобразовать результат обычного запроса, но для этого нам
понадобится получить доступ к оригинальному интерфейсу org.hibernate.Query
с помощью экземпляра Session, как показано в листинге 16.1.
468  Дополнительные возможности запросов
Листинг 16.1  Простой запрос с проекцией нескольких атрибутов
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
Session session = em.unwrap(Session.class);
org.hibernate.Query query = session.createQuery(
"select i.id as itemId, i.name as name, i.auctionEnd as auctionEnd from
Item i"
);
Без каких-либо преобразований этот запрос вернет список List с элементами
типа Object[]:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
List<Object[]> result = query.list();
for (Object[] tuple : result) {
Long itemId = (Long) tuple[0];
String name = (String) tuple[1];
Date auctionEnd = (Date) tuple[2];
// ...
}
Каждый массив объектов – это «запись» из результатов запроса. К элементу
кортежа можно обратиться по индексу: 0 – соответствует атрибуту типа Long, 1 -
String, а 2 – Date.
Первый преобразователь, который мы рассмотрим, позволяет получить список
List с элементами типа List.
Преобразование результатов запроса на основе критериев
Все примеры в этом разделе написаны для запросов JPQL, созданных с помощью
org.hibernate.Query. Если создать объект запроса JPA типа CriteriaQuery с помощью
интерфейса CriteriaBuilder, вы не сможете применить к нему преобразо-
ватель org.hibernate.transform.ResultTransformer: этот интерфейс доступен только
в Hibernate. Даже если вы получите оригинальный Hibernate API для своего за-
проса на основе критериев (путем приведения к типу HibernateQuery, как показано
в разделе 14.1.3), вы все равно не сможете применить произвольного преобра-
зователя. К объектам запросов JPA типа CriteriaQuery Hibernate применяет встро-
енный преобразователь, соответствующий спецификации JPA; применение про-
извольного преобразователя переопределит это поведение и создаст проблемы.
Однако для JPQL-запросов, созданных с помощью javax.persistence.Query, можно
установить свой преобразователь, получив доступ к оригинальному интерфейсу
HibernateQuery. Кроме того, далее вы увидите оригинальный интерфейс org.hibernate.
Criteria – альтернативный механизм для запросов на основе критериев,
поддерживающий возможность переопределения org.hibernate.transform.Result-
Transformer.
Преобразование результатов запросов  469
16.1.1. Получение списка списков
Предположим, что вы хотите получить доступ по индексу, но вам не нравится тип
Object[]. Вместо списка элементов Object[] каждый кортеж можно представить
как список List, задействовав преобразователь ToListResultTransformer:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
query.setResultTransformer(
ToListResultTransformer.INSTANCE
);
List<List> result = query.list();
for (List list : result) {
Long itemId = (Long) list.get(0);
String name = (String) list.get(1);
Date auctionEnd = (Date) list.get(2);
// ...
}
Отличие совсем незначительное, но это может быть удобно, если другие уровни
приложения уже работают со списками списков.
Следующий преобразователь представляет каждый кортеж в виде словаря Map,
отображающего псевдонимы в соответствующие элементы проекции.
16.1.2. Получение списка словарей
Преобразователь AliasToEntityMapResultTransformer возвращает список элементов
типа java.util.Map: по одному на каждую «запись». Псевдонимами в запросе явля-
ются itemId, name и auctionEnd:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
query.setResultTransformer(
AliasToEntityMapResultTransformer.INSTANCE
);
List<Map> result = query.list();
assertEquals( Псевдонимы, используемые в запросе
query.getReturnAliases(),
new String[]{"itemId", "name", "auctionEnd"}
);
for (Map map : result) {
Long itemId = (Long) map.get("itemId");
String name = (String) map.get("name");
Date auctionEnd = (Date) map.get("auctionEnd");
// ...
}
470  Дополнительные возможности запросов
Если псевдонимы в запросе неизвестны, их можно получить динамически, вы-
звав метод org.hibernate.Query#getReturnAliases().
В нашем примере запрос возвращает скалярные значения, но вам также может
понадобиться преобразовывать результаты, содержащие экземпляры сущностей.
Следующий пример использует псевдонимы для сущностей из проекции и список
List элементов типа Map:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
org.hibernate.Query entityQuery = session.createQuery(
"select i as item, u as seller from Item i join i.seller u"
);
entityQuery.setResultTransformer(
AliasToEntityMapResultTransformer.INSTANCE
);
List<Map> result = entityQuery.list();
for (Map map : result) {
Item item = (Item) map.get("item");
User seller = (User) map.get("seller");
assertEquals(item.getSeller(), seller);
// ...
}
Еще большую пользу может принести следующий преобразователь, отображающий
атрибуты результатов запроса в свойства компонента JavaBean по их
псевдонимам.
16.1.3. Отображение атрибутов
в свойства компонента JavaBean
В разделе 15.3.2 мы показали, как динамически получить объекты JavaBean, исполь-
зуя конструктор ItemSummary. В JPQL это можно сделать с помощью оператора new.
В запросах на основе критериев – с помощью метода construct(). Класс ItemSummary
должен иметь конструктор, соответствующий набору элементов в проекции.
Но даже если в классе компонента JavaBean отсутствует нужный конструктор,
все равно можно создать его экземпляр и заполнить его с помощью методов записи
и/или прямым обращением к полям с применением объекта AliasToBeanResult-
Transformer. Следующий пример преобразует результаты запроса, показанного
в листинге 16.1:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
query.setResultTransformer(
new AliasToBeanResultTransformer(ItemSummary.class)
);
Преобразование результатов запросов  471
List<ItemSummary> result = query.list();
for (ItemSummary itemSummary : result) {
Long itemId = itemSummary.getItemId();
String name = itemSummary.getName();
Date auctionEnd = itemSummary.getAuctionEnd();
// ...
}
Конструктору преобразователя нужно передать класс компонента JavaBean;
здесь это класс ItemSummary. Hibernate требует, чтобы такой класс не имел кон-
структора или имел общедоступный конструктор без параметров.
Во время преобразования результатов запроса Hibernate отыскивает методы
записи и поля, имена которых совпадают с псевдонимами в запросе. В классе
ItemSummary должны быть определены поля itemId, name и auctionEnd или методы
setItemId(), setName() и setAuctionEnd(). Поля и методы должны иметь правиль-
ный тип. Если только часть псевдонимов из запроса отображается на поля класса,
а оставшаяся часть – на методы записи, это тоже нормально.
Вам также будет полезно узнать, как написать собственный преобразователь
ResultTransformer на тот случай, если ни один из существующих не подходит.
16.1.4. Создание преобразователя ResultTransformer
Преобразователи, встроенные в Hibernate, довольно простые; между результата-
ми, представленными в виде списков, словарей или массивов объектов, нет особой
разницы. Несмотря на то что реализация интерфейса ResultTransformer тривиаль-
на, дополнительная логика преобразования результатов запроса может усилить
связанность уровней кода приложения. Если код пользовательского интерфейса
уже знает, как отображать таблицу на основе списка List<ItemSummary>, пусть Hibernate
возвращает его напрямую из запроса.
Далее мы покажем, как реализовать преобразователь ResultTransformer. Пред-
положим, что требуется получить список List<ItemSummary> из запроса в листинге
16.1, но так, чтобы Hibernate не участвовал в создании экземпляров ItemSummary,
вызывая конструктор через механизм рефлексии. Возможно, класс ItemSummary
предопределен и не имеет нужного конструктора, полей или методов. Зато у вас
есть фабрика ItemSummaryFactory, производящая экземпляры ItemSummary.
Интерфейс ResultTransformer требует реализации методов transformTuple()
и transformList():
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
TransformResults.java
query.setResultTransformer(
new ResultTransformer() {
@Override  Преобразует записи в результате
public Object transformTuple(Object[] tuple, String[] aliases) {
Long itemId = (Long) tuple[0];
472  Дополнительные возможности запросов
String name = (String) tuple[1];
Date auctionEnd = (Date) tuple[2];
assertEquals(aliases[0], "itemId"); При необходимости можно получить
assertEquals(aliases[1], "name"); все псевдонимы запроса
assertEquals(aliases[2], "auctionEnd");
return ItemSummaryFactory.newItemSummary(
itemId, name, auctionEnd
);
}
@Override  Преобразование списка результатов
public List transformList(List collection) {
return Collections.unmodifiableList(collection); Коллекция типа
} List<ItemSummary>
}
);
 Каждый кортеж в результатах запроса, имеющий вид массива Object[], должен быть пре-
образован в нужный объект. Здесь по индексу из массива извлекается каждый элемент
проекции и выполняется вызов фабрики ItemSummaryFactory для получения возвращае-
мого объекта. Hibernate также передает методу список псевдонимов для каждого элемен-
та проекции. Но для данного преобразователя псевдонимы не требуются.
 Вы можете обернуть или модифицировать получившийся список результатов после пре-
образования результатов запроса. Здесь мы сделали возвращаемый список List неизме-
няемым: это отлично подходит для отчета, где никакие данные не должны меняться.
Как показано в примере, преобразование происходит в два этапа: сначала пре-
образуется каждый возвращаемый кортеж в нужный объект. Затем в вашем распо-
ряжении оказывается целый список List этих объектов, который можно обернуть
или преобразовать.
Далее мы обсудим другую удобную особенность Hibernate (не имеющей экви-
валента в JPA): фильтры коллекций.
Особенности Hibernate
16.2. Фильтрация коллекций
В главе 7 вы узнали, когда следует (а скорее, не следует) отображать коллекции
в предметной модели на Java. Самая большая польза от отображения коллекций –
более удобный доступ к данным: вы можете вызывать методы item.getImages()
или item.getBids(), чтобы получить доступ ко всем изображениям или ставкам,
связанным с данным товаром Item. При этом не нужно писать ни запросов JPQL,
ни запросов на основе критериев; Hibernate сделает это за вас, как только вы нач-
нете обход элементов коллекции.
Самая очевидная проблема такого подхода: Hibernate будет всегда выполнять
один и тот же запрос, извлекая все изображения и ставки для товара Item. Вы мо-
Фильтрация коллекций  473
жете настроить порядок элементов коллекции, но только в статическом отображе-
нии. А что делать, если требуется вывести два списка ставок для товара Item, упо-
рядоченных по возрастанию и по убыванию? Вы могли бы вернуться к созданию
собственных запросов и не вызывать метода item.getBids(), но тогда отображение
коллекции может не понадобиться.
Вместо этого вы можете использовать нестандартную особенность Hibernate –
фильтры коллекций, – которая упрощает создание таких запросов с помощью
отображаемых коллекций. Предположим, что у вас есть в памяти хранимый эк-
земпляр Item, возможно, загруженный с помощью EntityManager. Пусть требуется
отобразить все ставки (коллекцию bids) для данного товара Item, а затем наложить
на коллекцию bids ограничение – выбрать только ставки, сделанные конкретным
пользователем User. Также требуется отсортировать список в порядке убывания
значений Bid#amount.
Листинг 16.2  Фильтрация и упорядочение коллекции
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
FilterCollections.java
Item item = em.find(Item.class, ITEM_ID);
User user = em.find(User.class, USER_ID);
org.hibernate.Query query = session.createFilter(
item.getBids(),
"where this.bidder = :bidder order by this.amount desc"
);
query.setParameter("bidder", user);
List<Bid> bids = query.list();
Метод session.createFilter() принимает хранимую коллекцию и фрагмент
запроса JPQL. Этот фрагмент не должен содержать предложений select и from –
только ограничения в предложениях where и order by. Псевдоним this ссылается
на элемент коллекции, в данном случае на экземпляр Bid. Созданный фильтр – это
обычный запрос org.hibernate.Query со связанным параметром, который можно
выполнить, вызвав метод list().
Hibernate не выполняет фильтрацию коллекций в памяти приложения. Если
во время вызова фильтра коллекция Item#bids не была инициализирована, она та-
кой и останется. Более того, фильтры нельзя применять к временным коллекциям
и результатам запроса. Их можно применять только к отображаемым коллекциям,
на которые ссылаются экземпляры сущностей, управляемые контекстом хране-
ния. Термин фильтр в некотором роде вводит в заблуждение, поскольку результа-
том фильтрации будет другая, совершенно новая коллекция; исходная коллекция
никак не изменится.
Ко всеобщему удивлению (включая разработчиков данной функционально-
сти), даже простейшие фильтры могут оказаться полезными. К примеру, пустой
запрос можно использовать для постраничного вывода элементов коллекции:
474  Дополнительные возможности запросов
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
FilterCollections.java
Item item = em.find(Item.class, ITEM_ID);
org.hibernate.Query query = session.createFilter(
item.getBids(),
""
);
query.setFirstResult(0); Вернет только две ставки
query.setMaxResults(2);
List<Bid> bids = query.list();
Здесь Hibernate выполнит запрос, загрузив только два элемента коллекции, на-
чиная с первой строки результата запроса. Обычно вместе с постраничным выво-
дом применяется и упорядочение order by.
В фильтрах коллекций не требуется использовать предложения from, но вы мо-
жете добавить его, если это соответствует вашему стилю. Фильтры коллекций мо-
гут даже не возвращать элементов фильтруемой коллекции.
Следующий фильтр возвращает товар Item, проданный любым из пользовате-
лей, сделавших ставку:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
FilterCollections.java
Item item = em.find(Item.class, ITEM_ID);
org.hibernate.Query query = session.createFilter(
item.getBids(),
"from Item i where i.seller = this.bidder"
);
List<Item> items = query.list();
Используя предложение select, можно определить проекцию. Следующий
фильтр извлекает имена всех пользователей, сделавших ставки:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
FilterCollections.java
Item item = em.find(Item.class, ITEM_ID);
org.hibernate.Query query = session.createFilter(
item.getBids(),
"select distinct this.bidder.username order by this.bidder.username asc"
);
List<String> bidders = query.list();
Все это очень интересно, но основная причина существования фильтров кол-
лекций – в том, что они позволяют извлекать элементы коллекции без ее инициализации.
Для больших коллекций крайне важно добиться хорошей производи-
тельности. Следующий запрос извлекает из коллекции bids все ставки, сделанные
за товар Item, которые больше или равны 100:
Интерфейс запросов на основе критериев в Hibernate  475
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
FilterCollections.java
Item item = em.find(Item.class, ITEM_ID);
org.hibernate.Query query = session.createFilter(
item.getBids(),
"where this.amount >= :param"
);
query.setParameter("param", new BigDecimal(100));
List<Bid> bids = query.list();
Этот код не инициализирует коллекцию Item#bids, но возвращает новую кол-
лекцию.
До появления JPA 2 запросы на основе критериев были доступны лишь в виде
нестандартного API в Hibernate. Сегодня стандартные интерфейсы JPA облада-
ют не меньшей мощностью, чем старый org.hibernate.Criteria, поэтому он редко
бывает нужен. Но есть несколько особенностей, которые доступны только в Hibernate,
такие как запросы по образцу и возможность встраивания произвольных
фрагментов SQL. В следующем разделе приводится краткий обзор интерфейса
org.hibernate.Criteria и некоторых его уникальных возможностей.
Особенности Hibernate
16.3. Интерфейс запросов на основе критериев
в Hibernate
Используя интерфейсы org.hibernate.Criteria и org.hibernate.Example, можно
создавать запросы программно, создавая и объединяя экземпляры org.hibernate.
criterion.*. Далее вы увидите, как использовать эти интерфейсы и как с их помощью
определять выборки, ограничения, соединения и проекции. Мы предпола-
гаем, что вы уже прочли предыдущую главу и знаете, как эти операции транслиру-
ются в код SQL. Для всех запросов, показанных здесь, в предыдущей главе можно
найти эквивалентный пример, так что при необходимости вы сможете сравнить
все три API.
Начнем с самых простых примеров.
16.3.1. Выборка и упорядочение
Следующий запрос загружает все экземпляры Item:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
org.hibernate.Criteria criteria = session.createCriteria(Item.class);
List<Item> items = criteria.list();
476  Дополнительные возможности запросов
Здесь с помощью Session создается экземпляр org.hibernate.Criteria. Также
можно создать отсоединенный запрос DetachedCriteria, не связанный с открытым
контекстом хранения:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
DetachedCriteria criteria = DetachedCriteria.forClass(Item.class);
List<Item> items = criteria.getExecutableCriteria(session).list();
Когда понадобится выполнить этот запрос, «присоедините» его к сеансу Session,
вызвав метод getExecutableCriteria().
Обратите внимание, что такая возможность поддерживается только в API за-
просов на основе критериев Hibernate. При работе с JPA понадобится как мини-
мум объект EntityManagerFactory, чтобы получить объект CriteriaBuilder.
Имеется возможность упорядочить результаты, как в предложении order by
в JPQL. Следующий запрос загрузит все экземпляры User, упорядочив их по име-
ни и фамилии в порядке возрастания:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<User> users =
session.createCriteria(User.class)
.addOrder(Order.asc("firstname"))
.addOrder(Order.asc("lastname"))
.list();
В данном примере используется прием объединения вызовов методов в цепочку;
такие методы, как addOrder(), возвращают исходный объект org.hibernate.Criteria.
Далее мы рассмотрим, как ограничить выбираемые записи.
16.3.2. Ограничения
Следующий запрос возвращает все экземпляры Item, свойство name которых со-
держит строку «Foo»:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Item> items =
session.createCriteria(Item.class)
.add(Restrictions.eq("name", "Foo"))
.list();
Интерфейс Restrictions – это фабрика объектов Criterion, которые можно до-
бавлять в объект Criteria. Ссылка на атрибуты производится с помощью обычных
строк, как, например, "name" для Item#name.
Также можно организовать поиск подстроки, как в операторе like в JPQL. Сле-
дующий запрос найдет всех пользователей (экземпляры User), имена которых
(username) начинаются с «j» или «J»:
Интерфейс запросов на основе критериев в Hibernate  477
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<User> users =
session.createCriteria(User.class)
.add(Restrictions.like("username", "j",
MatchMode.START).ignoreCase())
.list();
Параметр MatchMode.START является эквивалентом шаблона j% в JPQL. Также до-
ступны режимы EXACT, END и ANYWHERE.
С помощью точечной нотации можно обращаться к вложенным атрибутам
встраиваемых типов, таким как Address объекта User.
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<User> users =
session.createCriteria(User.class)
.add(Restrictions.eq("homeAddress.city", "Some City"))
.list();
Отличительной особенностью Criteria API в Hibernate является возможность
добавлять в ограничения фрагменты на языке SQL. Следующий запрос найдет
всех пользователей (экземпляры User), имена которых (username) состоят менее,
чем из восьми символов:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<User> users =
session.createCriteria(User.class)
.add(Restrictions.sqlRestriction(
"length({alias}.USERNAME) < ?",
8,
StandardBasicTypes.INTEGER
)).list();
Hibernate отправит этот фрагмент SQL в базу данных без изменений. Символ под-
становки {alias} нужен для передачи псевдонима таблицы в итоговом запросе SQL;
он всегда ссылается на отображаемую таблицу корневой сущности (USERS в данном
случае). Здесь также используется позиционный параметр (именованные не поддер-
живаются), тип которого определяется значением StandardBasicTypes.INTEGER.
Расширение системы критериев Hibernate
Система запросов на основе критериев в Hibernate допускает расширение: можно,
к примеру, обернуть вызов SQL-функции LENGTH() своей реализацией интерфейса
org.hibernate.criterion.Criterion.
478  Дополнительные возможности запросов
После создания выборки и ограничений нужно добавить в запрос проекцию для
описания возвращаемых данных.
16.3.3. Проекция и агрегирование
Следующий запрос возвращает кортежи, включающие идентификатор, имя поль-
зователя (username) и домашний адрес (homeAddress) для всех пользователей (User):
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Object[]> result =
session.createCriteria(User.class)
.setProjection(Projections.projectionList()
.add(Projections.property("id"))
.add(Projections.property("username"))
.add(Projections.property("homeAddress"))
).list();
Результатом этого запроса будет список (List) элементов типа Object[], по од-
ному массиву на каждый кортеж. Каждый массив содержит элемент типа Long
(или типа, заданного для идентификатора пользователя), String и Address.
Как и при работе с ограничениями, для преобразования элементов проекции
можно использовать произвольные выражения SQL и функции:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<String> result =
session.createCriteria(Item.class)
.setProjection(Projections.projectionList()
.add(Projections.sqlProjection(
"NAME || ':' || AUCTIONEND as RESULT",
new String[]{"RESULT"},
new Type[]{StandardBasicTypes.STRING}
))
).list();
Этот запрос вернет список (List) строк (String), где каждая строка имеет вид
«[Имя товара]:[Дата окончания аукциона]». Второй параметр в проекции – псев-
донимы, используемые в запросе: они необходимы Hibernate, чтобы прочитать
значения из объекта ResultSet. Также необходимо указать тип каждого элемента
проекции/псевдонима: здесь это StandardBasicTypes.STRING.
Hibernate поддерживает группировку и агрегирование. Следующий запрос под-
считает фамилии пользователей:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Object[]> result =
session.createCriteria(User.class)
Интерфейс запросов на основе критериев в Hibernate  479
.setProjection(Projections.projectionList()
.add(Projections.groupProperty("lastname"))
.add(Projections.rowCount())
).list();
Метод rowCount() действует подобно функции count() в JPQL. Следующий за-
прос использует агрегирование, чтобы подсчитать среднюю ставку (Bid) для каж-
дого товара (Item):
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Object[]> result =
session.createCriteria(Bid.class)
.setProjection(Projections.projectionList()
.add(Projections.groupProperty("item"))
.add(Projections.avg("amount"))
).list();
Далее вы узнаете, что Criteria API позволяет также выполнять соединения.
16.3.4. Соединения
Внутренние соединения связанных сущностей задаются с помощью вложенных
объектов Criteria:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Bid> result =
session.createCriteria(Bid.class)
.createCriteria("item")
.add(Restrictions.isNotNull("buyNowPrice"))
.createCriteria("seller")
.add(Restrictions.eq("username", "johndoe"))
.list();
Запрос вернет все ставки (экземпляры Bid) каждого товара (Item) с непустым
полем buyNowPrice, проданного пользователем (User) по имени «johndoe».
Первое внутреннее соединение по связи Bid#item задается вызовом метода
createCriteria("item") корневого объекта Criteria, созданного для класса Bid.
Вложенный объект Criteria определяет путь к связи, для которой выполняется
еще одно внутреннее соединение путем вызова createCriteria("seller"). На оба
соединения наложены ограничения; они объединяются логическим «И» в пред-
ложении where итогового запроса SQL.
Внутренние соединения также можно выразить с помощью метода createAlias()
объекта Criteria.
Ниже предствавлен аналогичный запрос:
List<Bid> result =
session.createCriteria(Bid.class)
Внутреннее
соединение
480  Дополнительные возможности запросов
.createCriteria("item")
.createAlias("seller", "s")
.add(Restrictions.and(
Restrictions.eq("s.username", "johndoe"),
Restrictions.isNotNull("buyNowPrice")
))
.list();
Немедленное динамическое извлечение с помощью внешнего соединения задает-
ся с помощью метода setFetchMode():
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Item> result =
session.createCriteria(Item.class)
.setFetchMode("bids", FetchMode.JOIN)
.list();
Этот запрос вернет все экземпляры Item с коллекциями bids, инициализирован-
ными в этом же запросе SQL.
Остерегайтесь дубликатов
Так же, как при работе с запросами JPQL и запросами на основе критериев JPA,
фреймворк Hibernate может возвращать дубликаты объектов Item. См. обсуждение
этого феномена в разделе 15.4.5.
Точно так же, как в запросах JPQL и запросах на основе критериев JPA, Hibernate
может удалять дубликаты в памяти с помощью операции «distinct»:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Item> result =
session.createCriteria(Item.class)
.setFetchMode("bids", FetchMode.JOIN)
.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY)
.list();
Здесь видно, как преобразователь ResultTransformer, о котором мы говорили ра-
нее в этой главе, может применяться к объекту Criteria.
Вы можете извлечь несколько связей/коллекций в одном запросе:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
List<Item> result =
session.createCriteria(Item.class)
.createAlias("bids", "b", JoinType.LEFT_OUTER_JOIN)
.setFetchMode("b", FetchMode.JOIN)
Внутреннее
соединение
Интерфейс запросов на основе критериев в Hibernate  481
.createAlias("b.bidder", "bdr", JoinType.INNER_JOIN)
.setFetchMode("bdr", FetchMode.JOIN)
.createAlias("seller", "s", JoinType.LEFT_OUTER_JOIN)
.setFetchMode("s", FetchMode.JOIN)
.list();
Этот запрос вернет все экземпляры Item, загрузит для каждого коллекцию
Item#bids, используя внешнее соединение, а потом загрузит поле Bid#bidder, ис-
пользуя внутреннее соединение. Также будет загружено поле Item#seller: посколь-
ку оно не может принимать значения null, для его загрузки можно использовать
любое соединение. Только не загружайте несколько коллекций в одном запросе,
иначе получится декартово произведение (см. раздел 15.4.5).
Далее вы увидите, как с помощью вложенных объектов Criteria описываются
подзапросы.
16.3.5. Подзапросы
Следующий подзапрос вернет всех пользователей (экземпляры User), продающих
более одного товара:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
DetachedCriteria sq = DetachedCriteria.forClass(Item.class, "i");
sq.add(Restrictions.eqProperty("i.seller.id", "u.id"));
sq.setProjection(Projections.rowCount());
List<User> result =
session.createCriteria(User.class, "u")
.add(Subqueries.lt(1l, sq))
.list();
Экземпляр DetachedCriteria описывает запрос, возвращающий количество то-
варов, проданных данным пользователем (User). Поскольку ограничение зависит
от псевдонима u, это коррелированный подзапрос. «Внешний» запрос, включаю-
щий объект DetachedCriteria, подставит реальное значение псевдонима u. Обрати-
те внимание, что подзапрос является правым операндом оператора lt() (меньше,
чем), который преобразуется в код SQL: 1 < ([Количество результатов запроса]).
В Hibernate также можно использовать кванторы. Например, следующий за-
прос найдет товары со ставками не выше 10:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
DetachedCriteria sq = DetachedCriteria.forClass(Bid.class, "b");
sq.add(Restrictions.eqProperty("b.item.id", "i.id"));
sq.setProjection(Projections.property("amount"));
List<Item> result =
session.createCriteria(Item.class, "i")
.add(Subqueries.geAll(new BigDecimal(10), sq))
.list();
482  Дополнительные возможности запросов
И снова позиция операнда говорит о том, что сравнение основано на операторе
geAll() (больше или равно каждому), который найдет все ставки, не превышаю-
щие 10.
Итак, у вас уже есть несколько причин для использования org.hibernate.Criteria
API. Тем не менее в новых приложениях лучше всего использовать стан-
дартизованные языки запросов JPA. Самой интересной особенностью старого API
является возможность встраивания выражений SQL в ограничения и проекции.
Другой интересной особенностью Hibernate являются запросы по образцу.
16.3.6. Запросы по образцу
Идея запросов по образцу заключается в передаче экземпляра сущности фрейм-
ворку Hibernate, который в ответ должен загрузить все экземпляры сущностей,
похожие на образец. Это может пригодиться в пользовательском интерфейсе, где
имеется сложный экран с настройками, поскольку отпадает необходимость созда-
вать дополнительные классы для хранения поисковых запросов.
Предположим, что в приложении есть форма, позволяющая выполнить поиск
пользователей (экземпляры User) по фамилии. Вы можете связать поле «фами-
лия» в форме со свойством User#lastname и попросить Hibernate загрузить «по-
хожих» пользователей (экземпляры User):
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
User template = new User();  Создание пустого экземпляра User
template.setLastname("Doe");
org.hibernate.criterion.Example example = Example.create(template);
example.ignoreCase();
example.enableLike(MatchMode.START);
example.excludeProperty("activated");  Игнорировать статус активности
List<User> users =  Добавить объект Example в качестве ограничения
session.createCriteria(User.class)
.add(example)
.list();
 Создать «пустой» экземпляр User, который будет играть роль образца, установив иско-
мые значения свойств – фамилию «Doe».
 На основе образца создать экземпляр Example. Этот класс позволит точнее настроить по-
иск. Здесь используется поиск подстроки и игнорируется регистр символов, поэтому
критериям поиска будет соответствовать строка «Doe», «doeX» или «Doe Y».
 Класс User имеет поле activated типа boolean. Поскольку простой тип не может прини-
мать значения null, его значением по умолчанию будет false; поэтому Hibernate вклю-
чит в круг поиска неактивных пользователей. Но, поскольку нужно найти всех пользо-
вателей, следует сообщить Hibernate, чтобы он это поле проигнорировал.
 Объект Example добавляется как ограничение в запрос, представленный объектом Criteria.
 Создание экземпляра
Example
Интерфейс запросов на основе критериев в Hibernate  483
Поскольку класс сущности User написан в соответствии с соглашением Java-
Bean, связать его с интерфейсом пользователя (UI) проще простого. Он имеет не-
обходимые методы чтения/записи, а создать «пустой» экземпляр можно, исполь-
зуя общедоступный конструктор без аргументов (см. обсуждение проектирования
конструкторов в разделе 3.2.3).
Очевидным недостатком Example является применение настроек сравнения
строк, таких как ignoreCase() и enableLike(), ко всем строковым свойствам образ-
ца. Если бы мы одновременно искали имя (firstname) и фамилию (lastname), игно-
рирование регистра символов выполнялось бы для обоих свойств.
По умолчанию в ограничения запроса добавляются все свойства образца сущ-
ности, значение которых отлично от null. Как было показано в последнем при-
мере, можно вручную исключить из поиска свойства образца, используя метод
excludeProperty(). Аналогично, с помощью метода excludeZeroes(), можно исклю-
чить свойства с нулевыми значениями (типа int или long) или отменить любые
исключения с помощью метода excludeNone(). В последнем случае любые свой-
ства образца, имеющие значение null, также будут добавлены в ограничение SQL-
запроса в виде проверки is null.
Если нужен более полный контроль за включением и исключением свойств,
можно расширить класс Example, используя собственный селектор PropertySelector:
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
class ExcludeBooleanExample extends Example {
ExcludeBooleanExample(Object template) {
super(template, new PropertySelector() {
@Override
public boolean include(Object propertyValue,
String propertyName,
Type type) {
return propertyValue != null
&& !type.equals(StandardBasicTypes.BOOLEAN);
}
});
}
}
Этот селектор исключает любые свойства со значением null (так же, как селек-
тор по умолчанию), но, кроме этого, исключает логические свойства (такие как
User#activated).
После добавления образца Example в объект Criteria в виде ограничения можно
определить дополнительные ограничения. Также можно создать запрос на основе
нескольких образцов. Следующий запрос вернет все товары (экземпляры Item)
с названиями (name), начинающимся с «B» или «b», и свойством seller, совпадающим
с объектом User:
484  Дополнительные возможности запросов
Файл: /examples/src/test/java/org/jpwh/test/querying/advanced/
HibernateCriteria.java
Item itemTemplate = new Item();
itemTemplate.setName("B");
Example exampleItem = Example.create(itemTemplate);
exampleItem.ignoreCase();
exampleItem.enableLike(MatchMode.START);
exampleItem.excludeProperty("auctionType");
exampleItem.excludeProperty("createdOn");
User userTemplate = new User();
userTemplate.setLastname("Doe");
Example exampleUser = Example.create(userTemplate);
exampleUser.excludeProperty("activated");
List<Item> items =
session
.createCriteria(Item.class)
.add(exampleItem)
.createCriteria("seller").add(exampleUser)
.list();
А теперь представьте, сколько кода SQL/JDBC потребовалось бы написать
вручную, чтобы создать такой поисковый запрос.
16.4. Резюме
 Вы познакомились с использованием ResultTransformer для преобразования
результатов запроса и узнали, как вернуть список списков, список словарей
и как отобразить псевдонимы в свойства сущностей.
 Мы рассмотрели механизм фильтрации коллекций в Hibernate, помогающий
упростить взаимодействия с хранимыми коллекциями.
 Вы познакомились с интерфейсом запросов Criteria в Hibernate и узнали,
в каких ситуациях он может заменить стандартные запросы на основе крите-
риев JPA. Мы рассмотрели все возможности данного API: выборки и упорядо-
чение, проекции и агрегирование, а также соединения, подзапросы и запросы
на основе образцов.
Глава 17
Настройка
SQL-запросов
В этой главе:
 назад к JDBC;
 отображение результатов SQL-запросов;
 настройка операций CRUD;
 вызов хранимых процедур.
В этой главе мы рассмотрим настройку SQL-запросов и способы их интеграции
с приложениями Hibernate. Язык SQL был создан в 1970 году, но ANSI (American
National Standard Institute – Американский институт стандартов) стандартизовал
его лишь в 1986-м. Несмотря на то что каждое обновление стандарта SQL добавляло
новые возможности (иногда довольно противоречивые), все СУБД поддерживают
SQL по-своему. Заботы о переносимости лежат на плечах разработчиков баз данных.
И здесь на помощь приходит Hibernate: его встроенный язык запросов генерирует
код SQL в соответствии с настроенным диалектом базы данных. Диалекты также
влияют на весь автоматически генерируемый код SQL (например, используемый
для извлечения коллекции по требованию). Простой заменой диалекта можно ин-
тегрировать свое приложение с другой СУБД. Hibernate генерирует все выражения
SQL за вас: операции создания, чтения, изменения и удаления (CRUD).
Но иногда может потребоваться нечто большее, чем могут дать Hibernate и Java
Persistence API, и тогда приходится спускаться на более низкий уровень абстра-
ции. Используя Hibernate, можно выполнять произвольные выражения SQL:
 можно вернуться к использованию JDBC API и работать напрямую с интер-
фейсами Connection, PreparedStatement и ResultSet. В Hibernate имеется ин-
терфейс Connection, поэтому вам не придется управлять отдельным пулом
соединений, и все ваши выражения SQL будут выполняться в рамках одной
(текущей) транзакции;
 можно писать SQL-выражения SELECT, встраивая их в Java-код или сохра-
няя в отдельном XML-файле или аннотациях в виде именованных запросов.
Эти SQL-запросы будут выполняться с помощью Java Persistence API, как
обычные запросы JPQL. Hibernate сможет преобразовать результаты в со-
486  Настройка SQL-запросов
ответствии с заданным отображением. Этот прием можно также использо-
вать для вызова хранимых процедур;
 SQL-выражения, сгенерированные фреймворком Hibernate, можно заме-
нить своими собственными, написанными вручную. Это значит, что при за-
грузке экземпляра сущности методом em.find() или при загрузке коллекции
по требованию данные будет извлекать ваш собственный запрос SQL. Мож-
но даже написать собственный язык управления данными (Data Manipulation
Language, DML), включающий такие инструкции, как UPDATE, INSERT
и DELETE. А также для выполнения операций CRUD можно вызывать хра-
нимые процедуры. Все автоматически сгенерированные выражения SQL
можно заменить собственным кодом.
Мы начнем эту главу с использования обычного JDBC, а затем обсудим воз-
можности Hibernate по отображению результатов запроса. Потом покажем, как
в Hibernate переопределяются запросы и DML-операции. И в завершение расска-
жем об интеграции с хранимыми процедурами в базе данных.
Главные нововведения в JPA 2
• Результаты SQL-запросов можно отображать в вызовы конструкторов.
• С помощью StoredProcedureQuery можно вызывать хранимые процедуры и функ-
ции непосредственно.
Особенности Hibernate
17.1. Назад к JDBC
Иногда бывает нужно обращаться к базе данных напрямую, с помощью JDBC API
и минуя Hibernate. Для этого вам понадобится интерфейс java.sql.Connection,
с помощью которого можно создать и выполнить запрос (объект PreparedStatement),
а также напрямую обратиться к результатам запроса (объекту ResultSet).
Поскольку Hibernate уже знает, как создавать и закрывать соединение с базой дан-
ных, он может передать вашему приложению объект Connection и автоматически
освободить его, когда надобность в нем отпадет.
Эта функциональность доступна благодаря интерфейсу, org.hibernate.jdbc.
Work, основанному на обратных вызовах. Все взаимодействие с JDBC заключено
в реализации этого интерфейса; Hibernate вызовет ее, передав объект Connection.
Следующий пример выполняет SQL-запрос SELECT и производит обход результа-
тов в коллекции ResultSet.
Листинг 17.1  Инкапсуляция взаимодействия с интерфейсами JDBC
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/JDBCFallback.java
public class QueryItemWork implements org.hibernate.jdbc.Work {
final protected Long itemId;  Идентикатор экземпляра Item
Назад к JDBC  487
public QueryItemWork(Long itemId) {
this.itemId = itemId;
}
@Override  Вызов метода execute()
public void execute(Connection connection) throws SQLException {
PreparedStatement statement = null;
ResultSet result = null;
try {
statement = connection.prepareStatement(
"select * from ITEM where ID = ?"
);
statement.setLong(1, itemId);
result = statement.executeQuery();
while (result.next()) {
String itemName = result.getString("NAME");
BigDecimal itemPrice = result.getBigDecimal("BUYNOWPRICE");
// ...
}
} finally {
if (result != null)  Освобождение ресурсов
result.close();
if (statement != null)
statement.close();
}
}
}
 Для выполнения этого запроса нужен идентификатор товара, поэтому в классе опреде-
лено финальное поле, устанавливаемое через параметр конструктора.
 Hibernate вызывает метод execute() и передает ему объект Connection. Вам не нужно за-
крывать соединение по завершении работы.
 Но не забудьте освободить остальные ресурсы, такие как PreparedStatement и ResultSet.
Выполнить работу, представленную объектом Work, можно с помощью Session:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/JDBCFallback.java
UserTransaction tx = TM.getUserTransaction();
tx.begin();
EntityManager em = JPA.createEntityManager();
Session session = em.unwrap(Session.class);
session.doWork(new QueryItemWork(ITEM_ID));
tx.commit();
em.close();
В данном случае соединение (Connection), возвращаемое Hibernate, будет на-
ходиться в границах текущей системной транзакции. Все ваши изменения будут
488  Настройка SQL-запросов
зафиксированы с подтверждением системной транзакции, а все операции, выпол-
няются они с помощью EntityManager или Session, будут являться частью одной
единицы работы. Если вам потребуется вернуть приложению результат выполне-
ния «работы», используйте интерфейс org.hibernate.jdbc.ReturningWork.
Для JDBC-операций, выполняемых внутри реализации интерфейса Work, нет
никаких ограничений. Чтобы вызвать хранимую процедуру, вместо PreparedStatement
можно использовать CallableStatement; в вашем распоряжении полный до-
ступ к JDBC API.
Для более простых запросов и работы с коллекцией ResultSet, такой как в пре-
дыдущем примере, есть более удобная альтернатива.
17.2. Отображение результатов SQL-запросов
После выполнения SQL-запроса SELECT с помощью JDBC API или вызова храни-
мой процедуры, возвращающей коллекцию ResultSet, выполняется обход записей
в результатах и извлекаются нужные данные. Это довольно трудоемкая задача,
требующая раз за разом писать один и тот же код.
Быстрая проверка выражений SQL
Для упрощения тестирования сценариев SQL с несколькими СУБД без запуска ло-
кального сервера можно воспользоваться онлайн-службой SQL Fiddle по адресу:
http://sqlfiddle.com.
Hibernate предлагает альтернативное решение: выполнить обычный SQL-запрос
или вызвать хранимую процедуру можно с помощью Hibernate/Java Persistence
API, но вместо коллекции ResultSet этот механизм вернет список List с нуж-
ными экземплярами. Результат запроса ResultSet можно отобразить в любой класс
по вашему усмотрению, а Hibernate сделает все необходимые преобразования.
ЗАМЕЧАНИЕ В этом разделе мы будем говорить только о SQL-запросах SELECT.
Однако тот же программный интерфейс можно использовать для выпол-
нения запросов UPDATE и INSERT, как будет показано в разделе 20.1.
Особенности Hibernate
На сегодняшний день существуют два API для выполнения запросов SQL и пре-
образования их результатов:
 стандартизированный Java Persistence API с методом EntityManager#create
NativeQuery() для встроенных SQL-выражений и аннотацией @NamedNative-
Query для запросов, хранящихся в отдельных файлах. Результаты запроса
можно отобразить с помощью аннотации @SqlResultSetMapping или опреде-
лить отображение в JPA-файле orm.xml. Также можно поместить именован-
ные SQL-запросы в XML-файлы JPA;
Отображение результатов SQL-запросов  489
 нестандартный и более старый механизм Hibernate с методом Session#
createSQLQuery() и интерфейсом org.hibernate.SQLQuery для отображе-
ния результатов запроса. Также можно помещать именованные SQL-запросы
и отображения результатов в XML-файлы метаданных Hibernate.
Возможности Hibernate шире. Например, он поддерживает немедленную за-
грузку коллекций и связей сущностей в отображениях результатов SQL-запросов.
В следующих разделах мы сравним два API на примере одних и тех же запросов.
Начнем с простого встроенного SQL-запроса и отображения скалярного резуль-
тата проекции.
17.2.1. Проекции в SQL-запросах
Следующий запрос вернет список List элементов типа Object[], где каждый эле-
мент представляет кортеж (запись) SQL-проекции:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select NAME, AUCTIONEND from {h-schema}ITEM"
);
List<Object[]> result = query.getResultList();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof String);
assertTrue(tuple[1] instanceof Date);}
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select NAME, AUCTIONEND from {h-schema}ITEM"
);
List<Object[]> result = query.list();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof String);
assertTrue(tuple[1] instanceof Date);
}
Методы em.createNativeQuery() и session.createSQLQuery() могут принимать
обычные запросы SQL в виде строк.
В данном случае запрос извлекает значения столбцов NAME и AUCTIONEND из таблицы
ITEM, а Hibernate автоматически преобразует их в значения типа String
и java.util.Date. Для определения типов конкретных элементов фреймворк Hibernate
обращается к метаданным java.sql.ResultSetMetaData. Ему известно, что
тип VARCHAR отображается в тип String, а TIMESTAMP – в тип java.util.Date (как объ-
яснялось в разделе 5.3).
Механизм обработки SQL-запросов в Hibernate поддерживает несколько удоб-
ных символов подстановки, таких как {h-schema} в предыдущем примере. Hibernate
заменит символ подстановки схемой, указанной по умолчанию для единицы
490  Настройка SQL-запросов
хранения (параметр hibernate.default_schema). В числе других символов подста-
новки можно назвать {h-catalog} (каталог SQL по умолчанию) и {h-domain} (объ-
единяет значения каталога и схемы).
Самое большое преимущество выполнения SQL-выражений с помощью Hibernate
состоит в автоматическом преобразовании результатов в экземпляры классов
предметной модели.
17.2.2. Отображение в классы сущностей
Следующий запрос SQL вернет список List экземпляров сущности Item:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select * from ITEM",
Item.class
);
List<Item> result = query.getResultList();
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select * from ITEM"
);
query.addEntity(Item.class);
List<Item> result = query.list();
Полученные экземпляры Item будут находиться в хранимом состоянии под
управлением текущего контекста хранения. Он вернет тот же результат, что
и JPQL-запрос select i from Item i.
Для данного преобразования Hibernate выполнит обход результатов SQL-запроса
и попытается отыскать имена и типы столбцов в метаданных отображе-
ния. Если столбец AUCTIONEND отображается в свойство Item#auctionEnd, Hibernate
будет знать, как это свойство заполнить, и вернет целиком загруженные
экземпляры.
Обратите внимание: Hibernate ожидает, что запрос вернет все столбцы, необхо-
димые для создания экземпляра Item, включая свойства, встроенные компонен-
ты и значения столбцов внешних ключей. Если Hibernate не удастся обнаружить
отображаемый столбец (по имени) в результате запроса, он возбудит исключение.
Чтобы получить такие же имена столбцов, как в метаданных отображения сущ-
ности, могут понадобиться псевдонимы в SQL.
Оба интерфейса, javax.persistence.Query и org.hibernate.SQLQuery, поддержи-
вают связывание параметров. Следующий запрос вернет только один экземпляр
сущности Item:
Отображение результатов SQL-запросов  491
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select * from ITEM where ID = ?",
Item.class
);
query.setParameter(1, ITEM_ID); Нумерация параметров начинается с 1
List<Item> result = query.getResultList();
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select * from ITEM where ID = ?"
);
query.addEntity(Item.class);
query.setParameter(0, ITEM_ID); Нумерация параметров начинается с 0
List<Item> result = query.list();
По историческим причинам Hibernate нумерует параметры, начиная с нуля,
тогда как JPA – с единицы. По этой причине предпочтительнее использовать име-
нованные параметры:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select * from ITEM where ID = :id",
Item.class
);
query.setParameter("id", ITEM_ID);
List<Item> result = query.getResultList();
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select * from ITEM where ID = :id"
);
query.addEntity(Item.class);
query.setParameter("id", ITEM_ID);
List<Item> result = query.list();
Несмотря на то что параметризованные запросы поддерживаются в обоих API,
спецификация JPA не считает именованные параметры в обычных запросах пере-
носимыми. Следовательно, не все реализации JPA поддерживают именованные
параметры в обычных запросах.
Если SQL-запрос возвращает не все столбцы, описанные в отображении клас-
са сущности Java, и его нельзя переписать, используя псевдонимы, следует явно
определить отображение результатов запроса.
492  Настройка SQL-запросов
17.2.3. Настройка отображения запросов
Следующий запрос SQL вернет список List управляемых экземпляров сущности
Item: все столбцы таблицы ITEM включены в SQL-проекцию, что требуется для соз-
дания экземпляров Item. Но столбец NAME в проекции переименован в EXTENDED_
NAME с помощью псевдонима:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select " +
"i.ID, " +
"'Auction: ' || i.NAME as EXTENDED_NAME, " +
"i.CREATEDON, " +
"i.AUCTIONEND, " +
"i.AUCTIONTYPE, " +
"i.APPROVED, " +
"i.BUYNOWPRICE, " +
"i.SELLER_ID " +
"from ITEM i",
"ItemResult"
);
List<Item> result = query.getResultList();
Hibernate в этом случае не сможет автоматически сопоставить поля результата
запроса со свойствами сущности Item: потому что столбца NAME больше нет. Следо-
вательно, нужно указать способ отображения результата с помощью второго пара-
метра метода createNativeQuery(); в данном случае ItemResult.
Отображение полей результата запроса в свойства сущности
Это отображение можно настроить с помощью аннотаций, например в классе
Item:
Файл: /model/src/main/java/org/jpwh/model/querying/Item.java
@SqlResultSetMappings({
@SqlResultSetMapping(
name = "ItemResult",
entities =
@EntityResult(
entityClass = Item.class,
fields = {
@FieldResult(name = "id", column = "ID"),
@FieldResult(name = "name", column = "EXTENDED_NAME"),
@FieldResult(name = "createdOn", column = "CREATEDON"),
@FieldResult(name = "auctionEnd", column = "AUCTIONEND"),
@FieldResult(name = "auctionType", column = "AUCTIONTYPE"),
@FieldResult(name = "approved", column = "APPROVED"),
@FieldResult(name = "buyNowPrice", column = "BUYNOWPRICE"),
Отображение результатов SQL-запросов  493
@FieldResult(name = "seller", column = "SELLER_ID")
}
)
)
})
@Entity
public class Item {
// ...
}
Все поля в результате запроса должны отображаться в свойства класса сущно-
сти. Даже если только одно свойство/столбец (EXTENDED_NAME) не совпадает с за-
данным отображением, все равно нужно перечислять все свойства и столбцы.
Отображения результатов запросов SQL, заданные в виде аннотаций, трудно
читать, и, кроме того, аннотации JPA можно размещать только перед определени-
ем класса, а не в файле метаданных package-info.java. Мы предпочитаем хранить
такие отображения в файлах XML. Ниже показано точно такое же отображение:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="ExternalizedItemResult">
<entity-result entity-class="org.jpwh.model.querying.Item">
<field-result name="id" column="ID"/>
<field-result name="name" column="EXTENDED_NAME"/>
<field-result name="createdOn" column="CREATEDON"/>
<field-result name="auctionEnd" column="AUCTIONEND"/>
<field-result name="auctionType" column="AUCTIONTYPE"/>
<field-result name="approved" column="APPROVED"/>
<field-result name="buyNowPrice" column="BUYNOWPRICE"/>
<field-result name="seller" column="SELLER_ID"/>
</entity-result>
</sql-result-set-mapping>
Если отображения будут называться одинаково, приоритет будет отдан отобра-
жениям из файла XML.
Сам SQL-запрос можно определить с помощью аннотации @NamedNativeQuery
или элемента <namednative-query>, как было показано в разделе 14.4. В следующих
примерах мы будем размещать выражения SQL в Java-коде, поскольку так вам
будет проще понять его логику. Но в практике чаще встречаются отображения ре-
зультатов, задаваемые с помощью более краткого синтаксиса XML.
Давайте сначала повторим предыдущий запрос, используя нестандартный ин-
терфейс Hibernate:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"i.ID as {i.id}, " +
494  Настройка SQL-запросов
"'Auction: ' || i.NAME as {i.name}, " +
"i.CREATEDON as {i.createdOn}, " +
"i.AUCTIONEND as {i.auctionEnd}, " +
"i.AUCTIONTYPE as {i.auctionType}, " +
"i.APPROVED as {i.approved}, " +
"i.BUYNOWPRICE as {i.buyNowPrice}, " +
"i.SELLER_ID as {i.seller} " +
"from ITEM i"
);
query.addEntity("i", Item.class);
List<Item> result = query.list();
В Hibernate отображение результатов запроса можно задать прямо в тексте са-
мого запроса, используя символы подстановки с псевдонимами. Значение псевдо-
нима i задается вызовом метода addEntity(). Теперь Hibernate сможет сгенериро-
вать настоящие псевдонимы в проекции SQL, используя символы подстановки,
такие как {i.name} и {i.auctionEnd}, указывающие на свойства сущности Item. Дру-
гих определений в отображении результатов запроса не требуется; Hibernate сге-
нерирует псевдоним в коде SQL и сможет прочитать значения полей коллекции
ResultSet. Это гораздо удобнее, чем отображать результаты запросов в JPA.
Но если код SQL нельзя изменить, отображения можно определить с помощью
методов addRoot() и addProperty() объекта org.hibernate.SQLQuery:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"i.ID, " +
"'Auction: ' || i.NAME as EXTENDED_NAME, " +
"i.CREATEDON, " +
"i.AUCTIONEND, " +
"i.AUCTIONTYPE, " +
"i.APPROVED, " +
"i.BUYNOWPRICE, " +
"i.SELLER_ID " +
"from ITEM i"
);
query.addRoot("i", Item.class)
.addProperty("id", "ID")
.addProperty("name", "EXTENDED_NAME")
.addProperty("createdOn", "CREATEDON")
.addProperty("auctionEnd", "AUCTIONEND")
.addProperty("auctionType", "AUCTIONTYPE")
.addProperty("approved", "APPROVED")
.addProperty("buyNowPrice", "BUYNOWPRICE")
.addProperty("seller", "SELLER_ID");
List<Item> result = query.list();
Отображение результатов SQL-запросов  495
Так же, как в стандартном API, в Hibernate можно задать имя существующего
отображения:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"i.ID, " +
"'Auction: ' || i.NAME as EXTENDED_NAME, " +
"i.CREATEDON, " +
"i.AUCTIONEND, " +
"i.AUCTIONTYPE, " +
"i.APPROVED, " +
"i.BUYNOWPRICE, " +
"i.SELLER_ID " +
"from ITEM i"
);
query.setResultSetMapping("ItemResult");
List<Item> result = query.list();
Еще одна ситуация, когда приходится задавать собственное отображение ре-
зультатов запроса, – повторение имен столбцов в результатах запроса SQL.
Отображение повторяющихся полей
Следующий запрос загрузит всех продавцов (поле seller) всех товаров (экзем-
пляров Item) в одном выражении, соединив таблицы ITEM и USERS:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select " +
"i.ID as ITEM_ID, " +
"i.NAME, " +
"i.CREATEDON, " +
"i.AUCTIONEND, " +
"i.AUCTIONTYPE, " +
"i.APPROVED, " +
"i.BUYNOWPRICE, " +
"i.SELLER_ID, " +
"u.ID as USER_ID, " +
"u.USERNAME, " +
"u.FIRSTNAME, " +
"u.LASTNAME, " +
"u.ACTIVATED, " +
"u.STREET, " +
"u.ZIPCODE, " +
"u.CITY " +
"from ITEM i join USERS u on u.ID = i.SELLER_ID",
496  Настройка SQL-запросов
"ItemSellerResult"
);
List<Object[]> result = query.getResultList();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof Item);
assertTrue(tuple[1] instanceof User);
Item item = (Item) tuple[0];
assertTrue(Persistence.getPersistenceUtil().isLoaded(item, "seller"));
assertEquals(item.getSeller(), tuple[1]);
}
Фактически это немедленная загрузка связи Item#seller. Hibernate знает, что
каждая запись содержит поля для экземпляров сущностей Item и User, связанных
внешним ключом SELLER_ID.
В данном случае в результатах запроса будут повторяться имена столбцов, со-
ответствующих i.ID и u.ID. Им присвоены псевдонимы ITEM_ID и USER_ID, поэтому
вы должны настроить отображение результата запроса:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="ItemSellerResult">
<entity-result entity-class="org.jpwh.model.querying.Item">
<field-result name="id" column="ITEM_ID"/>
<field-result name="name" column="NAME"/>
<field-result name="createdOn" column="CREATEDON"/>
<field-result name="auctionEnd" column="AUCTIONEND"/>
<field-result name="auctionType" column="AUCTIONTYPE"/>
<field-result name="approved" column="APPROVED"/>
<field-result name="buyNowPrice" column="BUYNOWPRICE"/>
<field-result name="seller" column="SELLER_ID"/>
</entity-result>
<entity-result entity-class="org.jpwh.model.querying.User">
<field-result name="id" column="USER_ID"/>
<field-result name="name" column="NAME"/>
<field-result name="username" column="USERNAME"/>
<field-result name="firstname" column="FIRSTNAME"/>
<field-result name="lastname" column="LASTNAME"/>
<field-result name="activated" column="ACTIVATED"/>
<field-result name="homeAddress.street" column="STREET"/>
<field-result name="homeAddress.zipcode" column="ZIPCODE"/>
<field-result name="homeAddress.city" column="CITY"/>
</entity-result>
</sql-result-set-mapping>
Как и прежде, требуется связать все поля каждой полученной сущности с име-
нами столбцов, даже если от первоначального отображения отличаются только
два из них.
Отобразить результаты такого запроса в Hibernate намного проще:
Отображение результатов SQL-запросов  497
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"{i.*}, {u.*} " +
"from ITEM i join USERS u on u.ID = i.SELLER_ID"
);
query.addEntity("i", Item.class);
query.addEntity("u", User.class);
List<Object[]> result = query.list();
Hibernate сгенерирует уникальные псевдонимы для символов подстановки
{i.*} и {u.*} в SQL-выражении, поэтому в запросе не будет одинаковых имен
столбцов.
В предыдущем отображении результатов запросов JPA вы, должно быть, заме-
тили использование точечной нотации при обращении ко встроенному компонен-
ту homeAddress экземпляра User. Давайте еще раз рассмотрим этот особый случай.
Отображение полей в свойства компонентов
Класс User имеет свойство homeAddress, встроенный экземпляр класса Address.
Следующий запрос загрузит всех пользователей (экземпляры User):
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select " +
"u.ID, " +
"u.USERNAME, " +
"u.FIRSTNAME, " +
"u.LASTNAME, " +
"u.ACTIVATED, " +
"u.STREET as USER_STREET, " +
"u.ZIPCODE as USER_ZIPCODE, " +
"u.CITY as USER_CITY " +
"from USERS u",
"UserResult"
);
List<User> result = query.getResultList();
В этом запросе переименованы столбцы STREET, ZIPCODE и CITY, поэтому их нуж-
но вручную отобразить в свойства встроенного компонента:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="UserResult">
<entity-result entity-class="org.jpwh.model.querying.User">
<field-result name="id" column="ID"/>
<field-result name="name" column="NAME"/>
498  Настройка SQL-запросов
<field-result name="username" column="USERNAME"/>
<field-result name="firstname" column="FIRSTNAME"/>
<field-result name="lastname" column="LASTNAME"/>
<field-result name="activated" column="ACTIVATED"/>
<field-result name="homeAddress.street" column="USER_STREET"/>
<field-result name="homeAddress.zipcode" column="USER_ZIPCODE"/>
<field-result name="homeAddress.city" column="USER_CITY"/>
</entity-result>
</sql-result-set-mapping>
Мы уже использовали точечную нотацию несколько раз, когда говорили
о встроенных компонентах: обратиться к свойству street компонента, на который
ссылается свойство homeAddress, можно как homeAddress.street. Для вложенных
встроенных компонентов можно использовать выражения вроде homeAddress.
city.name, если City – не простая строка, а другой встраиваемый класс.
Hibernate также поддерживает точечную нотацию в символах подстановки
для свойств компонентов. Ниже показан тот же самый запрос с таким же самым
отображением
результатов:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"u.ID as {u.id}, " +
"u.USERNAME as {u.username}, " +
"u.FIRSTNAME as {u.firstname}, " +
"u.LASTNAME as {u.lastname}, " +
"u.ACTIVATED as {u.activated}, " +
"u.STREET as {u.homeAddress.street}, " +
"u.ZIPCODE as {u.homeAddress.zipcode}, " +
"u.CITY as {u.homeAddress.city} " +
"from USERS u"
);
query.addEntity("u", User.class);
List<User> result = query.list();
Немедленное извлечение коллекции в запросе SQL доступно только в Hibernate.
Особенности Hibernate
Немедленное извлечение коллекций
Предположим, что требуется загрузить все экземпляры Item в одном SQL-запросе,
чтобы при этом для каждого экземпляра Item была загружена его коллекция
bids. Это требует использования в запросе SQL левого внешнего соединения:
Отображение результатов SQL-запросов  499
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(  Соединение таблиц ITEM и BID
"select " +
"i.ID as ITEM_ID, " +
"i.NAME, " +
"i.CREATEDON, " +
"i.AUCTIONEND, " +
"i.AUCTIONTYPE, " +
"i.APPROVED, " +
"i.BUYNOWPRICE, " +
"i.SELLER_ID, " +
"b.ID as BID_ID," +
"b.ITEM_ID as BID_ITEM_ID, " +
"b.AMOUNT, " +
"b.BIDDER_ID " +
"from ITEM i left outer join BID b on i.ID = b.ITEM_ID"
);
query.addRoot("i", Item.class)  Отображение столбцов в свойства сущностей
.addProperty("id", "ITEM_ID")
.addProperty("name", "NAME")
.addProperty("createdOn", "CREATEDON")
.addProperty("auctionEnd", "AUCTIONEND")
.addProperty("auctionType", "AUCTIONTYPE")
.addProperty("approved", "APPROVED")
.addProperty("buyNowPrice", "BUYNOWPRICE")
.addProperty("seller", "SELLER_ID");
query.addFetch("b", "i", "bids")  Отображение свойств Bid в атрибуты результата запроса
.addProperty("key", "BID_ITEM_ID")
.addProperty("element", "BID_ID")
.addProperty("element.id", "BID_ID")
.addProperty("element.item", "BID_ITEM_ID")
.addProperty("element.amount", "AMOUNT")
.addProperty("element.bidder", "BIDDER_ID");
List<Object[]> result = query.list();
assertEquals(result.size(), 5);  5 записей в результате
for (Object[] tuple : result) {
Item item = (Item) tuple[0];  Первый элемент кортежа – экземпляр Item
assertTrue(Persistence.getPersistenceUtil().isLoaded(item, "bids"));
Bid bid = (Bid) tuple[1];  Второй элемент – экземпляр Bid
if (bid != null)
assertTrue(item.getBids().contains(bid));
}
500  Настройка SQL-запросов
 В запросе используется внешнее соединение таблиц ITEM и BID. В проекции определены
все столбцы, необходимые для создания экземпляров Item и Bid. Повторяющиеся имена
столбцов, такие как ID, в запросе заменены псевдонимами.
 Но по этой причине приходится отображать каждый столбец в соответствующее свой-
ство сущности.
 Нужно сконструировать объект FetchReturn для коллекции bids, указав для сущности-
владельца псевдоним i, а затем отобразить специальные свойства key и element в столбец
внешнего ключа BID_ITEM_ID и идентификатор сущности Bid. Затем каждое свойство Bid
отображается в соответствующее поле в результатах запроса. Некоторые поля отобража-
ются дважды, что требуется Hibernate для инициализации коллекции.
 Число записей в результатах запроса является произведением: у одного товара три став-
ки, у другого – одна ставка, у последнего их нет вовсе, что даст в результате пять кортежей.
 Первым элементом каждого кортежа является экземпляр Item с инициализированной
коллекцией bids.
 Вторым элементом является экземпляр Bid.
Если имена столбцов в запросе SQL совпадают с именами в существующем
отображении,
можно не отображать результата запроса. В этом случае Hibernate
самостоятельно сгенерирует нужные псевдонимы в запросе SQL, используя сим-
волы подстановки:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"{i.*}, " +
"{b.*} " +
"from ITEM i left outer join BID b on i.ID = b.ITEM_ID"
);
query.addEntity("i", Item.class);
query.addFetch("b", "i", "bids");
List<Object[]> result = query.list();
Немедленное извлечение коллекций в запросах SQL доступно только в Hibernate;
эта функциональность не стандартизована в JPA.
Ограничения при загрузке коллекций в запросах SQL
Используя org.hibernate.SQLQuery, можно извлекать только коллекции, представ-
ленные связями один ко многим и многие ко многим. На момент написания кни-
ги Hibernate не поддерживал отображения результатов в коллекции простых
или встраиваемых
типов. Это означает, что невозможно загрузить коллекцию
Item#images, используя произвольный запрос SQL и org.hibernate.SQLQuery.
Отображение результатов SQL-запросов  501
До сих пор вы видели, как запросы SQL возвращают управляемые экземпляры
сущностей. Но точно так же можно возвращать временные экземпляры любого
класса, вызывая нужный конструктор.
Отображение результатов запроса в параметры конструктора
В разделе 15.3.2 мы рассмотрели динамическое создание экземпляров в запро-
сах JPQL и запросах на основе критериев. Похожая функциональность поддержи-
вается для обычных запросов JPA. Следующий запрос вернет список List экзем-
пляров ItemSummary:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select ID, NAME, AUCTIONEND from ITEM",
"ItemSummaryResult"
);
List<ItemSummary> result = query.getResultList();
Отображение ItemSummaryResult преобразует каждый столбец результата запро-
са в соответствующий параметр конструктора ItemSummary:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="ItemSummaryResult">
<constructor-result target-class="org.jpwh.model.querying.ItemSummary">
<column name="ID" class="java.lang.Long"/>
<column name="NAME"/>
<column name="AUCTIONEND"/>
</constructor-result>
</sql-result-set-mapping>
Типы возвращаемых столбцов должны соответствовать типам параметров кон-
структора; по умолчанию Hibernate выберет для столбца ID тип BigInteger, поэто-
му нужно указать для него тип Long с помощью атрибута class.
Hibernate предоставляет вам выбор. Вы можете указать имя существующего
отображения результатов запроса или применить преобразователь результатов,
как было показано в разделе 16.1 для запросов JPQL:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select ID, NAME, AUCTIONEND from ITEM"
);
// query.setResultSetMapping("ItemSummaryResult");
query.addScalar("ID", StandardBasicTypes.LONG);  Отобразить поля как скаляры
query.addScalar("NAME");
query.addScalar("AUCTIONEND");
 Использовать
существующее отображение
502  Настройка SQL-запросов
query.setResultTransformer(  Применить преобразователь результатов
new AliasToBeanConstructorResultTransformer(
ItemSummary.class.getConstructor(
Long.class,
String.class,
Date.class
)
)
);
List<ItemSummary> result = query.list();
 Есть возможность использовать существующее отображение.
 С другой стороны, можно отобразить поля, возвращаемые запросом, как скаляры. Без
применения преобразователя результатов для каждой записи вы получили бы массив
Object[].
 Применив встроенный преобразователь, можно превратить массив Object[] в экземпляр
ItemSummary.
Как было показано в разделе 15.3.2, Hibernate может использовать любой кон-
структор для такого отображения. Например, вместо экземпляров ItemSummary
можно было бы создать экземпляры Item. Они будут находиться во временном
или в отсоединенном состоянии, в зависимости от присутствия идентификатора
в результатах запроса и в отображении.
Также можно смешивать различные виды отображений результатов запроса
или напрямую возвращать скалярные значения.
Скалярные и смешанные отображения
Следующий запрос вернет список List массивов Object[], первым элементом
в которых будет экземпляр сущности Item (товар), а вторым – скаляр, представ-
ляющий число ставок за каждый товар:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select " +
"i.*, " +
"count(b.ID) as NUM_OF_BIDS " +
"from ITEM i left join BID b on b.ITEM_ID = i.ID " +
"group by i.ID, i.NAME, i.CREATEDON, i.AUCTIONEND, " +
"i.AUCTIONTYPE, i.APPROVED, i.BUYNOWPRICE, i.SELLER_ID",
"ItemBidResult"
);
List<Object[]> result = query.getResultList();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof Item);
assertTrue(tuple[1] instanceof Number);
}
Отображение результатов SQL-запросов  503
Поскольку повторяющиеся имена столбцов отсутствуют, отображение выгля-
дит просто:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="ItemBidResult">
<entity-result entity-class="org.jpwh.model.querying.Item"/>
<column-result name="NUM_OF_BIDS"/>
</sql-result-set-mapping>
В Hibernate можно добавить дополнительное скалярное поле, вызвав метод
addScalar():
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/
HibernateSQLQueries.java
org.hibernate.SQLQuery query = session.createSQLQuery(
"select " +
"i.*, " +
"count(b.ID) as NUM_OF_BIDS " +
"from ITEM i left join BID b on b.ITEM_ID = i.ID " +
"group by i.ID, i.NAME, i.CREATEDON, i.AUCTIONEND, " +
"i.AUCTIONTYPE, i.APPROVED, i.BUYNOWPRICE, i.SELLER_ID"
);
query.addEntity(Item.class);
query.addScalar("NUM_OF_BIDS");
List<Object[]> result = query.list();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof Item);
assertTrue(tuple[1] instanceof Number);
}
Наконец, в одном отображении можно совмещать сущности, конструкторы
и скаляры. Следующий запрос вернет управляемый хранимый экземпляр сущно-
сти User, представляющий продавца (поле seller) возвращаемого товара ItemSummary.
Также вы получите количество ставок за каждый товар:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNativeQuery(
"select " +
"u.*, " +
"i.ID as ITEM_ID, i.NAME as ITEM_NAME, i.AUCTIONEND as
ITEM_AUCTIONEND, " +
"count(b.ID) as NUM_OF_BIDS " +
"from ITEM i " +
"join USERS u on u.ID = i.SELLER_ID " +
"left join BID b on b.ITEM_ID = i.ID " +
"group by u.ID, u.USERNAME, u.FIRSTNAME, u.LASTNAME, " +
"u.ACTIVATED, u.STREET, u.ZIPCODE, u.CITY, " +
504  Настройка SQL-запросов
"ITEM_ID, ITEM_NAME, ITEM_AUCTIONEND",
"SellerItemSummaryResult"
);
List<Object[]> result = query.getResultList();
for (Object[] tuple : result) {
assertTrue(tuple[0] instanceof User);
assertTrue(tuple[1] instanceof BigInteger);
assertTrue(tuple[2] instanceof ItemSummary);
}
Для этого запроса задано следующее отображение:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="SellerItemSummaryResult">
<entity-result entity-class="org.jpwh.model.querying.User"/>
<constructor-result target-class="org.jpwh.model.querying.ItemSummary">
<column name="ID" class="java.lang.Long"/>
<column name="ITEM_NAME"/>
<column name="ITEM_AUCTIONEND"/>
</constructor-result>
<column-result name="NUM_OF_BIDS"/>
</sql-result-set-mapping>
Спецификация JPA гарантирует, что в смешанных отображениях результатов
запросов каждый кортеж Object[] будет содержать следующие элементы: сначала
все отображения <entityresult>, затем <constructor-result> и, наконец, <columnresult>.
XML-схема JPA гарантирует этот порядок в объявлении отображения; но
даже если отобразить элементы в другом порядке с помощью аннотаций (которые
не могут обеспечить порядка отображений), результат запроса будет сохранять
стандартный порядок. Но помните, что на момент написания книги Hibernate воз-
вращал результаты в неправильном порядке, как было показано в примере выше.
Обратите внимание, что с помощью Hibernate можно использовать это же
отображение
запроса, указав его имя, как было показано ранее. Если требуется
более полный контроль над преобразованием результатов, создайте собственный
преобразователь результатов, если, конечно, вы не найдете подходящего встроен-
ного преобразователя.
В завершение вы увидите более сложный пример запроса SQL, объявленного
в файле XML.
17.2.4. Размещение обычных запросов в отдельных файлах
Сейчас мы покажем, как объявить запрос SQL в файле XML. В настоящих при-
ложениях с большими запросами SQL не очень удобно читать строки в Java-коде,
поэтому вам будет проще хранить запросы SQL в файлах XML. Это также упростит
тестирование, поскольку можно копировать и вставлять выражения SQL из
файла XML в консоль базы данных SQL.
Неправильный порядок результатов:
ошибка в Hibernate с номером HHH-8678
Отображение результатов SQL-запросов  505
Вы наверняка обратили внимание, что все примеры запросов SQL в предыду-
щем разделе были тривиально простыми. Фактически ни один из примеров не
требовал применения SQL – в каждом случае можно было бы использовать JPQL.
Чтобы сделать следующий пример более интересным, мы напишем запрос, кото-
рый нельзя выразить на языке JPQL, – только на SQL.
Дерево категорий
Рассмотрим класс Category (категория) и связь многие к одному, которая ссыла-
ется сама на себя, как показано на рис. 17.1.
Это отображение – обычная связь с аннотацией @ManyToOne перед столбцом
внешнего ключа PARENT_ID:
Файл: /model/src/main/java/org/jpwh/model/querying/Category.java
@Entity
public class Category {
@ManyToOne
@JoinColumn(
name = "PARENT_ID",
foreignKey = @ForeignKey(name = "FK_CATEGORY_PARENT_ID")
)
protected Category parent; Корневая категория не имеет родителя; столбец может содержать null
// ...
}
Рис. 17.1  Сущность Category ссылается сама на себя
с помощью связи многие к одному
Категории образуют дерево. Корнем дерева является категория (экземпляр
Category) без родителя (свойство parent). На рис. 17.2 показан фрагмент такого
дерева в базе данных.
ID
1
2
3
4
NAME
One
CATEGORY
PARENT_ID
1
1
2
Two
Three
Four
Рис. 17.2  Таблица базы данных,
представляющая дерево категорий из примера
506  Настройка SQL-запросов
Эти данные также можно представить графически, как показано на рис. 17.3.
Также эти данные можно представить в виде последовательности путей с указа-
нием уровня каждого узла:
/One, 0
/One/Two, 1
/One/Three, 1
/One/Two/Four, 2
One(1, )
Two(2, 1) Three(3, 1)
Four(4, 2)
Рис. 17.3  Дерево категорий
Теперь посмотрим, как приложение загружает экземпляры Category. Для этого
необходимо найти корневую категорию (экземпляр Category). Это можно сделать
с помощью простейшего запроса JPQL:
select c from Category c where c.parent is null
Можно также с легкостью выбрать все категории на конкретном уровне дерева,
например всех потомков корневой категории:
select c from Category c, Category r where r.parent is null and c.parent = r
Этот запрос вернет только прямых потомков корневой категории: Two и Three.
Но как в одном запросе загрузить дерево (или поддерево) целиком? Это невоз-
можно сделать с помощью JPQL, поскольку потребовало бы рекурсии: «Загрузить
все категории на данном уровне, затем всех потомков на следующем уровне, потом
потомков потомков и т. д.». В SQL такой запрос можно написать, используя обоб-
щенное табличное выражение (Common Table Expression, CTE), также известное
как выделение подзапроса.
Загрузка дерева
Следующий SQL-запрос, объявленный в XML-файле JPA, загрузит все дерево
экземпляров Category:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<named-native-query name="findAllCategories"
result-set-mapping="CategoryResult">
<query>
Отображение результатов SQL-запросов  507
with CATEGORY_LINK(ID, NAME, PARENT_ID, PATH, LEVEL) as (
select
ID,
NAME,
PARENT_ID,
'/' || NAME,
0
from CATEGORY where PARENT_ID is null
union all
select
c.ID,
c.NAME,
c.PARENT_ID,
cl.PATH || '/' || c.NAME,
cl.LEVEL + 1
from CATEGORY_LINK cl
join CATEGORY c on cl.ID = c.PARENT_ID
)
select
ID,
NAME as CAT_NAME,
PARENT_ID,
PATH,
LEVEL
from CATEGORY_LINK
order by ID
</query>
</named-native-query>
Это сложный запрос, и мы не будем тратить на него много времени. Чтобы в нем
разобраться, прочтите последнее выражение SELECT, выбирающее данные из пред-
ставления CATEGORY_LINK. Каждая запись в этом представлении является узлом де-
рева. Представление определяется с помощью оператора WITH() AS. Представление
CATEGORY_LINK объединяет результаты двух выражений SELECT. В процессе рекур-
сии добавляются дополнительные данные, такие как PATH (путь к узлу из корня)
и LEVEL (уровень узла в дереве).
Давайте отобразим результат этого запроса:
Файл: /model/src/main/resources/querying/NativeQueries.xml
<sql-result-set-mapping name="CategoryResult">
<entity-result entity-class="org.jpwh.model.querying.Category">
<field-result name="id" column="ID"/>
<field-result name="name" column="CAT_NAME"/>
<field-result name="parent" column="PARENT_ID"/>
</entity-result>
<column-result name="PATH"/>
<column-result name="LEVEL" class="java.lang.Integer"/>
</sql-result-set-mapping>
508  Настройка SQL-запросов
Файл XML отображает атрибуты ID, CAT_NAME и PARENT_ID в свойства класса Category.
Отображение вернет дополнительные скаляры PATH и LEVEL.
Чтобы выполнить именованный запрос SQL, нужно написать следующий код:
Файл: /examples/src/test/java/org/jpwh/test/querying/sql/NativeQueries.java
Query query = em.createNamedQuery("findAllCategories");
List<Object[]> result = query.getResultList();
for (Object[] tuple : result) {
Category category = (Category) tuple[0];
String path = (String) tuple[1];
Integer level = (Integer) tuple[2];
// ...
}
Каждый кортеж содержит управляемый хранимый экземпляр Category, абсо-
лютный путь к нему от корня дерева (например, /One, /One/Two и т. д.) и уровень
узла.
Этот запрос SQL также можно объявить и отобразить в XML-файле метадан-
ных Hibernate:
Файл: /model/src/main/resources/querying/SQLQueries.hbm.xml
<sql-query name="findAllCategoriesHibernate">
<return class="org.jpwh.model.querying.Category">
<return-property name="id" column="ID"/>
<return-property name="name" column="CAT_NAME"/>
<return-property name="parent" column="PARENT_ID"/>
</return>
<return-scalar column="PATH"/>
<return-scalar column="LEVEL" type="integer"/>
...
</sql-query>
Мы опустили код SQL, поскольку он такой же, как в примере выше.
Как упоминалось в разделе 14.4, в отношении выполнения кода Java не важно,
где определяются именованные запросы – в файлах XML или в аннотациях. Даже
язык не играет роли – это может быть как JPQL, так и SQL. Интерфейсы запросов
в Hibernate и JPA обладают методами получения именованных запросов и их вы-
полнения, независимо от места, где они определены.
На этом мы заканчиваем рассматривать отображение результатов запросов SQL
и переходим к исследованию настройки выражений SQL для операций CRUD,
а также способов замены кода SQL, автоматически сгенерированного фреймвор-
ком Hibernate, для создания, чтения, изменения и удаления данных из базы.
Настройка операций CRUD  509
Особенности Hibernate
17.3. Настройка операций CRUD
Запрос SQL в первом примере ниже загружает экземпляры сущности User. Во всех
последующих примерах показан код SQL, который Hibernate выполняет автома-
тически, чтобы вы могли быстрее понять способы отображения.
Настроить способ извлечения экземпляров сущности можно с помощью загруз-
чика.
17.3.1. Подключение собственных загрузчиков
Переопределение запросов SQL для загрузки экземпляров сущности выполняет-
ся в два этапа:
 создать именованный запрос, извлекающий экземпляры сущности. Наш
пример написан на SQL, но именованные запросы также можно писать на
JPQL. В случае SQL может понадобиться дополнительное отображение ре-
зультатов запроса, как было показано ранее в этой главе;
 активировать запрос, добавив перед классом сущности аннотацию @org.hibernate.
annotations.Loader. После этого Hibernate будет использовать ваш
запрос вместо сгенерированного по умолчанию.
Давайте переопределим способ загрузки экземпляров User, как показано в листинге
17.2.
Листинг 17.2  Загрузка экземпляров User с помощью произвольного запроса
Файл: /model/src/main/java/org/jpwh/model/customsql/User.java
@NamedNativeQueries({  Объявление запроса для загрузки экземпляров User
@NamedNativeQuery(
name = "findUserById",
query = "select * from USERS where ID = ?",  Символ подстановки
resultClass = User.class  Дополнительного отображения результатов не требуется
)
})
@org.hibernate.annotations.Loader(  Активация загрузчика с передачей имени запроса
namedQuery = "findUserById"
)
@Entity
@Table(name = "USERS")
public class User {
// ...
}
 Запрос для загрузки экземпляров User задается с помощью аннотаций; его также можно
было бы определить в файле XML (с метаданными JPA или Hibernate). Этот запрос мож-
но использовать для доступа к данным, когда потребуется.
510  Настройка SQL-запросов
 У запроса должен иметься только один символ подстановки для значения параметра,
который Hibernate заменит значением идентификатора загружаемого экземпляра. Здесь
используется позиционный параметр, но именованный тоже подойдет.
 Определять отображение результатов для такого простого запроса не нужно. Все поля,
возвращаемые запросом, отображаются в классе User. Hibernate сможет автоматически
преобразовать результат.
 После активации загрузчика для класса сущности с определением имени запроса этот
запрос будет использоваться для всех операций загрузки экземпляров User из базы дан-
ных. Здесь нет и намека на язык запроса или способ его объявления; это не зависит от
объявления загрузчика.
В именованном запросе загрузчика сущности необходимо выбрать (задать эле-
менты проекции в предложении SELECT) следующие свойства класса сущности:
 свойство идентификатора или свойства, входящие в составной первичный
ключ;
 скалярные свойства простых типов;
 все свойства, ссылающиеся на встроенные компоненты;
 идентификатор сущности для каждого свойства с аннотацией @JoinColum
и отображаемой связью, такой как @ManyToOne, которой владеет данный
класс;
 все скалярные значения, встроенные компоненты и ссылки для соединения
по связи, находящиеся внутри аннотации @SecondaryTable;
 если для некоторых свойств настроить отложенную загрузку с помощью
перехвата вызовов, вам не нужно будет загружать этих свойств (см. раз-
дел 12.1.3).
Hibernate всегда выполняет запрос активного загрузчика, когда требуется из-
влечь экземпляр User из базы данных. Например, ваш запрос будет выполняться
при вызове em.find(User.class, USER_ID). Если выполнить цепочку вызовов someItem.
getSeller().getUsername(), прокси-объект Item#seller будет инициализиро-
ван с помощью вашего запроса.
Возможно, вам также потребуется настроить операции создания, изменения
и удаления экземпляров User из базы данных.
17.3.2. Настройка операций создания, изменения, удаления
Как правило, Hibernate генерирует SQL-код для операций CRUD во время за-
пуска. Затем он кэширует выражения SQL для будущего использования, что по-
зволяет во время выполнения не тратить времени на создание выражений SQL
для наиболее типичных операций. Пока что вы знаете только, как переопреде-
лить букву R (read – чтение) из всей аббревиатуры CRUD, поэтому сейчас мы
рассмотрим
CUD (создание, изменение, удаление – create, update, delete). Для лю-
бой сущности можно определить произвольные SQL-выражения CUD, используя
Hibernate-аннотации @SQLInsert, @SQLUpdate и @SQLDelete.
Настройка операций CRUD  511
Листинг 17.3  Замена DML-выражений для сущности User
Файл: /model/src/main/java/org/jpwh/model/customsql/User.java
@org.hibernate.annotations.SQLInsert(
sql = "insert into USERS " +
"(ACTIVATED, USERNAME, ID) values (?, ?, ?)"
)
@org.hibernate.annotations.SQLUpdate(
sql = "update USERS set " +
"ACTIVATED = ?, " +
"USERNAME = ? " +
"where ID = ?"
)
@org.hibernate.annotations.SQLDelete(
sql = "delete from USERS where ID = ?"
)
@Entity
@Table(name = "USERS")
public class User {
// ...
}
Будьте внимательны, связывая аргументы SQL-выражений с символами под-
становки ?. Для операций CUD Hibernate поддерживает только позиционные па-
раметры.
Но какой порядок параметров правильный? Существует внутренний порядок
связывания аргументов с параметрами SQL-выражений CUD. Чтобы узнать пра-
вильный порядок параметров в выражениях SQL, можно позволить Hibernate сге-
нерировать их примеры. Пока вы еще не добавили собственных выражений SQL,
включите уровень журналирования DEBUG для категории org.hibernate.persister.
entity, а затем, после запуска Hibernate, найдите в выводе программы все записи,
похожие на следующие:
Static SQL for entity: org.jpwh.model.customsql.User
Insert 0: insert into USERS (activated, username, id) values (?, ?, ?)
Update 0: update USERS set activated=?, username=? where id=?
Delete 0: delete from USERS where id=?
Эти автоматически сгенерированные выражения SQL подскажут верный поря-
док параметров, и Hibernate всегда будет выполнять связывание значений в таком
же порядке. Скопируйте необходимые выражения SQL и поместите их в аннота-
ции, внеся необходимые изменения.
Особый случай представляют свойства класса сущности, отображаемые в дру-
гую таблицу с помощью аннотации @SecondaryTable. Настройка выражений CUD
до сих пор затрагивала лишь столбцы основной таблицы сущности. Hibernate по-
прежнему будет выполнять автоматически сгенерированные выражения SQL для
вставки, удаления и изменения строк во вторичной таблице (таблицах). Этот код
SQL можно настроить, добавив перед классом сущности аннотацию @org.hiber512
 Настройка SQL-запросов
nate.annotations.Table и определив ее атрибуты sqlInsert, sqlUpdate и sqlDelete.
При желании SQL-выражения CUD можно разместить в файле XML. В этом
случае вам останется лишь описать всю сущность целиком в XML-файле мета-
данных Hibernate. Для произвольных выражений CUD используются элементы
<sql-insert>, <sql-update> и <sql-delete>. К счастью, выражения CUD, как прави-
ло, гораздо проще запросов выборки, поэтому в большинстве приложений удобнее
использовать аннотации.
Теперь мы определили собственные SQL-выражения операций CRUD для эк-
земпляра сущности. Пришла пора переопределить выражения SQL для загрузки
и изменения коллекций.
17.3.3. Настройка операций над коллекциями
Давайте переопределим выражения SQL, которые Hibernate использует для за-
грузки коллекции изображений Item#images. Это коллекция встраиваемых ком-
понентов, отображаемая аннотацией @ElementCollection. К коллекциям базовых
типов и связям типа @OneToMany или @ManyToMany применяется та же процедура.
Листинг 17.4  Загрузка коллекции с помощью собственного запроса
Файл: /model/src/main/java/org/jpwh/model/customsql/Item.java
@Entity
public class Item {
@ElementCollection
@org.hibernate.annotations.Loader(namedQuery = "loadImagesForItem")
protected Set<Image> images = new HashSet<Image>();
// ...
}
Как и прежде, нужно объявить запрос для загрузки коллекции. Но на этот раз
результаты запроса должны объявляться и отображаться в XML-файле метадан-
ных Hibernate: это единственный способ, позволяющий отобразить результат за-
проса в свойство поля, представляющее коллекцию: