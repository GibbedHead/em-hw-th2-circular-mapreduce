Когда состояние экземпляра сущности изменяется – например, при переходе из
временного состояния в хранимое, – связанные экземпляры сущностей также мо-
гут стать частью этого изменения. Подобная каскадная передача изменений по
умолчанию выключена; каждый экземпляр сущности имеет свой, независимый
жизненный цикл. Но для некоторых связей между сущностями может понадо-
биться тонкая настройки зависимостей жизненных циклов.
Например, в разделе 7.3 мы определили связь между классами сущностей Item
(товар) и Bid (ставка). В этом случае ставки за товар (Item) автоматически стано-
вились хранимыми при добавлении в коллекцию экземпляра Item, а при удалении
сущности-владельца Item они автоматически удалялись. Фактически мы сделали
класс сущности Bid зависимым от другой сущности Item.
В отображении этой связи мы использовали настройки каскадирования CascadeType.
PERSIST и CascadeType.REMOVE. Мы также обсудили специальный параметр
orphanRemoval и то, как каскадное удаление на уровне базы данных (с применением
параметра внешнего ключа ON DELETE) влияет на приложение.
Вам стоит заново просмотреть эти отображения связей, поскольку мы не станем
повторять их здесь. В этом разделе мы рассмотрим другие, более редкие способы
каскадирования.
Каскадная передача изменений состояния  367
13.1.1. Доступные способы каскадирования
Все способы каскадирования, доступные в Hibernate, перечислены в табл. 13.1.
Обратите внимание, как каждый из них связан с операциями EntityManager или
Session.
Таблица 13.1. Способы каскадирования для отображения связей
между сущностями
Параметр Описание
CascadeType.PERSIST При сохранении экземпляра сущности с помощью метода
EntityManager #persist() любой связанный экземпляр сущности
также перейдет в хранимое состояние во время выталкивания
контекста
CascadeType.REMOVE При удалении экземпляра сущности с помощью метода
EntityManager #remove() любой связанный экземпляр сущности также
будет удален удален во время выталкивания контекста
CascadeType.DETACH При отсоединении экземпляра сущности от контекста хранения
с помощью EntityManager#detach() любой ассоциированный экзем-
пляр сущности также будет отсоединен
CascadeType.MERGE При слиянии временной или отсоединенной сущности с контек-
стом персистентности с помощью EntityManager#merge() для любого
связанного временного или отсоединенного экземпляра сущности
также будет выполнено слияние
CascadeType.REFRESH При изменении экземпляра сущности с помощью
EntityManager#refresh() любой связанный экземпляр сущности
также будет изменен
org.hibernate.annotations
.CascadeType.REPLICATE
При копировании отсоединенного экземпляра сущности в базу
данных с помощью Session#replicate() любой связанный отсоеди-
ненный экземпляр сущности также будет скопирован
CascadeType.ALL Сокращенная запись для применения всех способов каскадирова-
ния к отображаемой связывания
Если вам интересно, дополнительные способы каскадирования можно най-
ти в перечислении org.hibernate.annotations.CascadeType. Но на данный момент
нас интересует только параметр REPLICATE с операцией Session#replicate(). Все
остальные операции Session имеют стандартизованные эквиваленты или альтер-
нативы в EntityManager API, поэтому их можно не рассматривать.
Мы уже рассказали про параметры PERSIST и REMOVE. Давайте разберемся с тран-
зитивным отсоединением, изменением и репликацией.
13.1.2. Транзитивное отсоединение и слияние
Предположим, что нужно извлечь из базы данных экземпляр Item и коллекцию
bids, чтобы работать с ними в отсоединенном состоянии. В классе Bid эта связь
отображается с помощью аннотации @ManyToOne. Она двунаправленная и имеет со-
ответствующее отображение коллекции @OneToMany в классе Item:
368  Фильтрация данных
Файл: /model/src/main/java/org/jpwh/model/filtering/cascade/Item.java
@Entity
public class Item {
@OneToMany(
mappedBy = "item",
cascade = {CascadeType.DETACH, CascadeType.MERGE}
)
protected Set<Bid> bids = new HashSet<Bid>();
// ...
}
Транзитивное отсоединение и слияние задаются при помощи параметров каскадирования
DETACH и MERGE. Теперь загрузим экземпляр Item вместе с коллекцией
bids:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
Item item = em.find(Item.class, ITEM_ID);
assertEquals(item.getBids().size(), 2); Инициализация коллекции bids
em.detach(item);
EntityManager#detach() – каскадная операция; она исключает из контекста хране-
ния экземпляр Item, а также коллекцию bids. Если коллекция bids не будет загруже-
на, она не сможет стать отсоединенной (конечно, можно закрыть контекст хранения,
фактически сделав отсоединенными все загруженные экземпляры сущностей).
В отсоединенном состоянии изменим значение Item#name и создадим новый
объект Bid, связав его с экземпляром Item:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
item.setName("New Name");
Bid bid = new Bid(new BigDecimal("101.00"), item);
item.getBids().add(bid);
Работая с сущностями и коллекциями в отсоединенном состоянии, нужно об-
ращать особое внимание на равенство и идентичность. Как объяснялось в разделе
10.3, мы должны переопределить методы equals() и hashCode() класса сущности
Bid:
Файл: /model/src/main/java/org/jpwh/model/filtering/cascade/Bid.java
@Entity
public class Bid {
@Override
public boolean equals(Object other) {
if (this == other) return true;
if (other == null) return false;
if (!(other instanceof Bid)) return false;
Bid that = (Bid) other;
Каскадная передача изменений состояния  369
if (!this.getAmount().equals(that.getAmount()))
return false;
if (!this.getItem().getId().equals(that.getItem().getId()))
return false;
return true;
}
@Override
public int hashCode() {
int result = getAmount().hashCode();
result = 31 * result + getItem().getId().hashCode();
return result;
}
// ...
}
Два экземпляра Bid равны, если содержат одинаковую цену и связаны с одним
и тем же экземпляром Item.
Закончив вносить изменения в отсоединенном состоянии, следующим шагом
нужно их сохранить. Используя новый контекст хранения, выполним слияние от-
соединенного экземпляра Item, чтобы Hibernate обнаружил изменения:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
Item mergedItem = em.merge(item);  Слияние объекта item
// select i.*, b.*
// from ITEM i
// left outer join BID b on i.ID = b.ITEM_ID
// where i.ID = ?
for (Bid b : mergedItem.getBids()) {  Экземпляр Bid имеет значение идентификатора
assertNotNull(b.getId());
}
em.flush();  Обнаружит изменение имени
// update ITEM set NAME = ? where ID = ?
// insert into BID values (?, ?, ?, ...)
 Hibernate выполнит слияние отсоединенного экземпляра item. Сначала он попытается
найти экземпляр Item с заданным идентификатором в контексте хранения. В данном
случае такого не окажется, поэтому объект item будет загружен из базы данных. Hibernate
достаточно «умен», чтобы понять, что во время слияния также нужно загрузить кол-
лекцию bids, поэтому он извлечет ее в том же запросе SQL. Затем скопирует значения
свойств из отсоединенного объекта item в загруженный экземпляр, который возвраща-
ется в хранимом состоянии. Та же процедура применяется к каждому экземпляру Bid,
и Hibernate обнаружит новый элемент в коллекции bids.
 Во время слияния Hibernate переведет новый экземпляр Bid в хранимое состояние. Те-
перь у него будет значение идентификатора.
 Выталкивая контекст хранения, Hibernate обнаружит, что свойство name объекта Item во
время слияния изменилось. Новый экземпляр Bid также будет сохранен.
370  Фильтрация данных
Каскадное слияние коллекций – мощная возможность. Представьте, как много
кода пришлось бы написать для ее реализации в отсутствие Hibernate.
Немедленная загрузка коллекций во время слияния
В предыдущем примере мы сказали, что Hibernate достаточно «умен», чтобы за-
грузить коллекцию Item#bids при слиянии отсоединенного экземпляра Item. Во вре-
мя слияния Hibernate всегда производит немедленную загрузку связей сущностей
с помощью оператора JOIN, если связь определена с параметром CascadeType.MERGE.
В предыдущем случае, когда коллекция Item#bids инициализировалась, отсоеди-
нялась и модифицировалась, это было «умным» поведением. Такая загрузка кол-
лекции с помощью JOIN во время слияния является необходимой и оптимальной.
Но при слиянии экземпляра Item, не имеющего инициализированной коллекции
bids или прокси-объекта seller, Hibernate извлечет коллекцию и данные прокси-
объекта с помощью JOIN. Операция слияния повлечет инициализацию этих связей
в управляемом экземпляре Item, который будет возвращен. Параметр CascadeType.
MERGE вынуждает Hibernate игнорировать и фактически переопределять любое
отображение
с параметром FetchType.LAZY (что допускается спецификацией JPA).
В некоторых ситуациях такое поведение может быть неидеальным, но на момент
написания книги его нельзя было настраивать.
Наш следующий пример будет менее запутанным: мы продемонстрируем каскадное
обновление связанных сущностей.
13.1.3. Каскадное обновление
Класс сущности User (пользователь) связан отношением один ко многим с классом
BillingDetails (платежные реквизиты): каждый пользователь приложения может
иметь несколько кредитных карт, банковских счетов и т. д. Если вы не знакомы
с классом BillingDetails, посмотрите отображения в главе 6.
Отношение между классами User и BillingDetails можно отобразить в виде од-
нонаправленной ассоциации сущностей один ко многим (@ManyToOne отсутствует):
Файл: /model/src/main/java/org/jpwh/model/filtering/cascade/User.java
@Entity
@Table(name = "USERS")
public class User {
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REFRESH})
@JoinColumn(name = "USER_ID", nullable = false)
protected Set<BillingDetails> billingDetails = new HashSet<>();
// ...
}
Для этой ассоциации указаны параметры каскадирования PERSIST и REFRESH.
Параметр PERSIST упрощает сохранение платежных реквизитов; они становятся
хранимыми при добавлении экземпляра BillingDetails в коллекцию хранимого
экземпляра User.
Каскадная передача изменений состояния  371
В разделе 18.3 мы обсудим архитектуру, в которой контекст хранения остает-
ся открытым на протяжении долгого времени, что ведет к устареванию данных
в управляемых экземплярах сущностей. Поэтому во время продолжительных диа-
логовых взаимодействий нужно повторно читать информацию из базы данных.
Параметр каскадирования REFRESH гарантирует, что при перезагрузке экземпляра
User Hibernate также обновит состояние каждого объекта BillingDetails, связан-
ного с экземпляром User.
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
User user = em.find(User.class, USER_ID);  Загрузка экземпляра User
assertEquals(user.getBillingDetails().size(), 2);  Инициализация коллекции
for (BillingDetails bd : user.getBillingDetails()) {
assertEquals(bd.getOwner(), "John Doe");
}
// Кто-то изменил платежные реквизиты в базе данных!
em.refresh(user);  Обновляет экземпляры BillingDetails
// select * from CREDITCARD join BILLINGDETAILS where ID = ?
// select * from BANKACCOUNT join BILLINGDETAILS where ID = ?
// select * from USERS
// left outer join BILLINGDETAILS
// left outer join CREDITCARD
// left outer JOIN BANKACCOUNT
// where ID = ?
for (BillingDetails bd : user.getBillingDetails()) {
assertEquals(bd.getOwner(), "Doe John");
}
 Экземпляр User загружается из базы данных.
 Отложенная коллекция billingDetails инициализируется в начале обхода элементов
или при вызове size().
 При изменении управляемого экземпляра User вызовом refresh() Hibernate каскадно
выполнит эту операцию для всех управляемых экземпляров BillingDetails и обновит
каждый из них с помощью SQL-выражения SELECT. Если ни одного из этих экземпля-
ров не останется в базе данных, Hibernate возбудит исключение EntityNotFoundException.
Затем Hibernate обновит экземпляр User и выполнит немедленную загрузку коллекции
billingDetails, чтобы обнаружить новый экземпляр BillingDetails.
Это как раз тот случай, когда Hibernate действует не совсем оптимально. Сна-
чала он выполнит SQL-выражение SELECT для каждого экземпляра BillingDetails
из коллекции, а затем загрузит всю коллекцию снова, чтобы обнаружить добав-
ленный экземпляр BillingDetails. Очевидно, что все это можно сделать одним вы-
ражением SELECT.
Последний способ каскадирования доступен только в Hibernate – это операция
replicate().
372  Фильтрация данных
13.1.4. Каскадная репликация
Мы впервые столкнулись с репликацией в разделе 10.2.7. Эта нестандартная опе-
рация доступна в Hibernate-интерфейсе Session. Основным сценарием его исполь-
зования является копирование данных из одной базы данных в другую.
Рассмотрим следующую связь многие к одному между классами Item и User:
Файл: /model/src/main/java/org/jpwh/model/filtering/cascade/Item.java
@Entity
public class Item {
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "SELLER_ID", nullable = false)
@org.hibernate.annotations.Cascade(
org.hibernate.annotations.CascadeType.REPLICATE
)
protected User seller;
// ...
}
Здесь в аннотации используется параметр каскадирования REPLICATE. Теперь за-
грузим экземпляр Item и его свойство seller из исходной базы данных:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);
assertNotNull(item.getSeller().getUsername());
tx.commit();
em.close();
Когда контекст хранения будет закрыт, экземпляры сущностей Item и User ока-
жутся в отсоединенном состоянии. Теперь соединимся с другой базой данных и за-
пишем отсоединенные данные:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Cascade.java
tx.begin();
EntityManager otherDatabase = // ... get EntityManager
otherDatabase.unwrap(Session.class)
.replicate(item, ReplicationMode.OVERWRITE);
// select ID from ITEM where ID = ?
// select ID from USERS where ID = ?
tx.commit();
// update ITEM set NAME = ?, SELLER_ID = ?, ... where ID = ?
// update USERS set USERNAME = ?, ... where ID = ?
otherDatabase.close();
Инициализация свойства Item#seller
с отложенной загрузкой
Каскадная передача изменений состояния  373
При вызове метода replicate() для отсоединенного экземпляра Item Hibernate
выполнит SQL-выражения SELECT, чтобы выяснить, присутствует ли он и его свой-
ство seller в базе данных. Затем, во время подтверждения транзакции, Hibernate
запишет значения экземпляра Item и поля seller в целевую базу данных. В пре-
дыдущем примере эти строки уже были записаны, поэтому вы видите операцию
UPDATE для каждой строки, перезаписывающую значения в базе данных. Если эк-
земпляр Item или User отсутствует в целевой базе данных, будут выполнены две
операции INSERT.
Последний способ каскадирования, который мы обсудим, – глобальная на-
стройка, включающая каскадное сохранение всех связей сущностей.
13.1.5. Глобальное каскадное сохранение
Уровень хранения реализует стратегию хранения по достижимости (persistence
by reachability), если любой экземпляр становится хранимым, когда приложение
создает ссылку на этот экземпляр из уже хранимого экземпляра. В чистом виде
стратегия хранения по достижимости реализуется посредством высокоуровневых
или корневых объектов в базе данных, через которые достижимы все хранимые
экземпляры. В идеальном случае, если до экземпляра нельзя добраться по ссыл-
кам от корневого хранимого объекта, он должен перейти во временное состояние
и быть удален из базы данных.
Ни Hibernate, ни любая другая реализация ORM не обеспечивают такого по-
ведения. Фактически ни в одной базе данных SQL нет аналога корневого храни-
мого объекта, и ни один сборщик мусора, входящий в состав механизма хранения,
не сможет определить экземпляров, на которые никто не ссылается. Объектно-
ориентированные (сетевые) хранилища данных могут реализовывать алгоритмы
сборки мусора, похожие на тот, который использует JVM для объектов в памяти;
но в мире ORM этот вариант отсутствует, а сканирование всех таблиц для поиска
записей, на которые никто не ссылается, неприемлемо с точки зрения произво-
дительности.
Тем не менее в идее хранения по достижимости есть определенные преимущества.
Это позволяет переводить экземпляры из временного состояния в храни-
мое и передавать их в базу данных без многочисленных обращений к диспетчеру
уровня хранения.
Активировать каскадное сохранение всех связей сущностей можно настройкой
единицы хранения в файле метаданных отображения orm.xml:
Файл: /model/src/main/resources/filtering/DefaultCascadePersist.xml
<persistence-unit-metadata>
<persistence-unit-defaults>
<cascade-persist/>
</persistence-unit-defaults>
</persistence-unit-metadata>
После этого ко всем связям сущностей в предметной модели, отображаемых
этой единицей хранения, Hibernate будет применять параметр CascadeType.PER374
 Фильтрация данных
SIST. Каждый раз, когда будет создаваться ссылка из хранимого экземпляра сущ-
ности на временный, Hibernate автоматически будет переводить последний из
временного состояния в хранимое.
Фактически параметры каскадирования – это предопределенные реакции ме-
ханизма хранения на события жизненного цикла. Если вам потребуется выпол-
нить свою процедуру при сохранении или загрузке данных, можно определить
собственные приемники и обработчики событий.
13.2. Прием и обработка событий
В этом разделе мы рассмотрим три различных API для работы с приемниками
и обработчиками событий жизненного цикла хранилища, доступные в JPA и Hibernate.
Они позволяют:
 использовать стандартные методы обратного вызова и приемники событий
жизненного цикла, которые определены в JPA;
 определить реализацию интерфейса org.hibernate.Interceptor и использо-
вать ее при работе с экземпляром Session;
 использовать механизм расширения Hibernate через интерфейс org.hibernate.
event.
Начнем со стандартных методов обратного вызова JPA. Они дают удобный до-
ступ к событиям сохранения, загрузки и удаления.
13.2.1. Приемники событий JPA и обратные вызовы
Предположим, что при сохранении нового экземпляра сущности требуется по-
слать электронное письмо системному администратору. Для этого, во-первых,
нужно создать приемник событий жизненного цикла с методом обратного вызова,
отмеченного аннотацией @PostPersist, как показано в следующем листинге.
Листинг 13.1  Уведомление администратора о сохранении нового экземпляра
сущности
Файл: /model/src/main/java/org/jpwh/model/filtering/callback/
PersistEntityListener.java
public class PersistEntityListener {
@PostPersist  Аннотация превращает метод notfyAdmin() в метод обратного вызова
public void notifyAdmin(Object entityInstance) {
User currentUser = CurrentUser.INSTANCE.get();  Получение информации
Mail mail = Mail.INSTANCE; о пользователе и отправка почты
mail.send(
"Entity instance persisted by "
+ currentUser.getUsername()
+ ": "
+ entityInstance
);
}
}
 Конструктор приемника событий
жизненного цикла сущностей
Каскадная передача изменений состояния  375
 Класс приемника событий жизненного цикла сущностей не должен иметь конструкто-
ра, или конструктор должен быть общедоступным и не иметь аргументов. От класса не
требуется реализовать какой-то специальный интерфейс. Класс приемника событий не
имеет состояния, а его экземпляры автоматически создаются и уничтожаются реализа-
цией JPA.
 Любой метод класса приемника событий можно отметить как метод обратного вызова.
Метод notifyAdmin() в данном примере будет вызываться после сохранения нового эк-
земпляра сущности в базу данных.
 Поскольку классы приемников событий не имеют состояния, получить более содержа-
тельную информацию может быть затруднительно. Здесь нам требуется получить эк-
земпляр текущего авторизованного пользователя и обратиться к почтовой системе для
отправки уведомления. Простейшим решением будет использование локальных пере-
менных потока и объектов-одиночек; вы можете найти исходные тексты классов CurrentUser
и Mail в коде примеров.
Метод обратного вызова принимает единственный параметр типа Object: экзем-
пляр сущности, меняющий состояние. Если понадобится определить метод обрат-
ного вызова для конкретного типа сущности, укажите конкретный тип параметра.
Метод обратного вызова может иметь любой модификатор доступа – он не обязан
быть общедоступным. Он не должен быть ни статическим, ни финальным и не
должен ничего не возвращать. Если метод обратного вызова возбудит неконтро-
лируемое исключение RuntimeException, Hibernate отменит выполняемую опера-
цию и отметит текущую транзакцию как подлежащую откату. Если метод обрат-
ного вызова объявит и возбудит контролируемое исключение Exception, Hibernate
завернет его в неконтролируемое исключение RuntimeException.
Внедрение зависимостей в классы приемников событий
Часто при реализации приемника событий требуется получить доступ к контекст-
ной информации и обращаться к API. В предыдущем примере понадобилось полу-
чить текущего зарегистрированного пользователя и обратиться к API для отправки
почты. Простейшего решения на основе локальных переменных потока и объек-
тов-одиночек может оказаться недостаточно для больших и сложных приложений.
JPA также стандартизирует интеграцию при помощи CDI, поэтому класс приемни-
ка событий может использовать механизм внедрения зависимостей посредством
аннотации @Inject. При обращении к классу приемника контейнер CDI автомати-
чески внедрит контекстную информацию. Но обратите внимание, что даже при
использовании CDI нельзя внедрить экземпляр EntityManager в приемник событий
для доступа к базе данных. Далее в этой главе мы обсудим другой способ доступа
к базе данных из приемника событий (Hibernate).
Каждую аннотацию для методов обратного вызова можно использовать в опре-
делении приемника событий только один раз, т. е. лишь один метод может быть от-
мечен аннотацией @PostPersist. Все доступные аннотации для методов обратных
вызовов перечислены в табл. 13.2.
376  Фильтрация данных
Таблица 13.2. Аннотации методов обратного вызова
для событий жизненного цикла
Аннотация Описание
@PostLoad Метод вызывается после загрузки экземпляра сущности в контекст хранения,
либо в результате поиска по идентификатору, в ходе навигации и инициализации
прокси-объекта/коллекции, либо при выполнении запроса. Метод также
вызывается после изменения уже хранимого экземпляра
@PrePersist Вызывается сразу после вызова операции persist() для экземпляра сущности.
Также вызывается после выполнения операции merge() для временной сущности,
когда ее временное состояние будет скопировано в хранимый экземпляр
сущности. Метод также будет вызван для связей сущностей с опцией
CascadeType.PERSIST
@PostPersist Вызывается после сохранения экземпляра сущности в базе данных и присваивания
ему значения идентификатора. Это может произойти либо после
операций
persist() или merge(), либо позже, во время выталкивания контекста
хранения, если генератор идентификаторов срабатывает перед вставкой (см.
раздел 4.2.5). Метод также будет вызван для связей сущностей с параметром
CascadeType.PERSIST
@PreUpdate,
@PostUpdate
Методы вызываются до и после синхронизации контекста хранения с базой
данных, т. е. до и после выталкивания контекста, но только в том случае, когда
требуется синхронизация сущности (если она определена как изменившаяся)
@PreRemove,
@PostRemove
Вызываются при выполнении remove() или каскадном удалении экземпляра
сущности, а также после удаления записи из базы данных, когда происходит
выталкивание контекста хранения
Чтобы организовать прием событий, возникающих в конкретной сущности, не-
обходимо явно указать класс приемника событий перед объявлением класса сущ-
ности, например:
Файл: /model/src/main/java/org/jpwh/model/filtering/callback/Item.java
@Entity
@EntityListeners(
PersistEntityListener.class
)
public class Item {
// ...
}
Аннотация @EntityListeners может принимать массив классов приемников
событий, если их несколько. Если в нескольких приемниках определены мето-
ды обратного вызова для одних и тех же событий, Hibernate будет вызывать их
в порядке перечисления. Связать классы приемников с сущностями можно так-
же в XML-файле метаданных при помощи дочерних элементов <entity-listener>
в элементах <entity>.
Чтобы организовать обработку отдельных событий жизненного цикла, не обя-
зательно создавать отдельный класс приемника. Например, можно определить
метод notifyAdmin() в классе сущности User:
Каскадная передача изменений состояния  377
Файл: /model/src/main/java/org/jpwh/model/filtering/callback/User.java
@Entity
@Table(name = "USERS")
public class User {
@PostPersist
public void notifyAdmin(){
User currentUser = CurrentUser.INSTANCE.get();
Mail mail = Mail.INSTANCE;
mail.send(
"Entity instance persisted by "
+ currentUser.getUsername()
+ ": "
+ this
);
}
// ...
}
Обратите внимание, что методы обратного вызова в классе сущности не имеют
аргументов: текущая сущность, меняющая состояние, доступна через переменную
this. Не допускается определять в одном классе несколько методов обратного вы-
зова для одного и того же события. Но одно и то же событие можно обрабатывать
в нескольких методах обратного вызова в разных классах сущностей или с помощью
приемника событий и в самом классе сущности.
Также есть возможность определить методы обратного вызова для целой иерар-
хии классов в суперклассах сущностей. Если в конкретном подклассе сущности
потребуется отключить методы обратного вызова суперкласса, достаточно отме-
тить подкласс аннотацией @ExcludeSuperclassListeners или отобразить его в мета-
данных XML с элементом <exclude-superclass-listeners>.
Используя метаданные XML, можно определить классы приемников событий,
применяемые по умолчанию ко всем сущностям в единице хранения:
Файл: /model/src/main/resources/filtering/EventListeners.xml
<persistence-unit-metadata>
<persistence-unit-defaults>
<entity-listeners>
<entity-listener
class="org.jpwh.model.filtering.callback.PersistEntityListener"/>
</entity-listeners>
</persistence-unit-defaults>
</persistence-unit-metadata>
Если потребуется отключить приемник событий по умолчанию в конкретной
сущности, его следует отобразить с элементом <exclude-default-listeners> в фай-
ле метаданных XML или отметить аннотацией @ExcludeDefaultListeners:
378  Фильтрация данных
Файл: /model/src/main/java/org/jpwh/model/filtering/callback/User.java
@Entity
@Table(name = "USERS")
@ExcludeDefaultListeners
public class User {
// ...
}
Но помните, что вызываться будут все подключенные приемники событий.
Если подключить/связать приемники событий в метаданных XML и аннотациях,
Hibernate вызовет их в следующем порядке:
1) приемники событий по умолчанию из единицы хранения, в порядке их пере-
числения в метаданных XML;
2) приемники событий, связанные с сущностью при помощи аннотации @EntityListeners,
в порядке перечисления;
3) сначала методы обратного вызова, объявленные в суперклассах, начиная
с самого общего. Последними – методы обратного вызова в классе сущности.
Приемники событий JPA и методы обратного вызова – это простейший спо-
соб вызова процедур при наступлении определенных событий жизненного цикла.
В качестве альтернативы в Hibernate имеется более гибкий и мощный API: org.
hibernate.Interceptor.
13.2.2. Реализация перехватчиков Hibernate
Предположим, что требуется вносить записи о модификации данных в журнал
аудита в отдельной таблице базы данных, например с информацией о создании
и изменении каждого экземпляра Item. В журнал аудита должны записываться
имя пользователя, дата, время и тип события, а также идентификатор измененно-
го экземпляра Item.
Журналы аудита, как правило, ведутся при помощи триггеров в базе данных.
С другой стороны, иногда лучше делать это в приложении, особенно когда требу-
ется обеспечить переносимость между несколькими базами данных.
Для реализации журнала аудита потребуется несколько ингредиентов. Во-
первых, нужно отметить все классы сущностей, для которых требуется вносить
записи в журнал аудита. Затем определить журналируемые данные, такие как
имя пользователя, дата, время и тип изменения. И наконец, связать все воедино
с помощью org.hibernate.Interceptor, который будет автоматически создавать
записи аудита.
Сначала создадим интерфейс-маркер Auditable:
Файл: /model/src/main/java/org/jpwh/model/filtering/interceptor/Auditable.java
public interface Auditable {
public Long getId();
}
Каскадная передача изменений состояния  379
Этот интерфейс требует, чтобы класс хранимой сущности открывал доступ
к идентификатору посредством метода чтения; это свойство понадобится для
записи в журнал аудита. После этого внесение записей о конкретном хранимом
классе в журнал аудита становится тривиальным. Нужно добавить его в объявле-
ние класса, как, например, в классе Item:
Файл: /model/src/main/java/org/jpwh/model/filtering/interceptor/Item.java
@Entity
public class Item implements Auditable {
// ...
}
Далее нужно создать новый класс хранимой сущности AuditLogRecord, опреде-
лив в нем всю информацию для записи в таблицу журнала аудита:
Файл: /model/src/main/java/org/jpwh/model/filtering/interceptor/
AuditLogRecord.java
@Entity
public class AuditLogRecord {
@Id
@GeneratedValue(generator = "ID_GENERATOR")
protected Long id;
@NotNull
protected String message;
@NotNull
protected Long entityId;
@NotNull
protected Class entityClass;
@NotNull
protected Long userId;
@NotNull
@Temporal(TemporalType.TIMESTAMP)
protected Date createdOn = new Date();
// ...
}
Нам нужно организовать сохранение экземпляра AuditLogRecord, когда Hibernate
сохраняет или обновляет экземпляр Item в базе данных. Перехватчик
Hibernate может делать это автоматически. Но вместо реализации всех методов
интерфейса org.hibernate.Interceptor достаточно лишь расширить класс EmptyInterceptor
и переопределить нужные методы, как показано далее.
380  Фильтрация данных
Листинг 13.2  Перехватчик Hibernate, записывающий в журнал события
изменения
Файл: /examples/src/test/java/org/jpwh/test/filtering/AuditLogInterceptor.java
public class AuditLogInterceptor extends EmptyInterceptor {
protected Session currentSession;  Обеспечивает доступ к базе данных
protected Long currentUserId;
protected Set<Auditable> inserts = new HashSet<Auditable>();
protected Set<Auditable> updates = new HashSet<Auditable>();
public void setCurrentSession(Session session) {
this.currentSession = session;
}
public void setCurrentUserId(Long currentUserId) {
this.currentUserId = currentUserId;
}
public boolean onSave(Object entity, Serializable id,  Вызывается, когда
Object[] state, String[] propertyNames, экземпляр становится
Type[] types) хранимым
throws CallbackException {
if (entity instanceof Auditable)
inserts.add((Auditable)entity);
return false; Мы не изменяли состояния
}
public boolean onFlushDirty(Object entity, Serializable id,  Вызывается
Object[] currentState, при изменении
Object[] previousState, состояния сущности
String[] propertyNames, Type[] types)
throws CallbackException {
if (entity instanceof Auditable)
updates.add((Auditable)entity);
return false; Мы не меняли текущего состояния
}
// ...
}
 Нам потребуется доступ к базе данных для записи в журнал аудита, поэтому мы добави-
ли в перехватчик Hibernate объект Session. Также нам понадобится сохранять в каждой
записи журнала аудита идентификатор текущего авторизованного пользователя. Пере-
менные экземпляра inserts и updates – это коллекции, в которых перехватчик сохраняет
свое состояние.
 Этот метод вызывается, когда экземпляр сущности становится хранимым.
 Этот метод вызывается, если во время выталкивания контекста хранения в экземпляре
сущности будут обнаружены изменения.
Каскадная передача изменений состояния  381
Перехватчик сохраняет все измененные экземпляры Auditable в коллекциях
inserts и updates. Обратите внимание, что в методе onSave() экземпляр сущности
может не иметь идентификатора. Hibernate гарантирует присваивание идентифи-
катора во время выталкивания контекста, поэтому запись в журнал аудита вы-
полняется в методе обратного вызова postFlush(), не показанном в листинге 13.2:
Файл: /examples/src/test/java/org/jpwh/test/filtering/AuditLogInterceptor.java
public class AuditLogInterceptor extends EmptyInterceptor {
// ...
public void postFlush(Iterator iterator) throws CallbackException {
Session tempSession =  Создает временный объект Session
currentSession.sessionWithOptions()
.transactionContext()
.connection()
.openSession();
try {
for (Auditable entity : inserts) {  Сохраняет экземпляры AuditLogRecords
tempSession.persist(
new AuditLogRecord("insert", entity, currentUserId)
);
}
for (Auditable entity : updates) {
tempSession.persist(
new AuditLogRecord("update", entity, currentUserId)
);
}
tempSession.flush();  Закрывает временный сеанс
} finally {
tempSession.close();
inserts.clear();
updates.clear();
}
}
}
 Этот метод будет вызываться после выталкивания контекста хранения. Здесь мы запи-
сываем данные в журнал аудита для всех операций добавления и изменения, которые мы
запомнили ранее.
 Мы не можем получить доступа к оригинальному контексту хранения – объекту Session,
вызывающему данный перехватчик. Во время вызова перехватчиков сеанс (Session) на-
ходится в уязвимом состоянии. Однако Hibernate дает возможность создать новый эк-
земпляр Session, наследующий некоторую информацию из оригинального экземпляра
Session, с помощью метода sessionWithOptions(). Новый временный экземпляр Session
работает в той же транзакции и с тем же соединением с базой данных, что и оригиналь-
ный экземпляр Session.
 Выполняет запись в журнал аудита
382  Фильтрация данных
 С помощью объекта Session для каждой операции добавления и изменения создается
новый экземпляр AuditLogRecord.
 Выталкиваем контекст и закрываем временный сеанс (Session) независимо от ориги-
нального сеанса (Session).
Теперь можно подключать этот перехватчик во время создания объекта Entity-
Manager, как свойство Hibernate:
Файл: /examples/src/test/java/org/jpwh/test/filtering/AuditLogging.java
EntityManagerFactory emf = JPA.getEntityManagerFactory();
Map<String, String> properties = new HashMap<String, String>();
properties.put(
org.hibernate.jpa.AvailableSettings.SESSION_INTERCEPTOR,
AuditLogInterceptor.class.getName()
);
EntityManager em = emf.createEntityManager(properties);
Определение перехватчиков по умолчанию
Если для каждого экземпляра EntityManager потребуется использовать перехват-
чик по умолчанию, в параметре hibernate.ejb.interceptor (в файле persistence.xml)
нужно указать имя класса, реализующего интерфейс org.hibernate.Interceptor. Об-
ратите особое внимание, что, в отличие от перехватчика уровня сеанса, Hibernate
разделяет этот перехватчик по умолчанию между потоками, поэтому он должен
быть потокобезопасным! Реализация AuditLogInterceptor из примера не является
потокобезопасной.
Теперь перехватчик AuditLogInterceptor подключен к экземпляру EntityManager,
но его еще нужно настроить, передав экземпляр Session и идентификатор те-
кущего авторизованного пользователя. Это требует нескольких приведений типов
для доступа к Hibernate API:
Файл: /examples/src/test/java/org/jpwh/test/filtering/AuditLogging.java
Session session = em.unwrap(Session.class);
AuditLogInterceptor interceptor =
(AuditLogInterceptor) ((SessionImplementor) session).getInterceptor();
interceptor.setCurrentSession(session);
interceptor.setCurrentUserId(CURRENT_USER_ID);
Экземпляр EntityManager теперь готов к использованию, и при каждом сохране-
нии и изменении экземпляра Item с его помощью в журнал аудита будет вноситься
запись.
Перехватчики Hibernate более гибкие, чем приемники событий JPA и методы
обратного вызова, – они позволяют получить гораздо больше контекстной инфор-
мации при наступлении события. Наряду с этим Hibernate позволяет еще глубже
внедряться в свое ядро благодаря своей полностью расширяемой системе событий.
Каскадная передача изменений состояния  383
13.2.3. Базовый механизм событий
Ядро механизма Hibernate основано на модели событий и приемников. Например,
если Hibernate потребуется сохранить экземпляр сущности, он сгенерирует собы-
тие. И все, кто принимает события этого типа, сможет среагировать на сохранение
данных. То есть вся базовая функциональность Hibernate реализована в виде на-
бора приемников по умолчанию, обрабатывающих все события Hibernate.
Hibernate имеет открытую архитектуру: вы можете создавать и использовать
собственные приемники событий. Можно подменять приемники по умолчанию
или дополнять их, чтобы получить побочные эффекты или выполнить дополни-
тельные процедуры. Подмена приемников событий происходит редко; это означало
бы, что ваша реализация берет на себя часть базовой функциональности Hibernate.
Фактически каждый метод интерфейса Session (и его более простого собрата,
интерфейса EntityManager) соответствует некоторому событию. Методы find()
и load() генерируют событие LoadEvent, и по умолчанию это событие обрабатыва-
ется экземпляром DefaultLoadEventListener.
Ваш собственный приемник должен реализовать подходящий интерфейс для
события, которое он будет обрабатывать, и/или расширять один из вспомогатель-
ных базовых классов Hibernate или приемников событий по умолчанию. Далее
показан пример реализации собственного приемника событий загрузки.
Листинг 13.3  Собственный слушатель событий загрузки
Файл: /examples/src/test/java/org/jpwh/test/filtering/SecurityLoadListener.java
public class SecurityLoadListener extends DefaultLoadEventListener {
public void onLoad(LoadEvent event, LoadEventListener.LoadType loadType)
throws HibernateException {
boolean authorized =
MySecurity.isAuthorized(
event.getEntityClassName(), event.getEntityId()
);
if (!authorized)
throw new MySecurityException("Unauthorized access");
super.onLoad(event, loadType);
}
}
Этот приемник может выполнять нестандартный код авторизации. Фактически
приемник должен быть объектом-одиночкой (singleton); он совместно использу-
ется разными контекстами хранения, поэтому в нем не должно быть переменных
состояния, связанных с транзакциями. Список всех оригинальных событий и ин-
терфейсов приемников событий в Hibernate можно найти в документации Javadoc
для пакета org.hibernate.event.
Приемники для каждого базового события можно настроить в файле persistence.
xml в элементе <persistenceunit>:
384  Фильтрация данных
Файл: /model/src/main/resources/META-INF/persistence.xml
<properties>
<property name="hibernate.ejb.event.load"
value="org.jpwh.test.filtering.SecurityLoadListener"/>
</properties>
Название свойства конфигурации всегда начинается с префикса hibernate.ejb.
event, за которым указывается тип принимаемого события. Список всех типов со-
бытий находится в классе org.hibernate.event.spi.EventType. В качестве значения
свойства можно указать список имен классов-приемников, перечисленных через
запятую; Hibernate будет вызывать их в порядке перечисления.
Но расширять систему базовых событий Hibernate собственной функциональ-
ностью требуется нечасто. Для большинства ситуаций достаточно интерфейса
org.hibernate.Interceptor. Он позволяет получить больше возможностей и заместить
любую часть ядра механизма Hibernate согласно принципу модульности.
Реализация внесения записей в журнал аудита, показанная в предыдущем раз-
деле, была очень простой. Если для аудита потребуется сохранять больше инфор-
мации, например значения измененных полей сущности, обратите внимание на
Hibernate Envers.
13.3. Аудит и версионирование с помощью
Hibernate Envers
Envers – это проект семейства Hibernate, задачей которого являются ведение жур-
нала аудита и хранение нескольких версий данных в базе. Своим действием он
напоминает системы управления версиями, такие как Subversion или Git, которые
могут быть вам уже знакомы.
После настройки механизма Envers он автоматически будет сохранять в от-
дельных таблицах копии при добавлении, изменении или удалении данных из
основных таблиц. Envers использует программный интерфейс событий Hibernate,
который вы видели в предыдущем разделе. Envers перехватывает события и, когда
Hibernate сохраняет изменения в базу данных, создает копии данных и сохраняет
их в собственных таблицах.
Envers группирует все изменения, произведенные в рамках единицы работы,
то есть в транзакции, в один набор изменений с общей версией. Для извлечения
архивных данных с заданной версией или меткой времени можно создавать за-
просы, используя интерфейс Envers API: например, «найти все экземпляры Item
по состоянию на прошлую пятницу». Но для начала следует подключить Envers
к приложению.
13.3.1. Включение ведения журнала аудита
Как только JAR-файл проекта Envers будет добавлен в путь поиска классов (или,
как показано в коде примеров, в зависимости Maven), его можно использовать без
Аудит и версионирование с помощью Hibernate Envers  385
дополнительных настроек. Аудит класса сущности можно осуществлять избира-
тельно, при помощи аннотации @org.hibernate.envers.Audited.
Листинг 13.4  Включение аудита для сущности Item
Файл: /model/src/main/java/org/jpwh/model/filtering/envers/Item.java
@Entity
@org.hibernate.envers.Audited
public class Item {
@NotNull
protected String name;
@OneToMany(mappedBy = "item")
@org.hibernate.envers.NotAudited
protected Set<Bid> bids = new HashSet<Bid>();
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "SELLER_ID", nullable = false)
protected User seller;
// ...
}
Теперь приложение будет вести журнал аудита для экземпляров Item и всех
свойств сущности. Чтобы выключить аудит для конкретного свойства, нужно от-
метить его аннотацией @NotAudited. В данном случае Envers будет игнорировать
коллекцию bids, но осуществлять аудит для seller. Также требуется поместить
аннотацию @Audited перед классом User.
Hibernate сгенерирует (или будет искать) дополнительные таблицы в базе для
хранения архивных данных каждого экземпляра Item и User. Схема таблиц пред-
ставлена на рис. 13.1.
ID << PK >>
USERNAME
<< Table >>
ID << PK >> USERS
NAME
SELLER_ID << FK >>
<< Table >>
ITEM
REV << PK >>
REVTSTMP
<< Table >>
ID << PK >> REVINFO
NAME
SELLER_ID
REV << PK >> << FK >>
REVTYPE
<< Table >>
ITEM_AUD
ID << PK >>
USERNAME
REV << PK >> << FK >>
REVTYPE
<< Table >>
USERS_AUD
Рис. 13.1  Таблицы журнала аудита для сущностей Item и User
История изменений хранится в таблицах ITEM_AUD и USERS_AUD, соответствую-
щих экземплярам Item и User. При изменении данных с последующим подтверж-
дением транзакции Hibernate сохранит новый номер версии с меткой времени
386  Фильтрация данных
в таблицу REVINFO. Затем для всех модифицированных экземпляров сущностей из
набора изменений, для которых настроен аудит, создаст копию данных и сохранит
в таблицы журнала аудита. Внешние ключи в виде номеров версий связывают на-
бор изменений воедино. В столбце REVTYPE хранится тип изменения: был ли кон-
кретный экземпляр сущности добавлен, изменен или удален во время транзакции.
Envers никогда не удаляет информацию о версиях и архивные данные; даже после
вызова метода remove() для экземпляра Item его предыдущая версия по-прежнему
будет храниться в таблице ITEM_AUD.
Давайте выполним несколько транзакций, чтобы понять, как это работает.
13.3.2. Ведение аудита
Далее мы рассмотрим несколько транзакций, использующих экземпляр Item и его
поле seller типа User. Мы создадим и сохраним экземпляры Item и User, затем из-
меним их и, наконец, удалим экземпляр Item.
Этот код уже должен быть вам знаком. Когда вы будете работать с объектом
EntityManager, Envers автоматически создаст записи в журнале аудита:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
tx.begin();
EntityManager em = JPA.createEntityManager();
User user = new User("johndoe");
em.persist(user);
Item item = new Item("Foo", user);
em.persist(item);
tx.commit();
em.close();
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);
item.setName("Bar");
item.getSeller().setUsername("doejohn");
tx.commit();
em.close();
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
tx.begin();
EntityManager em = JPA.createEntityManager();
Item item = em.find(Item.class, ITEM_ID);
em.remove(item);
tx.commit();
em.close();
Аудит и версионирование с помощью Hibernate Envers  387
Во время выполнения этих транзакций Envers создаст записи в журнале аудита
в виде трех наборов изменений. Для доступа к этим архивным данным для начала
нужно узнать версию, соответствующую требуемому набору изменений.
13.3.3. Поиск версий
Используя интерфейс Envers AuditReader, можно отыскать номер версии для каж-
дого набора изменений:
Листинг 13.5  Получение номеров версий для наборов изменений
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
AuditReader auditReader = AuditReaderFactory.get(em);  Интерфейс AuditReader
Number revisionCreate =  Получение версии номера
auditReader.getRevisionNumberForDate(TIMESTAMP_CREATE);
Number revisionUpdate =
auditReader.getRevisionNumberForDate(TIMESTAMP_UPDATE);
Number revisionDelete =
auditReader.getRevisionNumberForDate(TIMESTAMP_DELETE);
List<Number> itemRevisions = auditReader.getRevisions(Item.class, ITEM_ID);
assertEquals(itemRevisions.size(), 3);
for (Number itemRevision : itemRevisions) {
Date itemRevisionTimestamp = auditReader.getRevisionDate(itemRevision);
// ...
}
List<Number> userRevisions = auditReader.getRevisions(User.class, USER_ID);
assertEquals(userRevisions.size(), 2);
 Интерфейс AuditReader – это основа Envers API. Получить доступ к нему можно с по-
мощью объекта EntityManager.
 Получив метку времени, можно отыскать номер версии набора изменений, выполнен-
ных ранее этой метки или одновременно с ней.
 Если метка времени отсутствует, можно извлечь все номера версий, соответствующие
конкретному экземпляру сущности, для которой настроен аудит. Эта операция отыщет
все наборы изменений, в которых заданный экземпляр Item был создан, изменен или уда-
лен. В нашем примере мы создали, изменили и удалили экземпляр Item. Как результат
мы получили три версии.
 Имея номер версии, можно узнать метку времени, когда Envers зарегистрировал набор
изменений.
 Мы создали и изменили экземпляр User, поэтому в результате мы получили только две
версии.
В листинге 13.5 предполагается, что у нас есть метка времени (приблизитель-
ная) транзакции или идентификатор сущности (для получения всех версий). Если
эта информация отсутствует, придется исследовать журнал аудита с помощью за-
просов. Это бывает также полезно, когда нужно показать все наборы изменений
в интерфейсе пользователя приложения.
 Поиск наборов изменений
 Получение метки времени
 Подсчет количества версий
388  Фильтрация данных
Следующий код извлекает все версии сущности Item и загружает каждую вер-
сию Item вместе с данными аудита для конкретного набора изменений:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
AuditQuery query = auditReader.createQuery()  Запрос для получения данных аудита
.forRevisionsOfEntity(Item.class, false, false);
List<Object[]> result = query.getResultList();  Получение данных аудита
for (Object[] tuple : result) {
Item item = (Item) tuple[0];  Получение информации о версии
DefaultRevisionEntity revision = (DefaultRevisionEntity)tuple[1];
RevisionType revisionType = (RevisionType)tuple[2];
if (revision.getId() == 1) {  Получение типа версии
assertEquals(revisionType, RevisionType.ADD);
assertEquals(item.getName(), "Foo");
} else if (revision.getId() == 2) {
assertEquals(revisionType, RevisionType.MOD);
assertEquals(item.getName(), "Bar");
} else if (revision.getId() == 3) {
assertEquals(revisionType, RevisionType.DEL);
assertNull(item);
}
}
 Если не известны ни метки времени, ни номера версий, можно создать запрос с помощью
метода forRevisionsOfEntity() и получить все записи из журнала аудита для конкретной
сущности.
 Этот запрос возвращает записи из журнала в виде коллекции List с элементами типа
Object[].
 Каждый кортеж в списке результатов содержит экземпляр сущности для конкретной
версии, информацию о версии (включая номер версии и метку времени), а также тип
версии.
 Тип версии указывает на причину ее создания: вставка, изменение или удаление из базы
данных.
Номера версий увеличиваются последовательно; больший номер соответствует
более поздней версии экземпляра сущности. Теперь у нас есть номера версий для
трех наборов изменений в журнале аудита, и мы можем получить доступ к архив-
ным данным.
13.3.4. Получение архивных данных
Зная номера версий, можно извлекать различные состояния товара (Item) и его
продавца (seller).
Аудит и версионирование с помощью Hibernate Envers  389
Листинг 13.6  Загрузка предыдущих версий экземпляра сущности
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
Item item = auditReader.find(Item.class, ITEM_ID, revisionCreate);
assertEquals(item.getName(), "Foo");
assertEquals(item.getSeller().getUsername(), "johndoe");
Item modifiedItem = auditReader.find(Item.class,  Загрузка измененного экземпляра Item
ITEM_ID, revisionUpdate);
assertEquals(modifiedItem.getName(), "Bar");
assertEquals(modifiedItem.getSeller().getUsername(), "doejohn");
Item deletedItem = auditReader.find(Item.class,  Работа с удаленным экземпляром Item
ITEM_ID, revisionDelete);
assertNull(deletedItem);
User user = auditReader.find(User.class,  Получение самой последней версии
USER_ID, revisionDelete);
assertEquals(user.getUsername(), "doejohn");
 Если передать методу find() конкретную версию, он вернет соответствующее состояние
экземпляра сущности. Эта операция возвращает состояние экземпляра Item после его
создания.
 Эта операция возвращает состояние экземпляра Item после его изменения. Обратите
внимание, что значение свойства seller для этого набора изменений извлекается авто-
матически.
 Эта версия соответствует удаленному экземпляру Item, поэтому find() вернет null.
 В этой версии экземпляр User остался неизменным, поэтому Envers возвращает наиболее
близкое к данной версии состояние.
Операция AuditReader#find() возвращает только один экземпляр сущности – так
же, как и EntityManager#find(). Но возвращаемые экземпляры сущностей не нахо-
дятся в хранимом состоянии – они не управляются контекстом хранения. При из-
менении старой версии экземпляра Item Hibernate не выполнит обновления базы
данных. Обращайтесь с экземпляром сущности, возвращаемым интерфейсом AuditReader
API, как с отсоединенным или доступным только для чтения.
Кроме того, AuditReader имеет API, похожий на Criteria API в Hibernate, по-
зволяющий выполнять произвольные запросы (см. раздел 16.3).
Листинг 13.7  Получение старых версий экземпляров сущностей
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
AuditQuery query = auditReader.createQuery()
.forEntitiesAtRevision(Item.class, revisionUpdate);
query.add(  Добавление ограничения
AuditEntity.property("name").like("Ba", MatchMode.START)
);
 Возвращает экземпляр,
для которого настроен аудит
 Возвращает экземпляры Item,
соответствующие конкретной
версии
390  Фильтрация данных
query.add(  Добавление ограничения
AuditEntity.relatedId("seller").eq(USER_ID)
);
query.addOrder(  Упорядочение результатов
AuditEntity.property("name").desc()
);
query.setFirstResult(0);  Постраничный вывод
query.setMaxResults(10);
assertEquals(query.getResultList().size(), 1);
Item result = (Item)query.getResultList().get(0);
assertEquals(result.getSeller().getUsername(), "doejohn");
 Этот запрос вернет экземпляры Item, соответствующие конкретной версии и набору из-
менений.
 Вы можете добавлять в запрос ограничения: здесь значение поля Item#name должно на-
чинаться с «Ba».
 Ограничения могут касаться связей сущностей: например, можно отыскать версию това-
ра (Item), проданного конкретным пользователем (User).
 Результаты запроса можно упорядочивать.
 Объемные результаты можно выводить постранично.
Также Envers поддерживает операцию проекции. Следующий запрос вернет
только поле Item#name, соответствующее конкретной версии:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
AuditQuery query = auditReader.createQuery()
.forEntitiesAtRevision(Item.class, revisionUpdate);
query.addProjection(
AuditEntity.property("name")
);
assertEquals(query.getResultList().size(), 1);
String result = (String)query.getSingleResult();
assertEquals(result, "Bar");
Наконец, вам может понадобиться откатить экземпляр сущности к предыду-
щей версии. Это можно сделать, вызвав метод Session#replicate() и изменив су-
ществующую запись в базе данных. Следующий пример загружает экземпляр User
из первого набора изменений, а затем заменяет актуальный экземпляр User в базе
данных предыдущей версией:
Файл: /examples/src/test/java/org/jpwh/test/filtering/Envers.java
User user = auditReader.find(User.class, USER_ID, revisionCreate);
em.unwrap(Session.class)
.replicate(user, ReplicationMode.OVERWRITE);
em.flush();
Динамическая фильтрация данных  391
em.clear();
user = em.find(User.class, USER_ID);
assertEquals(user.getUsername(), "johndoe");
Envers зарегистрирует это изменение в журнале аудита как обновление; это
лишь еще одна версия экземпляра User.
Хронологические данные – это сложная тема, и мы рекомендуем изучить доку-
ментацию Envers для получения дополнительной информации. Добавить в журнал
аудита такую информацию, как имя пользователя, сделавшего изменение, не так уж
сложно. В документации также рассказывается о выборе различных стратегий от-
слеживания изменений и модификации схемы базы данных, используемой Envers.
Теперь представьте, что вам не требуется видеть все данные в базе. Например,
у текущего пользователя приложения может не быть прав для просмотра всей ин-
формации.
Как правило, для отбора требуемой информации в запросы добавляются
различные условия. Но это довольно сложно при работе с такой областью, как
безопасность,
поскольку требуется менять большинство запросов в приложении.
Но с помощью динамических фильтров данных Hibernate можно изолировать эти
ограничения в одном месте.
13.4. Динамическая фильтрация данных
Первой областью применения динамической фильтрации является обеспечение
безопасности данных. В приложении CaveatEmptor пользователю (User) можно
присвоить ранг в виде целого числа:
Файл: /model/src/main/java/org/jpwh/model/filtering/dynamic/User.java
@Entity
@Table(name = "USERS")
public class User {
@NotNull
protected int rank = 0;
// ...
}
Теперь предположим, что пользователи могут делать ставки только для тех то-
варов, которые предлагают пользователи с равным или меньшим рангом. Говоря
на языке бизнеса, имеется несколько групп пользователей, определяемых про-
извольно выбранным рангом (числом), и пользователи могут торговать только
с теми, у кого ранг такой же или меньше.
Для реализации этого требования нам пришлось бы переписать все запросы,
загружающие экземпляры Item из базы данных. Нужно было бы проверять ранг
у объекта Item#seller и сравнивать его с рангом текущего пользователя. Hibernate
может сделать эту работу за вас с помощью динамического фильтра.
392  Фильтрация данных
13.4.1. Создание динамических фильтров
Прежде всего необходимо определить фильтр, задав его имя и параметры, кото-
рые он будет принимать во время выполнения. Это определение можно оформить
в виде аннотации Hibernate перед любым классом сущности из предметной моде-
ли или в файле метаданных package-info.java:
Файл: /model/src/main/java/org/jpwh/model/filtering/dynamic/package-info.
java
@org.hibernate.annotations.FilterDef(
name = "limitByUserRank",
parameters = {
@org.hibernate.annotations.ParamDef(
name = "currentUserRank", type = "int"
)
}
)
В этом примере фильтр называется limitByUserRank; обратите внимание, что
имя фильтра должно быть уникальным в пределах единицы хранения. Во время
выполнения он принимает один аргумент типа int. Если имеется несколько опре-
делений фильтров, их можно объявить в аннотации @org.hibernate.annotations.
FilterDefs.
Пока фильтр неактивен; ничто не указывает, что он должен применяться к эк-
земплярам Item. Мы должны реализовать фильтр и применить его к тем классам
и коллекциям, которые нужно фильтровать.
13.4.2. Применение фильтра
Нам требуется применить заданный фильтр к классу Item, чтобы ни один экзем-
пляр не был доступен пользователям, не имеющим соответствующего ранга:
Файл: /model/src/main/java/org/jpwh/model/filtering/dynamic/Item.java
@Entity
@org.hibernate.annotations.Filter(
name = "limitByUserRank",
condition =
":currentUserRank >= (" +
"select u.RANK from USERS u " +
"where u.ID = SELLER_ID" +
")"
)
public class Item {
// ...
}
Условие condition представлено выражением SQL, которое выполняется на сто-
роне базы данных, поэтому в нем можно использовать любой оператор или функ-
Динамическая фильтрация данных  393
цию SQL. Оно должно возвращать значение true для записей, соответствующих
условию. В данном примере для получения ранга (поля rank) продавца товара ис-
пользуется подзапрос. Имена столбцов, такие как SELLER_ID, относятся к табли-
це, отображаемой на класс сущности. Если ранг текущего пользователя окажется
ниже ранга, который вернет подзапрос, экземпляр Item не пройдет фильтрацию.
Есть возможность объединить несколько фильтров с помощью аннотации @org.
hibernate.annotations.Filters.
Если после определения и применения фильтра активировать его в конкретной
единице работы, он начнет фильтровать все экземпляры Item, не соответствующие
условию. Давайте активируем его.
13.4.3. Активация фильтра
Мы определили фильтр данных и применили его к классу хранимой сущности.
Но это еще не полноценный фильтр – он должен быть активирован и параметри-
зован в рамках конкретной единицы работы с помощью Session API:
Файл: /examples/src/test/java/org/jpwh/test/filtering/DynamicFilter.java
org.hibernate.Filter filter = em.unwrap(Session.class)
.enableFilter("limitByUserRank");
filter.setParameter("currentUserRank", 0);
Активация фильтра производится по имени; метод возвращает объект Filter,
параметры которому передаются динамически во время выполнения. Вы должны
сами передать значения параметров; здесь устанавливается ранг, равный 0. В дан-
ном примере отфильтровываются все товары (Item), проданные пользователями
(User), имеющие больший ранг.
В классе Filter определено еще несколько полезных методов, таких как get-
FilterDefinition() (позволяет последовательно обращаться к именам параметров
и типам) и validate() (возбуждает исключение HibernateException, если забыть
установить значение параметра). Также можно передать список аргументов с по-
мощью метода setParameterList(); это очень удобно, если ограничение SQL содер-
жит выражение с операторами, работающими на множествах (например, с опера-
тором IN).
Теперь каждый запрос на основе критериев или JPQL, выполняемый в рамках
фильтруемого контекста хранения, будет возвращать отфильтрованное множество
экземпляров Item:
Файл: /examples/src/test/java/org/jpwh/test/filtering/DynamicFilter.java
List<Item> items = em.createQuery("select i from Item i").getResultList();
// select * from ITEM where 0 >=
// (select u.RANK from USERS u where u.ID = SELLER_ID)
Файл: /examples/src/test/java/org/jpwh/test/filtering/DynamicFilter.java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery();
394  Фильтрация данных
criteria.select(criteria.from(Item.class));
List<Item> items = em.createQuery(criteria).getResultList();
// select * from ITEM where 0 >=
// (select u.RANK from USERS u where u.ID = SELLER_ID)
Обратите внимание, как Hibernate динамически добавляет условия ограниче-
ний SQL в сформированные запросы.
При первом знакомстве с динамическими фильтрами вы, возможно, столкне-
тесь с особенностями извлечения по идентификатору. Вы, наверное, ожидаете, что
результат вызова em.find(Item.class, ITEM_ID) также будет отфильтрован. Однако
это не так: Hibernate не применяет фильтров к операциям извлечения по иден-
тификатору. Одна из причин заключается в том, что условия фильтрации – это
фрагменты SQL, а поиск по идентификатору может полностью осуществляться
целиком в кэше контекста хранения первого уровня. Аналогичные рассуждения
применимы и к связям многие к одному и один к одному. Если бы связь многие
к одному подвергалась фильтрации (возвращая, например, null при вызове anItem.
getSeller()), тогда изменилась бы множественность связи! Вы бы не узнали, есть
ли у товара продавец, если бы не могли его увидеть.
Но вы можете динамически ограничивать доступ к коллекциям. Помните, что
хранимые коллекции – это лишь псевдонимы для запросов.
13.4.4. Фильтрация коллекций
До сих пор вызов метода someCategory.getItems() возвращал все товары (Item),
принадлежащие конкретной категории (Category). Но можно добавить ограниче-
ние, применив для коллекции фильтр:
Файл: /model/src/main/java/org/jpwh/model/filtering/dynamic/Category.java
@Entity
public class Category {
@OneToMany(mappedBy = "category")
@org.hibernate.annotations.Filter(
name = "limitByUserRank",
condition =
":currentUserRank >= (" +
"select u.RANK from USERS u " +
"where u.ID = SELLER_ID" +
")"
)
protected Set<Item> items = new HashSet<Item>();
// ...
}
Если теперь активировать фильтр в рамках сеанса (Session), объекты, возвра-
щаемые во время обхода коллекции Category#items, будут отфильтрованы:
Резюме  395
Файл: /examples/src/test/java/org/jpwh/test/filtering/DynamicFilter.java
filter.setParameter("currentUserRank", 0);
Category category = em.find(Category.class, CATEGORY_ID);
assertEquals(category.getItems().size(), 1);
Если ранг текущего пользователя равен 0, при загрузке коллекции будет полу-
чен лишь один экземпляр Item. Изменив значение ранга на 100, вы увидите больше
данных:
Файл: /examples/src/test/java/org/jpwh/test/filtering/DynamicFilter.java
filter.setParameter("currentUserRank", 100);
category = em.find(Category.class, CATEGORY_ID);
assertEquals(category.getItems().size(), 2);
Вы, должно быть, заметили, что условие SQL одинаково в обоих случаях при-
менения фильтра. Если ограничение SQL одинаково для всех случаев применения
фильтра, его можно установить в качестве условия по умолчанию, чтобы избежать
повторения:
Файл: /model/src/main/java/org/jpwh/model/filtering/dynamic/package-info.java
@org.hibernate.annotations.FilterDef(
name = "limitByUserRankDefault",
defaultCondition=
":currentUserRank >= (" +
"select u.RANK from USERS u " +
"where u.ID = SELLER_ID" +
")",
parameters = {
@org.hibernate.annotations.ParamDef(
name = "currentUserRank", type = "int"
)
}
)
Существует множество других интересных вариантов применения динамиче-
ской фильтрации данных. Вы уже видели ограничение доступа к данным на основе
произвольного условия, касающегося безопасности. Это может быть ранг пользо-
вателя, принадлежность к определенной группе или назначенная пользователю
роль. Данные могут храниться вместе с кодом региона (например, все деловые
контакты отдела продаж). Или, к примеру, каждый менеджер по продажам мог бы
работать только с данными, относящимися к его региону.
13.5. Резюме
 Каскадная передача изменений состояния – это предопределенные реакции
механизма хранения на события жизненного цикла.
396  Фильтрация данных
 Вы узнали, как принимать и обрабатывать события. Создали реализацию при-
емников и обработчиков событий, чтобы выполнить дополнительную логику
в процессе загрузки и сохранения данных. Познакомились с методами обрат-
ного вызова JPA и механизмом расширения Interceptor, а также с ядром систе-
мы событий Hibernate.
 Вы можете использовать Hibernate Envers для ведения журнала аудита и хра-
нения нескольких версий данных в базе (как в системе контроля версий). При
работе с Envers копия данных автоматически сохраняется в отдельных табли-
цах, когда происходит добавление, изменение или удаление данных из таблиц.
Envers объединяет все изменения, произведенные в транзакции, в отдельный
набор изменений со своим номером версии. Вы можете использовать запросы
к Envers и извлекать архивные данные.
 Используя динамическую фильтрацию данных, Hibernate может автоматиче-
ски добавлять ограничения SQL к формируемым запросам.
ID << PK >>
STREET
ZIPCODE
CITY
<< Table >>
ADDRESS
ID << PK >> << FK >>
USERNAME
FIRSTNAME
LASTNAME
<< Table >>
USERS
ID << PK >>
CC_OWNER
CARDNUMBER
EXPMONTH
EXPYEAR
<< Table CREDITCARD
owner : String
BillingDetails
id : Long
cardNumber : String
expMonth : String
expYear : String
CreditCard
id : Long
account : String
bankname : String
swift : String
BankAccount
Часть IV
СОЗДАНИЕ
ЗАПРОСОВ
В части IV мы познакомимся с особенностями, а также подробно изучим API
и языки запросов. Не все главы в этой части написаны как руководство; мы рас-
считываем, что вы будете часто заглядывать в эту часть книги во время разработки
приложений в поисках решений проблем с конкретными запросами.
Начиная с главы 14, мы будем рассказывать о создании и выполнении запросов
с помощью базового API, а также об оптимизации их выполнения. В главе 15 мы
обсудим различные языки запросов, покажем, как создавать запросы JPQL и на
основе критериев, расскажем, как эффективно извлекать данные с помощью со-
единений и как создавать отчеты с применением запросов и подзапросов. В главе
16 мы углубимся в изучение более продвинутых возможностей: преобразование
результатов, фильтрацию коллекций и создание запросов на основе критериев
с помощью Hibernate API. Наконец, в главе 17 мы опишем такие приемы, как ис-
пользование JDBC, отображение результатов запросов SQL, настройка операций
создания, чтения, изменения, удаления (CRUD), а также вызов хранимых про-
цедур.
После прочтения этой части книги вы сможете извлекать любую информацию
из базы данных, используя различные варианты запросов, настраивая доступ
к данным по необходимости.
Глава 14
Создание
и выполнение запросов
В этой главе:
 базовый API запросов;
 создание и подготовка запросов;
 оптимизация выполнения запросов.
Если вы много лет писали SQL-запросы вручную, вас наверняка беспокоит воз-
можность лишиться привычной гибкости и выразительности. Но, смеем вас уве-
рить, при использовании Hibernate и Java Persistence этого не произойдет.
Мощные механизмы запросов в Hibernate и Java Persistence позволяют выра-
зить практически все, что вам часто (или нечасто) приходилось делать с помощью
SQL, но используя при этом объектно-ориентированный подход – с помощью
классов и полей. Более того, вы всегда сможете вернуться к SQL и переложить на
Hibernate всю тяжелую работу по обработке результатов запроса. Дополнитель-
ные ресурсы, посвященные SQL, находятся в справочном разделе.
Главные нововведения в JPA 2
• Прикладной интерфейс для программного создания типизированных запросов
на основе критериев.
• С помощью интерфейса TypedQuery теперь можно объявить тип результата запро-
са в самом начале.
• Можно программно сохранить объект Query (JPQL, запрос на основе критериев
или обычный запрос SQL) для повторного использования в качестве именован-
ного запроса.
• В дополнение к возможности задавать параметры, подсказки, максимальное
количество результатов, режим выталкивания контекста и блокировки JPA 2 до-
бавляет в Query API разнообразные методы чтения для получения текущих на-
строек.
• В JPA стандартизировано несколько рекомендаций для запросов (максималь-
ное время ожидания, использование кэширования).
Создание запросов  399
В этой главе мы покажем, как создавать и выполнять запросы с помощью JPA
и Hibernate API. Запросы будут максимально простыми, чтобы вы могли сосре-
доточиться на API для их создания и выполнения, не отвлекаясь на незнакомые
языки запросов (они будут рассмотрены в следующей главе).
Общим для всех API является необходимость подготовки запроса в коде при-
ложения перед выполнением, включающей три шага:
1) создание запроса с произвольной выборкой, ограничениями и проекциями
извлекаемых данных;
2) подготовка запроса: связывание аргументов с параметрами запроса, уста-
новка подсказок и настройка постраничного вывода. Вы можете повторно
использовать запрос, изменяя его настройки;
3) выполнение подготовленного запроса в базе данных и извлечение информа-
ции. Вы можете управлять выполнением запроса и способом загрузки дан-
ных в память (например, загружать все сразу или по частям).
В зависимости от разновидности отправной точкой для создания запроса будет
EntityManager или Session. Первый шаг – создание запроса.
14.1. Создание запросов
JPA представляет запрос в виде объекта javax.persistence.Query или javax.persistence.
TypedQuery. Запросы создаются с помощью метода EntityManager#createQuery()
или его вариантов. Запрос может быть написан на языке Java Persistence Query
Language (JPQL), создан при помощи объекта CriteriaBuilder или интерфей-
са CriteriaQuery API или написан на обычном SQL (также доступен интерфейс
javax.persistence.StoredProcedureQuery, который рассматривается в разделе 17.4).
В Hibernate есть свои, более старые API запросов: org.hibernate.Query и org.
hibernate.SQLQuery. Мы поговорим о них чуть ниже, но сначала рассмотрим стан-
дартные интерфейсы и языки запросов JPA.
14.1.1. Интерфейсы запросов JPA
Предположим, что требуется извлечь все экземпляры Item из базы данных. Этот
простой запрос на языке JPQL выглядит очень похожим на SQL:
Query query = em.createQuery("select i from Item i");
Реализация JPA возвращает новый объект Query, но Hibernate еще не отправил
код SQL в базу данных. Помните, что дальнейшая подготовка и выполнение за-
проса являются отдельными шагами.
Язык JPQL прост и понятен каждому, имеющему опыт использования SQL.
Вместо имен столбцов и таблиц язык JPQL оперирует именами классов и свойств
сущностей. Не считая имен классов и свойств, JPQL не чувствителен к регистру,
поэтому не важно, напишите вы SeLEct или select.
Строки запросов JPQL (и SQL) могут быть простыми литералами в коде, как
в предыдущем примере. С другой стороны, особенно в больших приложениях,
строки запросов можно убрать из кода доступа к данным и поместить их в аннота-
400  Создание и выполнение запросов
ции или в файлы XML. Потом обратиться к запросу можно вызовом EntityManage
r#createNamedQuery(). Мы отдельно обсудим тему хранения запросов в отдельных
файлах далее в этой главе; существует много нюансов, которые нужно учитывать.
Наибольшее неудобство при работе с JPQL доставляет рефакторинг предмет-
ной модели: если переименовать класс Item, ваш запрос JPQL перестанет работать
(хотя некоторые IDE способны обнаруживать строки JPQL и проводить их ре-
факторинг).
JPA и языки запросов: HQL против JPQL
До появления JPA (а в некоторой документации и по сей день) язык запросов в Hibernate
назывался HQL. На сегодняшний день различия между JPQL и HQL сгла-
дились. Каждый раз, передавая строку запроса любому интерфейсу запросов Hibernate,
будь то EntityManager или Session, вы передаете строку JPQL/HQL. Внутри
эти строки обрабатывает один и тот же парсер. Основной синтаксис и семантика
совпадают, хотя, как обычно, Hibernate поддерживает некоторые конструкции, не
стандартизованные в JPA. Мы сообщим вам, если какое-то ключевое слово или
предложение в примере будет работать только с Hibernate. Для простоты, увидев
аббревиатуру HQL, мысленно подставляйте вместо нее JPQL.
С помощью интерфейсов CriteriaBuilder и CriteriaQuery можно создавать пол-
ностью типизированные запосы. В JPA эти запросы также называются запросами
на основе критериев:
CriteriaBuilder cb = em.getCriteriaBuilder();
// Можно использовать EntityManagerFactory:
// CriteriaBuilder cb = entityManagerFactory.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery();
criteria.select(criteria.from(Item.class));
Query query = em.createQuery(criteria);
Сначала нужно получить экземпляр CriteriaBuilder из объекта EntityManager,
вызвав getCriteriaBuilder(). Если у вас нет готового экземпляра EntityManager
(например, когда требуется создать запрос отдельно от конкретного контекста
хранения), экземпляр CriteriaBuilder можно получить из объекта EntityManager-
Factory, обычно доступный глобально.
Затем можно использовать экземпляр построителя (builder) и создать любое
количество экземпляров CriteriaQuery. Для каждого объекта CriteriaQuery дол-
жен быть указан хотя бы один корневой класс с помощью метода from(), как Item.
class в предыдущем примере. Это называется выборкой; мы расскажем больше
о выборках в следующей главе. Запрос в примере возвращает все экземпляры Item
из базы данных.
Интерфейс CriteriaQuery можно без проблем встроить в приложение, не ис-
пользуя операций со строками. Это лучший вариант, когда невозможно до кон-
ца определить запрос во время разработки и приложение должно формировать
Создание запросов  401
его динамически во время выполнения. Представьте, что требуется реализовать
в приложении поиск по маске, используя различные флажки, поля ввода и пере-
ключатели, которые может менять пользователь. Запрос к базе данных должен
быть сформирован автоматически, на основе указанных пользователем параметров
поиска. При использовании JPQL и конкатенации строк такой код трудно бу-
дет написать и поддерживать.
Вы можете создать строго типизированный объект CriteriaQuery безо всяких
строк, используя статическую метамодель JPA. Это означает, что ваши запросы
останутся в безопасности и смогут подвергаться рефакторингу, как уже было по-
казано в разделе «Статическая метамодель» в главе 3.
Создание отсоединенного запроса на основе критериев
Чтобы получить экземпляр JPA CriteriaBuilder, необходим объект EntityManager или
EntityManagerFactory. При работе с более старым оригинальным интерфейсом org.
hibernate.Criteria, чтобы создать отсоединенный запрос, необходим лишь доступ
к корневому классу сущности, как показано в разделе 16.3.
Когда необходимо использовать возможности, доступные только для вашей
базы данных, единственный вариант – использовать обычный SQL. Вы можете
непосредственно выполнить код SQL и возложить на Hibernate обработку резуль-
тата с помощью метода EntityManager#createNativeQuery():
Query query = em.createNativeQuery(
"select * from ITEM", Item.class
);
После выполнения этого запроса SQL Hibernate на основе данных в объекте
java.sql.ResultSet создаст коллекцию List управляемых экземпляров Item. Все
столбцы, необходимые для создания объекта Item, конечно же, должны присутство-
вать в результате; если запрос SQL не вернет их, будет возбуждено исключение.
На практике большинство запросов в вашем приложении будет довольно простым
– вы сможете легко написать их с помощью JPQL или CriteriaQuery. Затем,
возможно во время оптимизации, вы обнаружите несколько сложных запросов,
для которых очень важна производительность. Возможно, вам потребуется ис-
пользовать специальные ключевые слова SQL для управления оптимизатором
вашей СУБД. В таких случаях большинство разработчиков пишет запросы на
чистом
SQL вместо JPQL, сохраняя такие сложные запросы в файлах XML, где
их можно менять независимо от Java-кода с помощью администратора баз дан-
ных. Hibernate по-прежнему сможет обрабатывать результаты запроса за вас. Нет
ничего плохого в том, чтобы использовать SQL в приложении Hibernate; не дайте
ORM-«пуризму» помешать вам в этом. Сталкиваясь с особым случаем, не пытай-
тесь его спрятать, лучше выделите его особо и хорошо задокументируйте, чтобы
следующий инженер понимал, что происходит.
Порой бывает полезно указывать тип данных, возвращаемых запросом.
402  Создание и выполнение запросов
14.1.2. Результаты типизированных запросов
Предположим, нужно извлечь только один экземпляр Item по заданному иденти-
фикатору:
Query query = em.createQuery(
"select i from Item i where i.id = :id"
).setParameter("id", ITEM_ID);
Item result = (Item) query.getSingleResult();
Этот пример демонстрирует порядок связывания параметров и выполнение за-
проса. Обратите внимание на значение, возвращаемое методом getSingleResult().
Оно имеет тип java.lang.Object, и поэтому требуется выполнить приведение
к типу Item.
Но если во время создания запроса указать класс возвращаемого значения, при-
ведение типа будет не нужно. Эту работу выполнит интерфейс javax.persistence.
TypedQuery:
TypedQuery<Item> query = em.createQuery(
"select i from Item i where i.id = :id", Item.class
).setParameter("id", ITEM_ID);
Item result = query.getSingleResult(); Приведение типа не нужно
Интерфейс TypedQuery также поддерживается запросами на основе критериев:
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Item> criteria = cb.createQuery(Item.class);
Root<Item> i = criteria.from(Item.class);
criteria.select(i).where(cb.equal(i.get("id"), ITEM_ID));
TypedQuery<Item> query = em.createQuery(criteria);
Item result = query.getSingleResult(); Приведение типа не нужно
Обратите внимание, что этот запрос CriteriaQuery не является полностью типи-
зированным: имя свойства Item#id задается с помощью строки в методе get("id").
В главе 3, в разделе «Статическая метамодель», вы видели, как создавать полно-
стью типобезопасные запросы с помощью статической метамодели классов.
Hibernate старше самой первой версии JPA, поэтому в нем есть свои API для
работы с запросами.
Особенности Hibernate
14.1.3. Интерфейсы Hibernate для работы с запросами
В Hibernate запросы представлены объектами org.hibernate.Query и org.hibernate.
SQLQuery. Как обычно, они имеют больше возможностей, чем определено
в JPA, но за это приходится расплачиваться переносимостью. Эти интерфейсы го-
раздо старше, чем JPA, поэтому имеет место повторение функциональности.
Создание запросов  403
Чтобы воспользоваться Hibernate API для работы с запросами, требуется сна-
чала получить экземпляр Session:
Session session = em.unwrap(Session.class);
org.hibernate.Query query = session.createQuery("select i from Item i");
// Нестандартный API: query.setResultTransformer(...);
Запрос можно написать на обычном JPQL. Сравнивая javax.persistence.Query
с org.hibernate.Query, можно обнаружить несколько дополнительных нестандарт-
ных методов, доступных только в Hibernate. Вы узнаете больше об этом API далее
в этой и следующих главах.
В Hibernate также имеется собственный механизм отображения результатов за-
просов SQL, доступный в интерфейсе org.hibernate.SQLQuery:
Session session = em.unwrap(Session.class);
org.hibernate.SQLQuery query = session.createSQLQuery(
"select {i.*} from ITEM {i}"
).addEntity("i", Item.class);
Этот пример работает за счет использования символов подстановки в тексте
запроса SQL для отображения столбцов java.sql.ResultSet в свойства сущности.
В разделе 17.2 мы еще затронем тему интеграции запросов SQL с данным нестан-
дартным механизмом и с механизмом отображения JPA.
В Hibernate также имеется более старый интерфейс для создания запросов на
основе критериев – org.hibernate.Criteria:
Session session = em.unwrap(Session.class);
org.hibernate.Criteria query = session.createCriteria(Item.class);
query.add(org.hibernate.criterion.Restrictions.eq("id", ITEM_ID));
Item result = (Item) query.uniqueResult();
Чтобы получить доступ к Hibernate API для работы с запросами из интерфейса
javax.persistence.Query, нужно сначала преобразовать его в org.hibernate.jpa.HibernateQuery:
javax.persistence.Query query = em.createQuery(
// ...
);
org.hibernate.Query hibernateQuery =
query.unwrap(org.hibernate.jpa.HibernateQuery.class)
.getHibernateQuery();
hibernateQuery.getQueryString();
hibernateQuery.getReturnAliases();
// ... прочие вызовы проприетарного API
Далее мы сначала рассмотрим стандартный API, а затем покажем некоторые
продвинутые и редко используемые возможности, доступные только в Hibernate,
такие как прокрутка с помощью курсоров или запросы на основе примеров.
404  Создание и выполнение запросов
После создания запроса, но перед выполнением вам, возможно, понадобится
установить его параметры.
14.2. Подготовка запросов
Запрос одновременно решает несколько задач: определяет информацию, которая
должна быть загружена из базы данных, а также накладывает на нее ограничения,
которым она должна соответствовать, такие как идентификатор товара (Item) или
имя пользователя (User). При создании запроса необязательно внедрять эти па-
раметры в текст запроса, используя конкатенацию строк. Вместо этого предпочтительнее
использовать параметры и связать с ними значения аргументов перед
выполнением. Это позволяет повторно использовать запрос с разными значения-
ми аргументов, исключая возможность атак, основанных на внедрении SQL-кода.
В зависимости от требований пользовательского интерфейса может потребо-
ваться реализовать постраничную выборку. Для этого можно ограничить количество
записей, возвращаемых запросом. Например, можно вернуть записи с 1 по
20 – ровно столько, сколько можно показать на экране, – а позже извлечь строки
с 21 по 40 и т. д.
Начнем со связывания параметров.
14.2.1. Защита от атак на основе внедрения SQL-кода
Не имея возможности связывать параметры во время выполнения, вы вынуждены
писать плохой код:
String searchString = getValueEnteredByUser(); Никогда не делайте так!
Query query = em.createQuery(
"select i from Item i where i.name = '" + searchString + "'"
);
Никогда не пишите подобного кода, поскольку злоумышленник может сконструировать
строку поиска, которая позволит ему выполнить произвольный код
в базе данных, например введя значение переменной searchString в поле поиска
как foo' and callSomeStoredProcedure() and 'bar' = 'bar.
Как видите, searchString – уже не просто строка с поисковым запросом, а код,
вызывающий хранимую процедуру в базе данных! Символы кавычек не экрани-
руются; следовательно, вызов хранимой процедуры – это еще одно корректное
выражение в запросе. Конструируя текст запроса подобным образом, вы создаете
огромную брешь в безопасности приложения, позволяя выполнять произволь-
ный код на стороне базы данных. Это и есть атака на основе внедрения кода SQL.
Никогда не передавайте непроверенных данных от пользователя в базу данных!
К счастью, есть простой механизм, предотвращающий такую ошибку.
Механизм JDBC предоставляет возможность безопасного связывания значе-
ний с параметрами SQL. Он точно знает, какие символы в значениях аргументов
нужно экранировать, благодаря чему предыдущая уязвимость становится просто
Подготовка запросов  405
невозможной. К примеру, драйвер базы данных экранирует символы одинарных
кавычек в строке searchString и обращается с ними не как с управляющими сим-
волами, а как с частью строки поиска. Кроме того, при использовании параметров
база данных может эффективно кэшировать предварительно скомпилированные
выражения, значительно увеличивая производительность.
Существуют два подхода к связыванию параметров: по именам и по позициям.
JPA поддерживает оба варианта, но их нельзя использовать одновременно в одном
запросе.
14.2.2. Связывание именованных параметров
Используя именованные параметры, предыдущий запрос можно переписать так:
String searchString = // ...
Query query = em.createQuery(
"select i from Item i where i.name = :itemName"
).setParameter("itemName", searchString);
Двоеточие, за которым следует имя, определяет именованный параметр item-
Name. Следующий шаг – связать значение с параметром itemName. Такой код выгля-
дит опрятнее, он безопаснее и обладает лучшей производительностью, посколь-
ку вы можете повторно использовать скомпилированное выражение SQL, меняя
лишь значение параметра.
Вы можете получить множество (Set) всех объектов Parameter из экземпляра
запроса (Query), чтобы узнать больше о каждом параметре (например, имя или
Java-тип) или убедиться перед выполнением запроса, что все параметры связаны
со значениями:
for (Parameter<?> parameter : query.getParameters()) {
assertTrue(query.isBound(parameter));
}
Метод setParameter() – это обобщенная операция, которая может связывать
аргменты всех типов. Ей нужно только немного помочь при использовании зна-
чений времени:
Date tomorrowDate = // ...
Query query = em.createQuery(
"select i from Item i where i.auctionEnd > :endDate"
).setParameter("endDate", tomorrowDate, TemporalType.TIMESTAMP);
Для Hibernate важно знать, передавать ли дату, время или отметку времени.
Также ради удобства можно передать в метод setParameter() экземпляр:
Item someItem = // ...
Query query = em.createQuery(
"select b from Bid b where b.item = :item"
).setParameter("item", someItem);
406  Создание и выполнение запросов
Hibernate свяжет значение идентификатора переданного экземпляра Item. Далее
вы увидите, что выражение b.item – это лишь сокращенная форма записи b.item.id.
Для запросов на основе критериев существуют два способа связывания параметров,
простой и сложный:
String searchString = // ...
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery();
Root<Item> i = criteria.from(Item.class);
Query query = em.createQuery(
criteria.select(i).where(
cb.equal(
i.get("name"),
cb.parameter(String.class, "itemName")
)
)
).setParameter("itemName", searchString);
Здесь мы добавили в экземпляр CriteriaQuery параметр itemName типа String,
а затем связали его со значением, используя обычный метод Query#setParameter().
Можно также применить объект ParameterExpression, избавляющий от необхо-
димости придумывать имя для параметра и обеспечивающий безопасность типов
(нельзя связать значение типа Integer с объектом ParameterExpression<String>):
String searchString = // ...
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery criteria = cb.createQuery(Item.class);
Root<Item> i = criteria.from(Item.class);
ParameterExpression<String> itemNameParameter =
cb.parameter(String.class);
Query query = em.createQuery(
criteria.select(i).where(
cb.equal(
i.get("name"),
itemNameParameter
)
)
).setParameter(itemNameParameter, searchString);
Менее безопасный и редко используемый способ связывания значений – с ис-
пользованием позиционных параметров.
14.2.3. Связывание позиционных параметров
При желании вместо именованных параметров можно использовать позиционные:
Подготовка запросов  407
Query query = em.createQuery(
"select i from Item i where i.name like ?1 and i.auctionEnd > ?2"
);
query.setParameter(1, searchString);
query.setParameter(2, tomorrowDate, TemporalType.TIMESTAMP);
В этом примере позиционные параметры отмечены индексами ?1 и ?2. Похожие
обозначения параметров используются в JDBC, но только с одними знаками во-
просов без номеров. JPA требует нумерации параметров, начиная с 1.
ПРИМЕЧАНИЕ В Hibernate поддерживаются оба подхода, поэтому будьте
внимательны! Hibernate предупредит о ненадежном запросе, если вы будете
использовать позиционные параметры в стиле JDBC, обозначаемые только зна-
ками вопросов.
Мы рекомендуем избегать позиционных параметров. Возможно, их удобно ис-
пользовать для построения сложных запросов, но для этой цели лучше подходит
CriteriaQuery API.
После связывания параметров запроса можно настроить постраничную выбор-
ку, если невозможно сразу отобразить всех результатов.
14.2.4. Постраничная выборка больших наборов
с результатами
Для обработки больших наборов с результатами запросов на практике широко ис-
пользуется постраничная выборка. Пользователи могут просматривать результа-
ты своих поисковых запросов (например, конкретные товары) постранично. На
каждой странице отображается ограниченное подмножество (например, 10 това-
ров), и пользователи могут самостоятельно переходить к следующим и предыду-
щим страницам для просмотра остальных результатов запроса.
Интерфейс Query поддерживает постраничную выборку. В следующем примере
требуемая страница начинается в середине множества с результатами:
Query query = em.createQuery("select i from Item i");
query.setFirstResult(40).setMaxResults(10);
Этот код извлечет следующие десять записей, начиная с сороковой. Вызов set-
FirstResults(40) указывает, что страница начинается с записи № 40 во множестве
результатов. Вызов setMaxResults(10) ограничивает количество записей, возвра-
щаемых базой данных. Поскольку в SQL отсутствует стандартный способ пред-
ставления постраничной выборки, Hibernate использует особые приемы для эф-
фективной работы с конкретными СУБД.
Чрезвычайно важно помнить, что постраничная выборка реализована на уровне
SQL для строк результата. Ограничение результата десятью строками не обяза-
тельно означает то же самое, что ограничение результата десятью экземплярами
Item! В разделе 15.4.5 вы увидите несколько запросов с динамическим извлечением,
которые не могут работать совместно с постраничной выборкой строк на уровне
SQL, и мы снова обсудим этот вопрос.
408  Создание и выполнение запросов
Постраничная выборка поддерживается даже для запросов SQL:
Query query = em.createNativeQuery("select * from ITEM");
query.setFirstResult(40).setMaxResults(10);
Hibernate автоматически добавит в SQL-запрос необходимые предложения
и ключевые слова, ограничивающие количество возвращаемых строк для конкрет-
ной страницы.
На практике часто приходится совмещать постраничную выборку со специаль-
ным запросом подсчета записей. Отображая страницу со списком товаров, можно
также сообщить пользователю их полное количество. Кроме того, эта информация
понадобится, чтобы решить, остались ли еще непросмотренные страницы, и дать
пользователю возможность перейти к следующей. Обычно для этого требуется
выполнить два разных запроса: например, select i from Item i в сочетании с ме-
тодами setMaxResults() и setFirstResult() извлечет порцию результатов, а select
count(i) from Item i вернет количество доступных товаров.
Особенности Hibernate
Старайтесь избегать дополнительных затрат на поддержку практически одина-
ковых запросов. Часто с этой целью пишут один запрос, но выполняют его с помощью
курсора базы данных, чтобы получить общее количество результатов:
Query query = em.createQuery("select i from Item i");
org.hibernate.Query hibernateQuery =  Преобразовать API
query.unwrap(org.hibernate.jpa.HibernateQuery.class).getHibernateQuery();
org.hibernate.ScrollableResults cursor =  Выполнить запрос с помощью курсора
hibernateQuery.scroll(org.hibernate.ScrollMode.SCROLL_INSENSITIVE);
cursor.last();  Подсчитать записи
int count = cursor.getRowNumber()+1;
cursor.close();  Закрыть курсор
query.setFirstResult(40).setMaxResults(10);  Получить произвольный набор данных
 Преобразование Hibernate API для использования курсора с поддержкой прокрутки.
 Выполнение запроса с помощью курсора базы данных; результат запроса не загружается
в память.
 Переход к последней записи в наборе результатов в базе данных, с последующим получе-
нием количества строк. Поскольку нумерация строк начинается с нуля, чтобы получить
их количество, нужно к номеру последней строки прибавить 1.
 Закрыть курсор в базе данных.
 Вновь выполнить запрос и извлечь произвольную страницу с результатами.
Но этот удобный подход имеет один существенный недостаток: ваш JDBC-
драйвер и/или СУБД могут не поддерживать курсоров. Хуже того, может пока-
заться, что курсор работает, но данные будут незаметно загружаться в память при-
ложения; курсор работает не напрямую с базой данных. Драйверы Oracle и MySQL
Выполнение запросов  409
известны своими проблемами, и мы еще многое скажем о прокрутке результатов
запросов и курсорах в следующем разделе. Позже в этой книге, в разделе 19.2, мы
еще раз обсудим стратегии постраничной выборки на стороне приложения.
Теперь запрос готов к выполнению.
14.3. Выполнение запросов
После создания и подготовки экземпляра Query можно выполнить запрос и за-
грузить результаты в память. На практике часто используют прием извлечения
полного набора результатов запроса в память за одно обращение; мы называем
это выводом списка (listing). Существуют также другие варианты, которые мы об-
судим ниже, такие как прокрутка с помощью курсоров (scrolling) или итераторов
(iterating).
14.3.1. Извлечение полного списка результатов
Метод getResultList() выполнит запрос (Query) и вернет результаты в виде кол-
лекции java.util.List:
Query query = em.createQuery("select i from Item i");
List<Item> items = query.getResultList();
Hibernate сразу же выполнит одно или несколько SQL-выражений SELECT, в за-
висимости от стратегии извлечения. Если вы отобразили некоторые связи или
коллекции с параметром FetchType.EAGER, Hibernate должен извлечь их вместе
с основными данными. Все данные загружаются в память, и все экземпляры
сущностей, извлекаемые Hibernate, будут находиться в хранимом состоянии под
управлением контекста хранения.
Конечно, контекст хранения не управляет результатами скалярных проекций.
Следующий запрос вернет список (List) строк (String):
Query query = em.createQuery("select i.name from Item i");
List<String> itemNames = query.getResultList();
Некоторые запросы возвращают только единичный результат, например когда
нужна лишь самая большая ставка (Bid) за товар (Item).
14.3.2. Получение единичных результатов
Выполнить запрос, возвращающий единственный результат, можно с помощью
метода getSingleResult():
TypedQuery<Item> query = em.createQuery(
"select i from Item i where i.id = :id", Item.class
).setParameter("id", ITEM_ID);
Item item = query.getSingleResult();
410  Создание и выполнение запросов
Вызов getSingleResult() вернет экземпляр Item. Тот же прием можно использо-
вать для извлечения скаляров:
TypedQuery<String> query = em.createQuery(
"select i.name from Item i where i.id = :id", String.class
).setParameter("id", ITEM_ID);
String itemName = query.getSingleResult();
А теперь неприятные подробности: в отсутствие результатов метод getSingleResult()
возбудит исключение NoResultException. Следующий запрос пытается
отыскать
товар с несуществующим идентификатором:
try {
TypedQuery<Item> query = em.createQuery(
"select i from Item i where i.id = :id", Item.class
).setParameter("id", 1234l);
Item item = query.getSingleResult();
// ...
} catch (NoResultException ex) {
// ...
}
Возможно, вы ожидали получить null от этого безобидного запроса. Ситуация
тем неприятнее, что приходится обертывать этот участок кода блоком try/catch.
Фактически это вынуждает всегда обертывать вызовы getSingleResult(), посколь-
ку заранее неизвестно, сколько записей окажется в результате.
Если в результате база данных вернет несколько записей, getSingleResult() воз-
будит исключение NonUniqueResultException. Такое обычно происходит со следую-
щим видом запросов:
try {
Query query = em.createQuery(
"select i from Item i where name like '%a%'"
);
Item item = (Item) query.getSingleResult();
// ...
} catch (NonUniqueResultException ex) {
// ...
}
Извлечение всех результатов в память на практике используется чаще всего. Но
Hibernate поддерживает другие способы, которые могут вас заинтересовать, если
потребуется оптимизировать потребление памяти или особенности выполнения
запроса.
Выполнение запросов  411
Особенности Hibernate
14.3.3. Прокрутка с помощью курсоров базы данных
Обычный JDBC поддерживает наборы результатов с возможностью прокрутки.
Для этого используется курсор, открытый на стороне СУБД. Курсор указывает
на конкретную запись в результатах запроса, а приложение может перемещать его
вперед и назад. С помощью курсора можно даже перейти к конкретной записи.
Одна из причин, по которой может понадобиться перемещаться по результатам
запроса вместо загрузки их в память, – большое количество результатов, не уме-
щающееся в памяти. Обычно возвращаемый набор пытаются уменьшить путем
наложения дополнительных ограничений в запросе. Иногда это невозможно, на-
пример если требуется вывести все данные, но в несколько заходов. Мы покажем
такую процедуру пакетной обработки в разделе 20.1.
JPA не определяет порядка прокрутки результатов запроса с помощью курсоров
базы данных, поэтому вам понадобится интерфейс org.hibernate.ScrollableResults,
получаемый из нестандартного интерфейса org.hibernate.Query:
Session session = em.unwrap(Session.class);
org.hibernate.Query query = session.createQuery(  Открыть курсор
"select i from Item i order by i.id asc"
);
org.hibernate.ScrollableResults cursor =  Создать запрос
query.scroll(org.hibernate.ScrollMode.SCROLL_INSENSITIVE);
cursor.setRowNumber(2);  Перейти к третьей записи
Item item = (Item) cursor.get(0);  Получить значение столбца
cursor.close();  Закрыть курсор
Сначала нужно создать объект org.hibernate.Query  и открыть курсор .
Затем пропустить две первые записи в результатах, перейдя сразу к третьей ,
и получить значение первого «столбца» из этой записи . В JPQL нет столбцов,
поэтому здесь это соответствует первому элементу проекции: i в предложении select.
Другие примеры проекций вы найдете в следующей главе. Всегда закрывайте
курсор  до завершения транзакции в базе данных!
Как упоминалось ранее в этой главе, из обычного интерфейса javax.persistence.
Query, созданного при помощи CriteriaBuilder, с помощью метода unwrap()
можно получить Hibernate API для запросов. Запрос на основе интерфейса org.
hibernate.Criteria также поддерживает прокрутку с помощью курсоров; возвра-
щаемый курсор типа ScrollableResults работает аналогично.
Константы, определяемые перечислением ScrollMode из Hibernate API, соответ-
ствуют константам JDBC. Значение ScrollMode.SCROLL_INSENSITIVE в предыдущем
412  Создание и выполнение запросов
примере означает, что никакие изменения в базе данных не повлияют на курсор,
т. е. результат запроса не подвержен неповторимому или фантомному чтению. Два
оставшихся режима – SCROLL_SENSITIVE (курсор, чувствительный к изменениям)
и FORWARD_ONLY (курсор, допускающий перемещение только вперед). Курсор, чув-
ствительный к изменениям, отображает подтвержденные изменения в базе дан-
ных, пока он открыт; курсор, допускающий перемещение только вперед, не может
ссылаться на абсолютную позицию в результатах запроса. Обратите внимание,
что кэш контекста хранения в Hibernate по-прежнему обеспечивает повторимость
чтения экземпляров сущности даже при использовании курсора, чувствительного
к изменениям, поэтому использование такого курсора позволит видеть только из-
менившиеся скалярные значения, выбираемые с помощью проекций.
Имейте в виду, что не все драйверы JDBC поддерживают прокрутку с помощью
курсоров, хотя может казаться, что они работают. К примеру, драйверы MySQL
сразу загружают полный набор результатов в память; поэтому прокрутка проис-
ходит в памяти приложения. Чтобы по-настоящему извлекать запись за записью,
нужно установить размер извлекаемой выборки JDBC в значение Integer.MIN_
VALUE (как объяснялось в разделе 14.5.4) и задать режим ScrollMode.FORWARD_ONLY.
Исследуйте поведение и документацию для вашей СУБД и драйвера JDBC
перед использованием курсоров.
Важным ограничением прокрутки с помощью курсоров в базе данных является
невозможность объединения с динамическим извлечением, задаваемым предло-
жением join fetch в JPQL. Связанное извлечение работает с несколькими запи-
сями одновременно, поэтому вы не сможете извлекать данные запись за записью.
Hibernate возбудит исключение при вызове scroll() для запроса, использующего
динамическое извлечение.
Другой способ извлечения данных требует применения итератора (iteration).
Особенности Hibernate
14.3.4. Обход результатов с применением итератора
Предположим, что вам известно, что большинство экземпляров сущностей, извле-
каемых запросом, уже находится в памяти. Они могут находиться в контексте хра-
нения или в общем кэше второго уровня (см. раздел 20.2). В таком случае может
иметь смысл последовательный обход результатов запроса с помощью нестандарт-
ного org.hibernate.Query API:
Session session = em.unwrap(Session.class);
org.hibernate.Query query = session.createQuery(
"select i from Item i"
);
Iterator<Item> it = query.iterate(); // select ID from ITEM
while (it.hasNext()) {
Обращение к запросам по именам и их удаление из программного кода  413
Item next = it.next(); // select * from ITEM where ID = ?
// ...
}
Hibernate.close(it); Итератор должен быть закрыт вместе с экземпляром Session или вручную
При вызове query.iterate() Hibernate выполнит запрос, отправив SQL-выражение
SELECT в базу данных. Но Hibernate слегка модифицирует запрос, и вместо
всех столбцов из таблицы ITEM получит только значения идентификаторов/пер-
вичных ключей.
Затем, при каждом вызове next() интерфейса Iterator, будет выполняться до-
полнительный запрос SQL и загружаться оставшаяся часть записи из таблицы
ITEM. Очевидно, что это приведет к проблеме n + 1 выражений SELECT, если только
Hibernate не удастся избежать дополнительных запросов при вызове next(). А это
произойдет, только если Hibernate найдет данные экземпляра в кэше контекста
хранения или в кэше второго уровня.
Объект Iterator, возвращаемый методом iterate(), должен быть закрыт. Hibernate
закроет его автоматически, при закрытии EntityManager или Session. Если есть
риск в процедуре, использующей итераторы, превысить максимальное количество
открытых курсоров в базе данных, объект Iterator можно закрыть вручную, вы-
звав метод Hibernate.close(iterator).
Применение итераторов редко бывает оправдано, учитывая, что для эффектив-
ной работы процедуры из примера все аукционные товары должны находиться
в кэше. Как и в случае с курсором, вы не сможете использовать динамического
извлечения и предложения join fetch, потому что в таком случае Hibernate воз-
будит исключение.
До сих пор в каждом примере мы использовали строковые литералы Java с тек-
стом запроса. Это подходит только для небольших запросов, но когда в работу
включаются сложные, многострочные запросы, это становится неудобным. Вместо
этого можно дать каждому запросу имя и перенести его либо в аннотации, либо
в файлы XML.
14.4. Обращение к запросам по именам
и их удаление из программного кода
Удаление запросов из программного кода позволяет хранить все запросы, относя-
щиеся к конкретному хранимому классу (или набору классов), вместе с осталь-
ными метаданными класса. Другой подход заключается в перемещении всех за-
просов в файл XML. Такой подход предпочтительнее в больших приложениях;
сотни запросов легче поддерживать, когда они расположены в нескольких хорошо
известных местах, а не разбросаны по всему коду различных классов, обращаю-
щихся к базе данных. Обращение к таким запросам происходит по именам.
414  Создание и выполнение запросов
14.4.1. Вызов именованных запросов
Метод EntityManager#getNamedQuery() возвращает объект именованного запроса
Query:
Query query = em.createNamedQuery("findItems");
Также можно получить экземпляр типизированного именованного запроса
TypedQuery:
TypedQuery<Item> query = em.createNamedQuery("findItemById", Item.class);
Интерфейс запросов Hibernate также позволяет получать именованные за-
просы:
org.hibernate.Query query = session.getNamedQuery("findItems");
Именованные запросы являются глобальными, т. е. имя запроса является его
уникальным идентификатором в пределах единицы хранения или экземпляра
org.hibernate.SessionFactory. Коду приложения совершенно не важно, определе-
ны они в файлах XML или в аннотациях. Во время запуска Hibernate загрузит
именованные запросы JPQL из файлов XML и/или из аннотаций и проверит их
синтаксическую корректность. (Это может быть полезно на этапе разработки, но
в рабочей версии для уменьшения времени загрузки можно избавиться от этого
поведения, добавив в настройки единицы хранения параметр hibernate.query.
startup_check.)
Не важно, на каком языке создается именованный запрос. Это может быть
и JPQL, и SQL.
14.4.2. Хранение запросов в метаданных XML
Именованный запрос можно поместить в любой JPA-элемент <entity-mappings>
в файле метаданных orm.xml. В более крупных приложениях мы советуем хранить
именованные запросы отдельно, каждый в своем файле. Также можно использо-
вать один и тот же файл отображения XML для определения запросов и конкрет-
ных классов.
Элемент <named-query> определяет именованный запрос JPQL:
Файл: /model/src/main/resources/querying/ExternalizedQueries.xml
<entity-mappings
version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm
http://xmlns.jcp.org/xml/ns/persistence/orm_2_1.xsd">
<named-query name="findItems">
<query><![CDATA[
select i from Item i
]]></query>
Обращение к запросам по именам и их удаление из программного кода  415
</named-query>
</entity-mappings>
Текст запроса нужно обернуть инструкциями CDATA, чтобы ни один из его сим-
волов, который может быть случайно воспринят как XML (например, оператор
меньше), не помешал работе синтаксического анализатора XML. Для краткости
мы не будет использовать CDATA в большинстве примеров.
Именованные запросы не обязательно создавать с помощью JPQL. Это могут
быть обычные запросы SQL; программному коду на Java эти различия не инте-
ресны:
Файл: /model/src/main/resources/querying/ExternalizedQueries.xml
<named-native-query name="findItemsSQL"
result-class="org.jpwh.model.querying.Item">
<query>select * from ITEM</query>
</named-native-query>
Это полезно, если позднее потребуется оптимизировать запросы с помощью
тонкой настройки SQL. Это может также пригодиться при модификации унаследованного
приложения для работы с JPA/Hibernate, где код SQL может быть
изолирован от написанных вручную процедур JDBC. Используя именованные за-
просы, их можно легко переносить один за другим в файлы отображений.
Особенности Hibernate
В Hibernate есть собственное нестандартное средство для хранения запросов
в XML-файлах метаданных Hibernate:
Файл: /model/src/main/resources/querying/ExternalizedQueries.hbm.xml
<?xml version="1.0"?>
<hibernate-mapping xmlns="http://www.hibernate.org/xsd/orm/hbm">
<query name="findItemsOrderByAuctionEndHibernate">
select i from Item i order by i.auctionEnd asc
</query>
<sql-query name="findItemsSQLHibernate">
<return class="org.jpwh.model.querying.Item"/>
select * from ITEM order by NAME asc
</sql-query>
</hibernate-mapping>
Вы еще увидите примеры перемещения различных запросов SQL в отдельные
файлы в главе 17.
Если вам не по душе XML, запросы можно определять с помощью Java-аннотаций.
416  Создание и выполнение запросов
14.4.3. Хранение запросов в аннотациях
JPA поддерживает именованные запросы с помощью аннотаций @NamedQuery и @NamedNativeQuery.
Но эти аннотации должны находиться перед отображаемым классом.
Обратите внимание, что имя запроса также должно быть уникальным среди всех
классов; к имени запроса не добавляется префикс в виде имени пакета или класса:
@NamedQueries({
@NamedQuery(
name = "findItemById",
query = "select i from Item i where i.id = :id"
)
})
@Entity
public class Item {
// ...
}
Этот класс отмечен аннотацией @NamedQueries, содержащей массив аннотаций
@NamedQuery. Единственный запрос может быть объявлен без дополнительной ан-
нотации @NamedQueries. Для определения SQL-запросов вместо JPQL применяй-
те аннотацию @NamedNativeQuery. Для отображения результатов запроса SQL существует
множество вариантов, и мы покажем их позже в главе 17.
Особенности Hibernate
К сожалению, аннотации именованных запросов JPA обязательно должны нахо-
диться перед отображаемым классом. Их нельзя поместить в файл метаданных
package-info.java. Для этих целей в Hibernate есть собственные аннотации:
Файл: /model/src/main/java/org/jpwh/model/querying/package-info.java
@org.hibernate.annotations.NamedQueries({
@org.hibernate.annotations.NamedQuery(
name = "findItemsOrderByName",
query = "select i from Item i order by i.name asc"
)
})
package org.jpwh.model.querying;
Если для хранения именованных запросов вас не устраивают ни файлы XML,
ни аннотации, можно создавать их программно.
14.4.4. Программное создание именованных запросов
Объект Query можно «превратить» в именованный запрос с помощью метода EntityManagerFactory#
addNamedQuery():
Query findItemsQuery = em.createQuery("select i from Item i");
em.getEntityManagerFactory().addNamedQuery(
Подсказки для запросов  417
"savedFindItemsQuery", findItemsQuery
);
Query query =
em.createNamedQuery("savedFindItemsQuery");
Этот код регистрирует запрос в единице хранения – экземпляре EntityManager-
Factory – и обеспечивает повторное использование именованного запроса. Со-
храняемый объект Query не обязательно должен быть выражением JPQL; можно
сохранять запросы на основе критериев и обычные SQL-запросы. Обычно запрос
регистрируется только один раз, во время запуска приложения.
Использовать или не использовать именованные запросы – решать вам. Но во-
обще хранение строк запросов в коде приложения (если только они не размещены
в аннотациях) мы рассматриваем во вторую очередь; при любой возможности из-
бавляйтесь от строк запросов в программном коде. На практике самым универ-
сальным способом являются файлы XML.
Кроме того, для некоторых запросов может понадобиться применить дополни-
тельные настройки и подсказки.
14.5. Подсказки для запросов
В этом разделе мы представим несколько дополнительных параметров из стандар-
та JPA, а также несколько настроек, поддерживаемых Hibernate. Название раздела
подразумевает, что данная информация может понадобиться не сразу, поэтому вы
можете пропустить этот раздел и обратиться к нему позже, когда это потребуется.
Во всех примерах используется один и тот же запрос:
String queryString = "select i from Item i";
Фактически подсказку можно включить в запрос (Query) с помощью мето-
да setHint(). Остальные API для работы с запросами, такие как TypedQuery или
StoredProcedureQuery, также имеют этот метод. Если реализация механизма хране-
ния не поддерживает подсказки, она просто проигнорирует их.
Следующие подсказки, перечисленные в табл. 14.1, стандартизованы в JPA.
Таблица 14.1. Подсказки для запросов, стандартизованные в JPA
Имя Значение Описание
javax.persistence.query.
timeout
(Миллисекунды) Устанавливает предельное время выполнения
запроса. Доступна также в виде константы
org.hibernate.annotations.QueryHints.TIMEOUT_JPA
javax.persistence.cache.
retrieveMode
USE | BYPASS Указывает Hibernate, следует ли обращаться
к разделяемому кэшу второго уровня при из-
влечении данных, или данные должны читать-
ся только из результата запроса
javax.persistence.cache.
storeMode
USE | BYPASS | REFRESH Указывает Hibernate, следует ли сохранять
данные в кэше второго уровня при извлечении
их из результатов запроса
Последующий вызов
с тем же экземпляром
EntityManagerFactory
418  Создание и выполнение запросов
Особенности Hibernate
В Hibernate имеются собственные подсказки для запросов, доступные в виде кон-
стант в классе org.hibernate.annotations.QueryHints; см. табл. 14.2.
Таблица 14.2. Подсказки для запросов в Hibernate
Имя Значение Описание
org.hibernate.flushMode org.hibernate.FlushMode
(перечисление)
Определяет необходимость выталкивания
контекста хранения перед выполнением
запроса
org.hibernate.readOnly true | false Включает или отключает проверку состоя-
ния управляемых экземпляров сущностей,
возвращаемых запросом
org.hibernate.fetchSize (Количество
одновременно
извлекаемых записей
в JDBC)
Перед выполнением запроса вызывает
метод JDBC PreparedStatement#setFetchSize();
это оптимизационная подсказка
для драйвера базы данных
org.hibernate.comment (Комментарий для кода
SQL)
Комментарий, добавляемый перед кодом
SQL; используется для журналирования
(в том числе на стороне базы данных)
Кэш второго уровня (особенно для запросов) – сложная тема, потому мы от-
дельно посвятим ей раздел 20.2. Вы должны будете прочитать этот раздел, прежде
чем использовать разделяемый кэш: установка флага кэширования запроса в зна-
чение «включено» не окажет никакого эффекта.
Некоторые подсказки заслуживают более подробных пояснений.
14.5.1. Установка предельного времени выполнения
Время выполнения запроса можно контролировать, задав предельное время вы-
полнения:
Query query = em.createQuery(queryString)
.setHint("javax.persistence.query.timeout", 60000); 1 минута
В Hibernate этот метод обладает такой же семантикой и влиянием, как и setQueryTimeout()
JDBC-интерфейса Statement.
Обратите внимание, что драйвер JDBC не обязательно остановит запрос при
истечении времени ожидания. Спецификация JDBC гласит: «Как только у источ-
ника данных появится возможность обработать запрос на прерывание текущей
команды, пользователю будет возвращено исключение SQLException...» Это по-
зволяет достаточно широко интерпретировать момент, когда у источника данных
появится возможность прервать выполнение команды. Это может быть и после
ее завершения. Вы можете проверить это со своей СУБД и драйвером. Для этого
установите подсказку как глобальное свойство в файле persistence.xml, передайте
ее как свойство при создании экземпляра EntityManagerFactory или используйте ее
Подсказки для запросов  419
как параметр именованного запроса. Метод Query#setHint() переопределяет гло-
бальное свойство для конкретного запроса.
14.5.2. Установка режима выталкивания контекста хранения
Предположим, что вы модифицировали несколько хранимых экземпляров сущ-
ностей перед выполнением запроса. Например, поменяли значение свойства name
управляемых экземпляров Item. Эти изменения присутствуют только в памяти,
поэтому перед выполнением запроса Hibernate по умолчанию выталкивает кон-
текст хранения вместе со всеми изменениями в базу данных. Это гарантирует по-
лучение последних изменений запросом и отсутствие конфликта между результа-
тами запроса и экземплярами в памяти.
Иногда это очень непрактично, когда выполняется последовательность попере-
менных изменений и обращений к базе и каждый следующий запрос извлекает
другие наборы данных, отличные от предыдущих. Другими словами, может быть за-
ранее известно, что перед выполнением запроса не понадобится выталкивать изме-
нения в базу данных, поскольку конфликтующих результатов не будет. Также обра-
тите внимание, что контекст хранения обеспечивает повторимое чтение экземпляров
сущностей, поэтому проблему будут представлять лишь скалярные результаты.
Отключить выталкивание контекста хранения перед выполнением запроса
можно с помощью подсказки org.hibernate.flushMode для объекта Query со значе-
нием org.hibernate.FlushMode.COMMIT. К счастью, в JPA определен стандартный
метод setFlushMode() интерфейсов EntityManager и Query; значение FlushModeType.
COMMIT также стандартизовано. Поэтому, если требуется отключить выталкивание
контекста для конкретного запроса, используйте стандартный API:
Query query = em.createQuery(queryString)
.setFlushMode(FlushModeType.COMMIT);
В режиме COMMIT Hibernate не будет выталкивать контекст перед выполнением
запроса. Значение по умолчанию – AUTO.
14.5.3. Установка режима только для чтения
В разделе 10.2.8 мы рассказывали, как уменьшить потребление памяти и избежать
длинных циклов проверки состояния объектов. Используя подсказку, вы можете
сообщить Hibernate, что все экземпляры сущностей, возвращаемые запросом, сле-
дует рассматривать как доступные только для чтения (хотя и неотсоединенные):
Query query = em.createQuery(queryString)
.setHint(
org.hibernate.annotations.QueryHints.READ_ONLY,
true
);
Все экземпляры Item, возвращаемые этим запросом, находятся в хранимом со-
стоянии, но Hibernate не будет делать снимков состояния для автоматической
проверки объектов в контексте хранения. Hibernate не сохранит никаких изме-
420  Создание и выполнение запросов
нений, если только вы не отключите описываемого режима вызовом session.
setReadOnly(item, false).
14.5.4. Определение количества одновременно
извлекаемых записей
Количество одновременно извлекаемых записей – это подсказка для драйвера
базы данных:
Query query = em.createQuery(queryString)
.setHint(
org.hibernate.annotations.QueryHints.FETCH_SIZE,
50
);
Если эта возможность не поддерживается драйвером, данная подсказка может
никак не повлиять на производительность. Но если поддерживается, она может
ускорить взаимодействие между клиентом JDBC и базой данных: при обработке
результата запроса (ResultSet) клиентом (Hibernate) за одно обращение будет из-
влекаться сразу несколько записей.
14.5.5. Управление комментариями SQL
Во время оптимизации приложения часто приходится читать множество сообще-
ний из журнала выполнения SQL. Мы настоятельно рекомендуем добавить па-
раметр hibernate.use_sql_comments в файл конфигурации persistence.xml. В этом
случае Hibernate будет добавлять автоматически сформированные комментарии
к каждому выражению SQL, сохраняемому в журнале выполнения.
Добавить собственный комментарий к конкретному запросу (Query) можно
с помощью рекомендации:
Query query = em.createQuery(queryString)
.setHint(
org.hibernate.annotations.QueryHints.COMMENT,
"Custom SQL comment"
);
Все предыдущие подсказки были связаны с Hibernate или с JDBC. Но для боль-
шинства разработчиков и администраторов баз данных подсказки для запросов
представляют собой нечто совершенно иное. В SQL подсказка для запроса – это
инструкция в SQL-выражении для оптимизатора СУБД. Например, если разра-
ботчик или администратор решит, что план выполнения, выбранный оптимиза-
тором базы данных для конкретного выражения SQL, недостаточно быстрый, он
сможет использовать подсказку для выбора другого плана выполнения. Hibernate
и спецификация Java Persistence не поддерживают произвольных подсказок SQL
на уровне API; для этого придется использовать чистый SQL и создавать соб-
ственные выражения SQL; выполнять такие запросы вы сможете, используя под-
держиваемые API.
Подсказки для запросов  421
С другой стороны, в некоторых СУБД можно управлять оптимизатором с по-
мощью SQL-комментария, расположенного в начале выражения SQL. В таком
случае можно использовать такую же подсказку, как в предыдущем примере.
Вы видели, как можно установить подсказку напрямую в экземпляре Query.
Если вы храните запросы во внешних файлах и используете именованные запро-
сы, подсказки нужно определять либо в аннотациях, либо в XML.
14.5.6. Подсказки для именованных запросов
Все подсказки для запросов, которые устанавливались выше методом setHint(),
также можно указать в метаданных XML, в элементах <named-query> или <namednative-
query>:
<entity-mappings
version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence/orm
http://xmlns.jcp.org/xml/ns/persistence/orm_2_1.xsd">
<named-query name="findItems">
<query><![CDATA[
select i from Item i
]]></query>
<hint name="javax.persistence.query.timeout" value="60000"/>
<hint name="org.hibernate.comment" value="Custom SQL comment"/>
</named-query>
</entity-mappings>
Аналогично можно задавать подсказки в определениях именованных запросов
в аннотациях:
@NamedQueries({
@NamedQuery(
name = "findItemByName",
query = "select i from Item i where i.name like :name",
hints = {
@QueryHint(
name = org.hibernate.annotations.QueryHints.TIMEOUT_JPA,
value = "60000"),
@QueryHint(
name = org.hibernate.annotations.QueryHints.COMMENT,
value = "Custom SQL comment")
}
)
})
422  Создание и выполнение запросов
Особенности Hibernate
Подсказки для именованных запросов также можно задавать с помощью аннота-
ций Hibernate, в файле package-info.java:
@org.hibernate.annotations.NamedQueries({
@org.hibernate.annotations.NamedQuery(
name = "findItemBuyNowPriceGreaterThan",
query = "select i from Item i where i.buyNowPrice > :price",
timeout = 60,
comment = "Custom SQL comment"
)
})
package org.jpwh.model.querying;
Особенности Hibernate
И наконец, подсказки можно определять для запросов в XML-файлах конфигу-
рации Hibernate:
<?xml version="1.0"?>
<hibernate-mapping xmlns="http://www.hibernate.org/xsd/orm/hbm">
<query name="findItemsOrderByAuctionEndHibernateWithHints"
cache-mode="ignore"
comment="Custom SQL comment"
fetch-size="50"
read-only="true"
timeout="60">
select i from Item i order by i.auctionEnd asc
</query>
</hibernate-mapping>
14.6. Резюме
 Вы узнали, как создавать и выполнять запросы. Для создания и обработки ре-
зультатов запросов используются интерфейсы JPA. Вы также познакомились
с интерфейсами запросов Hibernate.
 Вы узнали, как готовить запросы к выполнению и защищаться от атак, связан-
ных с внедрением кода SQL. Вы познакомились со связанными и позицион-
ными параметрами, а также с постраничной обработкой больших результатов
запросов.
Резюме  423
 Чтобы не встраивать JPQL-запросов в исходные файлы на Java, можно при-
своить им имена и переместить во внешние файлы. Вы видели, как вызывать
именованные запросы, а также узнали способы их определения: в метаданных
XML, в аннотациях и программно.
 Мы рассказали о подсказках для запросов, которые можно передавать в Hibernate:
предельное время выполнения, доступ только на чтение, количество
одновременно извлекаемых записей и комментарии SQL. На примере JPQL
мы продемонстрировали, как задавать подсказки для запросов во внешних
файлах.
Глава 15
Языки запросов
В этой главе:
 запросы JPQL и запросы на основе критериев;
 эффективное извлечение данных с помощью соединений;
 запросы и подзапросы для получения отчетов.
Создание запросов – наиболее интересный этап в разработке приложений баз дан-
ных. Для создания сложного запроса может потребоваться много времени, и он
может оказать колоссальное влияние на производительность приложения. С дру-
гой стороны, писать запросы становится проще по мере приобретения опыта, и то,
что сначала казалось сложным, становится простым после изучения различных
языков запросов.
В этой главе рассматриваются языки запросов, доступные в JPA: JPQL и API
для запросов на основе критериев. Мы будем показывать примеры запросов, соз-
данных с использованием обоих языков/API и возвращающих одинаковые ре-
зультаты.
Главные нововведения в JPA 2
• Добавлена поддержка операторов CASE, NULLIF и COALESCE, обладающих такой же
семантикой, как и их аналоги в SQL.
• В выборке и ограничении запроса можно выполнить приведение к более специфичному
типу с помощью оператора TREAT.
• В ограничениях и проекциях запросов можно вызывать произвольные SQL-
функции.
• Используя новое ключевое слово ON, можно добавлять дополнительные условия
соединений.
• В предложениях FROM подзапросов можно использовать соединения.
Мы рассчитываем, что во время разработки приложения вы будете неоднократ-
но возвращаться к этой главе, используя ее в качестве руководства по синтаксису
запросов. Вследствие этого наше изложение будет кратким и сопровождаться не-
большими примерами кода для различных вариантов использования. Иногда мы
будем упрощать части приложения CaveatEmptor ради удобочитаемости. Напри-
Выборка  425
мер, в сравнениях мы будем обращаться не к экземплярам MonetaryAmount, а к эк-
земплярам BigDecimal.
Для начала разберемся с терминологией, относящейся к запросам. Для опреде-
ления источников данных используются выборки (selections), для отбора записей,
удовлетворяющих определенным критериям, – ограничения (restrictions), и для
перечисления выбираемых столбцов данных – проекции (projections). Вы увидите,
что данная глава организована в том же порядке.
В этой главе, говоря о запросах, мы, как правило, будем иметь в виду выражения
SELECT: операции, извлекающие информацию из базы данных. JPA также поддер-
живает выражения UPDATE, DELETE, выражение INSERT ... SELECT в JPQL, запросы на
основе критериев и различные реализации SQL, о которых мы расскажем в разде-
ле 20.1. Мы не будем повторять здесь этих массовых операций и сосредоточимся
только на выражениях SELECT. Для начала покажем несколько простых примеров
выборок.
15.1. Выборка
Во-первых, говоря выборка, мы не имеем в виду предложения запроса SELECT. Мы
также не имеем в виду самого выражения SELECT. Мы говорим о выборе реляцион-
ной переменной, или, говоря на языке SQL, о предложении FROM. Оно описывает
источник данных, или, проще говоря, таблицы, из которых будет производиться
выборка. Используя имена классов вместо таблиц, в JPQL можно написать сле-
дующее:
from Item
Следующий запрос (только предложение FROM) извлекает все экземпляры Item.
Для него Hibernate сгенерирует такой SQL-запрос:
select i.ID, i.NAME, ... from ITEM i
Эквивалентный запрос на основе критериев можно создать, передав имя сущ-
ности в метод from():
CriteriaQuery criteria = cb.createQuery(Item.class);
criteria.from(Item.class);
Особенности Hibernate
Hibernate может работать с запросами, содержащими лишь одно предложение
FROM или критерий. К сожалению, ни JPQL, ни запросы на основе критериев,
которые мы только что продемонстрировали, не являются переносимыми: они
несовместимы с JPA. Спецификация JPA требует, чтобы запрос JPQL содержал
предложение SELECT, а переносимые запросы на основе критериев вызывали ме-
тод select().
Это требует назначения псевдонимов и определения корневых источников за-
проса, что является нашей следующей темой.
426  Языки запросов
15.1.1. Назначение псевдонимов и определение
корневых источников запроса
Добавление предложения SELECT в запрос JPQL требует присваивания псевдонима
(alias) классу в предложении FROM, чтобы можно было ссылаться на него в других
предложениях запроса.