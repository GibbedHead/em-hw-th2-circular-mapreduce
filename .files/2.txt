1.1. Что такое долговременное хранение?
Почти все приложения используют данные, хранящиеся долговременно (persistent
data). Долговременное хранение является одним из фундаментальных поня-
тий в разработке приложений. Если бы информационная система не сохраняла
данных во время отключения, от нее было бы мало толку. Долговременное хранение
объектов (object persistence) означает, что отдельные объекты могут существовать
дольше, чем процесс приложения; они могут помещаться в хранилище данных
и восстанавливаться впоследствии. Когда мы говорим о долговременном хране-
нии в Java, мы обычно имеем в виду отображение и сохранение отдельных объек-
тов в базе данных SQL. Мы начнем с краткого обзора технологии и ее применения
в Java. Вооруженные этими знаниями, мы продолжим обсуждение технологии
долговременного хранения и ее реализации в объектно-ориентированных прило-
жениях.
28  Основы объектно-реляционного отображения
1.1.1. Реляционные базы данных
Возможно, вы, как и большинство разработчиков программного обеспечения, ра-
ботали с SQL и реляционными базами данных; многие из нас сталкиваются с по-
добными системами ежедневно. Системы управления реляционными базами дан-
ных имеют прикладной программный интерфейс, основанный на SQL, поэтому
мы называем современные продукты, относящиеся к реляционным базам данных,
системами управления базами данных SQL (СУБД), или, говоря о конкретной си-
стеме, базами данных SQL.
Реляционные технологии хорошо известны, и один этот факт является доста-
точным аргументом в их пользу для многих организаций. Но упомянуть лишь об
этом означало бы выразить меньшее почтение, чем следует. Сила реляционных
баз данных – в невероятно гибком и устойчивом подходе к управлению данными.
Благодаря тщательно исследованным теоретическим обоснованиям реляционной
модели, помимо других желаемых качеств, реляционные базы данных способны
обеспечивать и защищать целостность хранимых данных. Вам, возможно, извест-
на работа Э. Кодда (E. F. Codd), вышедшая четыре десятилетия назад, – введение
в реляционную модель «A Relational Model of Data for Large Shared Data Banks»
(Codd, 1970). Более поздней работой, которую можно порекомендовать для про-
чтения, посвященной SQL, является труд К. Дейта (C. J. Date) «SQL and Relational
Theory»1 (Date, 2009).
Реляционные СУБД могут использоваться не только с Java, так же как и базы
данных SQL могут использоваться не только конкретным приложением. Этот
важный принцип носит название независимости данных (data independence). Дру-
гими словами, мы бы хотели как можно ярче подчеркнуть этот факт: данные су-
ществуют дольше, чем любое приложение. Реляционные технологии дают возмож-
ность совместного использования данных разными приложениями или разными
частями одной общей системы (например, приложением ввода данных и прило-
жением отчетов). Реляционные технологии являются общим знаменателем для
различных систем и технологических платформ. В результате реляционная мо-
дель обычно становится общим основанием для представления бизнес-сущностей
в масштабах предприятия.
Прежде чем переходить к подробному обсуждению практических сторон баз
данных SQL, следует отметить важный момент: система управления базами дан-
ных, которая позиционируется на рынке как реляционная, но которая предостав-
ляет только интерфейс SQL, не является в действительности реляционной и во
многом даже близко не соответствует изначальной идее. Естественно, это приве-
ло к путанице. Профессиональные разработчики SQL критикуют реляционную
модель за ограничения в языке SQL, а эксперты в управлении реляционными
данными критикуют стандарт SQL как слабое воплощение реляционной модели
и идеалов. Разработчики приложений находятся где-то посередине, решая труд-
1 Дейт К. Дж. SQL и реляционная теория. Как грамотно писать код на SQL. ISBN: 978-5-
93286-173-8. Символ-Плюс, 2010. – Прим. ред.
Что такое долговременное хранение?  29
ную задачу по выпуску чего-то работоспособного. Далее в книге мы будем под-
черкивать важные и значимые стороны этой проблемы, но в целом мы сосредото-
чимся на решении практических задач. Если вам хочется узнать больше, мы очень
рекомендуем «Practical Issues in Database Management: A Reference for the Thinking
Practicioner» (Pascal, 2000) Фабиана Паскаля (Fabian Pascal) и «Introduction to
Database Systems» (Date, 2003) Кристофера Дейта (Chris Date). В этих книгах вы
ознакомитесь с теорией, понятиями и идеалами (реляционных) систем управле-
ния базами данных. Последняя книга является прекрасным справочником (очень
объемным) по всем вопросам, касающимся баз данных и управления данными.
1.1.2. Разбираемся с SQL
Для эффективного использования Hibernate необходимо глубокое понимание
реляционной модели и SQL. Вы должны понимать реляционную модель и такие
темы, как нормализация для обеспечения целостности данных, а также использо-
вать знание SQL для оптимизации производительности приложения с Hibernate.
Hibernate автоматизирует решение множества повторяющихся задач, но ваше
знание технологии долговременного хранения должно распространяться дальше
Hibernate, если хотите воспользоваться всеми преимуществами современных баз
данных SQL. Ознакомьтесь со списком литературы в конце книги для более глу-
бокого погружения в тему.
Возможно, вы использовали SQL в течение многих лет и знакомы с основными
операциями и инструкциями. Тем не менее, опираясь на собственный опыт, мы
можем утверждать, что код SQL иногда трудно запомнить, а некоторые термины
имеют разное значение.
Рассмотрим некоторые термины SQL, используемые в книге. Язык SQL широ-
ко используется как язык описания данных (Data Definition Language, DDL) при
создании (create), изменении (alter) или удалении (drop) таких артефактов, как
таблицы и ограничения в каталоге СУБД. При наличии готовой схемы SQL ис-
пользуется как язык управления данными (Data Manipulation Language, DML) для
вставки (insertion), изменения (update) и удаления (delete) этих данных. Для из-
влечения данных используются запросы с ограничениями (restrictions), проекция-
ми (projections) и декартовыми произведениями (Cartesian products). Для лучшего
представления с помощью SQL данные можно соединять (join), агрегировать (aggregate)
и группировать (group) по необходимости. Можно даже помещать одни
инструкции SQL внутрь других – эта техника носит название вложенных запросов
(subselects). Когда меняются бизнес-требования, приходится менять схему базы
данных при помощи инструкций DDL уже после того, как были сохранены дан-
ные; это называется эволюцией схемы (schema evolution).
Тем, кто давно использует SQL и желает узнать больше об оптимизации и о том,
как выполняются инструкции SQL, можно порекомендовать отличную книгу
«SQL Tuning» (Tow, 2003) Дэна Тоу (Dan Tow). Книга «SQL Antipatterns: Avoiding
the Pitfalls of Database Programming» (Karwin, 2010) является хорошим ресурсом
для изучения практического применения SQL на примерах некорректного ис-
пользования SQL.
30  Основы объектно-реляционного отображения
Несмотря на то что база данных SQL является одной из частей ORM, другая
ее часть состоит из данных Java-приложения, которые необходимо хранить и из-
влекать из базы данных.
1.1.3. Использование SQL в Java
При работе с базой данных SQL в Java-приложении инструкции SQL передаются
в базу данных через прикладной интерфейс Java Database Connectivity (JDBC).
Независимо от того, как написан код SQL – вручную, включен в Java-код или
создан Java-кодом «на лету», для привязки аргументов к параметрам запроса,
выполнения запроса, итераций по результатам запроса, извлечения значений из
результирующей выборки и т. д. будет использован JDBC API. Все это – низко-
уровневые задачи доступа к данным; как разработчики приложений мы больше
заинтересованы в решении предметной задачи, требующей доступа к данным.
Что бы мы действительно хотели писать – так это код, сохраняющий и возвра-
щающий экземпляры классов, который избавил бы нас от этой низкоуровневой
рутины.
Из-за того, что задачи доступа к данным обычно такие нудные, мы спрашива-
ем – действительно ли реляционная модель данных и (особенно) SQL являются
правильным решением для долговременного хранения данных в объектно-ориен-
тированных приложениях? Мы отвечаем на этот вопрос однозначно – да! Есть
много причин, почему базы данных SQL доминируют в индустрии ПО, – реляци-
онные системы управления базами данных являются единственной испытанной
универсальной технологией, и они почти всегда требуются в Java-проектах.
Обратите внимание, что мы не утверждаем, будто реляционная технология всег-
да является лучшим решением. Существует множество требований к управлению
данными, вынуждающих использовать иные подходы. Например, распределенные
системы в масштабах Интернета (поисковые системы, сети распространения кон-
тента, пиринговые сети обмена информацией, обмен мгновенными сообщениями)
сталкиваются с исключительно большим количеством транзакций. В большин-
стве из них не требуется, чтобы после изменения данных все процессы видели
одно и то же обновленное состояние (сильная транзакционная согласованность).
Пользователям может быть достаточно слабой согласованности, когда после из-
менения может возникнуть окно несогласованности, прежде чем все процессы
получат обновленные данные. Многие научные приложения работают с огромны-
ми, но специализированными наборами данных. Подобные системы с их уникаль-
ными проблемами требуют таких же уникальных и, как правило, нестандартных
решений проблемы хранения данных. Универсальные инструменты управления
данными, такие как базы данных SQL (поддерживающие транзакции, которые со-
ответствуют требованиям ACID1), JDBC и Hibernate, здесь играют второстепен-
ную роль.
1 https://ru.wikipedia.org/wiki/ACID/. – Прим. ред.
Что такое долговременное хранение?  31
Реляционные системы в масштабах Интернета
Чтобы понять, почему реляционные системы и связанные с ними гарантии целост-
ности плохо масштабируются, мы рекомендуем прежде познакомиться с теоремой
CAP, согласно которой распределенная система не может быть согласованной, до-
ступной и устойчивой к отказам разделов одновременно1.
Система может гарантировать актуальность данных на все узлах одновременно
и надежную обработку всех запросов чтения и записи. Но когда часть системы
может оказаться недоступной из-за проблем с узлом, сетью или дата-центром,
следует отказаться от сильной согласованности (линеаризуемости) или 100%-ной
доступности. На практике это означает, что необходима стратегия, которая бы от-
слеживала отказы разделов и до определенного уровня восстанавливала либо со-
гласованность, либо доступность (например, сделав часть системы недоступной
для синхронизации в фоновом режиме). Обычно необходимость в сильной согла-
сованности зависит от данных, пользователя или операции.
Примерами легко масштабируемых реляционных СУБД могут служить VoltDB
(https://www.voltdb.com/) и NuoDB (https://www.nuodb.com/). Кроме того, в весьма
интересной статье «F1 – The-Fault-TolerantDistributedRDBMSSupportingGoogleAd’s
Business» (Shute, 2012) вы узнаете, как Google масштабирует свою самую главную
базу данных для рекламного бизнеса и почему она является реляционной/SQL.
В этой книге мы будем рассматривать проблемы хранения данных и их со-
вместного использования в контексте объектно-ориентированных приложений,
основанных на модели предметной области (domain model). Вместо работы не-
посредственно со строками и колонками в экземплярах java.sql.ResultSet биз-
нес-логика приложения взаимодействует с объектно-ориентированной моделью
предметной области конкретного приложения. Если в схеме базы данных SQL для
онлайн-аукциона имеются таблицы ITEM (лот) и BID (предложение цены), в Java-
приложении могут быть определены классы Item и Bid. Вместо того чтобы читать
и записывать значения конкретных строк и колонок с помощью класса ResultSet,
приложение загружает и сохраняет экземпляры классов Item и Bid.
То есть в процессе выполнения приложение взаимодействует с экземплярами
данных классов. Каждый экземпляр Bid ссылается на экземпляр Item аукциона,
а каждый экземпляр Item может иметь множество ссылок на экземпляры Bid. Биз-
нес-логика выполняется не на стороне базы данных (в виде хранимой процедуры);
она реализована на Java и выполняется на уровне приложения. Это позволяет ей
использовать такие сложные механизмы ООП, как наследования и полиморфизм.
К примеру, мы могли бы использовать такие известные шаблоны проектирования,
как «Стратегия» (Strategy), «Посредник» (Mediator) и «Компоновщик» (Composite),
описание которых можно найти в «Design Patterns: Elementsof Reusable Object-
Oriented Software» [Gamma, 1995]2, опирающиеся на полиморфные вызовы методов.
1 https://ru.wikipedia.org/wiki/Теорема_CAP. – Прим. ред.
2 Гамма Э. Приемы объектно-ориентированного проектирования. ISBN: 978-5-496-00389-6.
Питер, 2013. – Прим. ред.
32  Основы объектно-реляционного отображения
Но есть нюанс: не все Java-приложения спроектированы подобным образом, да
и не всегда это оправдано. Простые приложения прекрасно обойдутся без пред-
метной модели. Используйте JDBC ResultSet, если это все, что вам нужно. Вызы-
вайте хранимые процедуры и читайте возвращаемые ими наборы данных. Многим
приложениям требуется выполнять процедуры, модифицирующие большие объ-
емы данных. Вы можете реализовать отчеты, используя обычные запросы SQL,
и выдавать результат прямо на экран. SQL и JDBC API отлично подходят для ра-
боты с данными в табличном представлении, а JDBC RowSet сильно упрощает опе-
рации CRUD. Работа с таким представлением хранимых данных довольно проста
и понятна.
Но в случае, когда приложение имеет нетривиальную бизнес-логику, использо-
вание модели предметной области поможет сильно улучшить повторное исполь-
зование кода и простоту сопровождения.
На протяжении десятилетий разработчики говорят о несоответствии парадигм.
Это несоответствие объясняет, почему многие корпоративные проекты тратят так
много усилий на проблемы, касающиеся хранения информации. Парадигмы, о ко-
торых идет речь, – это объектное и реляционное моделирование, а на практике –
ООП и SQL.
Осознав это, вы начнете видеть проблемы – некоторые хорошо изученные, а не-
которые не очень, – которые приложение должно решать, объединяя оба подхода:
объектно-ориентированное моделирование предметной области и реляционное
моделирование хранимых данных. Давайте взглянем поближе на это так называе-
мое несоответствие парадигм.
1.2. Несоответствие парадигм
Несоответствие объектной и реляционной парадигм можно разделить на несколь-
ко частей, каждую из которых мы рассмотрим отдельно. Начнем с примера, кото-
рый не имеет проблемы. По мере того как мы будем его развивать, вы увидите, как
начнет проявляться несоответствие.
Предположим, вам необходимо разработать приложение для электронной ком-
мерции. Приложению нужен класс, представляющий информацию о пользовате-
ле системы, и еще один класс, представляющий информацию о платежных рекви-
зитах пользователя, как показано на рис. 1.1.
User 1..* BillingDetails
Рис. 1.1  Простая UML-диаграмма
сущностей User и Billing Details
Как видно на диаграмме, у пользователя (класс User) может быть несколько
платежных реквизитов (класс BillingDetails). Вы можете осуществлять нави-
гацию по связи между классами в обоих направлениях; это означает, что можно
Несоответствие парадигм  33
выполнять итерации по коллекциям или вызывать методы для получения «дру-
гой» стороны отношения. Классы, выражающие это отношение, могут быть очень
простыми:
public class User {
String username;
String address;
Set billingDetails;
// Методы доступа (чтения/записи), бизнес-методы и т. д.
}
public class BillingDetails {
String account;
String bankname;
User user;
// Методы доступа (чтения/записи), бизнес-методы и т. д.
}
Отметим, что нас интересуют только состояния сущностей, поэтому мы опустили
реализацию методов доступа и бизнес-методов, таких как getUsername() или
billAuction().
В данном случае не составит труда придумать схему SQL:
create table USERS (
USERNAME varchar(15) not null primary key,
ADDRESS varchar(255) not null
);
create table BILLINGDETAILS (
ACCOUNT varchar(15) not null primary key,
BANKNAME varchar(255) not null,
USERNAME varchar(15) not null,
foreign key (USERNAME) references USERS
);
Столбец USERNAME в таблице BILLINGDETAILS, являющийся внешним ключом,
представляет отношение между двумя сущностями. В такой простой предметной
модели трудно различить несоответствие объектной и реляционной парадигм; мы
легко сможем написать JDBC-код для вставки, изменения и удаления информа-
ции о пользователях и платежных реквизитах.
Теперь рассмотрим более реалистичный пример. Несоответствие парадигм про-
явится после того, как в приложении будет больше сущностей и их отношений.
1.2.1. Проблема детализации
Наиболее очевидная проблема текущей реализации в том, что адрес представлен
простым значением типа String. В большинстве систем необходимо раздельно
хранить улицу, город, штат, страну и почтовый индекс. Конечно, все эти свойства
34  Основы объектно-реляционного отображения
можно добавить прямо в класс User, но, поскольку велика вероятность, что и дру-
гие классы системы будут использовать информацию об адресах, имеет смысл соз-
дать класс Address. На рис. 1.2 показана обновленная модель:
Address User 1..* BillingDetails

Рис. 1.2  У пользователя (User) есть адрес (Address)
Следует ли создать таблицу ADDRESS? Не обязательно; обычно информация об
адресе хранится в таблице USERS, но в отдельных столбцах. Такое решение более
производительно, так как не требует выполнять соединения таблиц, чтобы полу-
чить пользователя и адрес одним запросом. Самым элегантным решением было
бы создание нового типа данных SQL, представляющего адрес, и добавление од-
ного столбца этого типа в таблицу USERS вместо нескольких отдельных колонок.
Теперь имеется выбор между добавлением нескольких столбцов или одно-
го (нового типа данных SQL). Это, очевидно, является проблемой детализации
(problem of granularity). В широком смысле детализация относится к размерам
типов, с которыми вы работаете.
Вернемся к нашему примеру. Добавление нового типа данных в каталог базы
данных для хранения экземпляров Java-класса Address в одном столбце выглядит
лучшим решением:
create table USERS (
USERNAME varchar(15) not null primary key,
ADDRESS address not null
);
Новый тип (класс) Address в Java и ADDRESS, новый тип данных SQL, должны
обеспечить
взаимодействие. Но вы обнаружите множество проблем, если про-
верите поддержку типов, определяемых пользователем (User-defined Data Types,
UDT), в современных системах управления базами данных SQL.
Поддержка UDT – это одно из так называемых объектно-реляционных рас-
ширений традиционного SQL. Этот термин сбивает с толку, так как означает, что
СУБД имеет (или должна поддерживать) сложную систему типов – то, что вы
принимаете за данность, если кто-то продает вам систему, способную управлять
данными в реляционном стиле. К сожалению, поддержка UDT является малопо-
нятной особенностью многих СУБД SQL и, определенно, не является переноси-
мой между различными продуктами. Более того, стандарт SQL слабо поддержива-
ет типы, определяемые пользователем.
Это ограничение не является недостатком реляционной модели данных. Про-
вал в стандартизации такой важной функциональности вы можете рассматри-
вать как последствие войн между производителями объектно-реляционных баз
данных в середине 90-х. Сегодня большинство инженеров искренне считает, что
SQL-системы обладают ограниченной системой типов. Даже при наличии слож-
Несоответствие парадигм  35
ной системы UDT в вашей СУБД вам наверняка придется объявлять новые типы
в Java, а затем дублировать их в SQL. Попытки поиска лучшей альтернативы в сре-
де Java, как, например, SQLJ, к сожалению, не увенчались успехом. СУБД редко
поддерживают развертывание и выполнение Java-классов непосредственно в базе
данных, но даже если такая поддержка доступна, она обычно ограничена базовой
функциональностью и сложна для повседневного применения.
По этой и многим другим причинам использование UDT или типов Java в базах
данных SQL еще не стало общепринятой практикой в отрасли; маловероятно, что
вы столкнетесь со старой схемой, в которой широко применяются UDT. Следо-
вательно, вы не сможете, и не будете, хранить экземпляры нового класса Address
в одном столбце, имеющем тот же тип данных, что и в Java.
Более практичное решение этой проблемы: создать несколько столбцов предо-
пределенных типов (логического, числового, строкового), встроенных произво-
дителем. Согласно ему, таблицу USERS можно определить следующим образом:
create table USERS (
USERNAME varchar(15) not null primary key,
ADDRESS_STREET varchar(255) not null,
ADDRESS_ZIPCODE varchar(5) not null,
ADDRESS_CITY varchar(255) not null
);
Классы предметной модели в Java имеют различную степень детализации: от
более крупных классов сущностей, как User, до более детализированных классов,
как Address, и простого SwissZipCode, расширяющего AbstractNumericZipCode (в за-
висимости от требуемого уровня абстракции). В базе данных SQL, напротив, до-
ступны лишь два уровня детализации: реляционные типы, созданные вами, как,
например, USERS и BILLINGDETAILS, и встроенные, такие как VARCHAR, BIGINT или TIMESTAMP.
Большинство механизмов хранения не замечает этого несоответствия и в итоге
навязывает менее гибкое представление SQL-систем объектно-ориентированным
системам, делая их более плоскими.
Оказывается, что проблему детализации легко решить. Мы бы даже не стали
ее обсуждать, если бы не тот факт, что она проявляется во многих существующих
системах. Мы опишем решение этой проблемы в разделе 4.1.
Более сложная и интересная проблема возникает, когда мы имеем дело с моде-
лями предметной области, основанными на наследовании – принципе объектно-
ориентированного проектирования, который вы могли бы использовать, чтобы
выставлять счета пользователям вашего приложения для электронной коммерции
новыми и интересными способами.
1.2.2. Проблема подтипов
Наследование типов в Java реализуется при помощи суперклассов и подклассов.
Чтобы продемонстрировать, почему это может представлять проблему несоответ-
ствия, давайте расширим возможности приложения, чтобы можно было произ-
36  Основы объектно-реляционного отображения
водить оплату не только с банковского счета, но и при помощи кредитных или
дебетовых карт. Наиболее естественно это изменение в модели можно отразить
в виде нескольких конкретных подклассов, наследующих суперкласс BillingDetails:
CreditCard, BankAccount и т. д. Каждый из этих подклассов содержит немного
отличающиеся данные (и определяет совершенно разную функциональность для
работы с этими данными). Диаграмма классов UML на рис. 1.3 демонстрирует эту
модель.
User 1..* BillingDetails
CreditCard BankAccount
Рис. 1.3  Применение наследования
для различных способов оплаты
Какие изменения требуется внести для поддержки обновленной структуры
Java-классов? Требуется ли создавать таблицу CREDITCARD, расширяющую BILLINGDETAILS?
Системы баз данных SQL, как правило, не поддерживают табличного
наследования (или даже наследования типов), а используют нестандартный син-
таксис и могут подвергать нас проблемам целостности данных (ограничивая под-
держку целостности для представлений, допускающих обновление).
Наследование – не единственная трудность. Добавив наследование, мы также
добавили в модель полиморфизм.
У класса User есть ассоциация c суперклассом BillingDetails – это полиморф-
ная ассоциация. Во время выполнения экземпляр User может ссылаться на экземпляр
любого из подклассов BillingDetails. Также хотелось бы иметь возможность
создания полиморфных запросов, ссылающихся на класс BillingDetails, и чтобы
запрос возвращал экземпляры подклассов.
В базах данных SQL нет способа (по крайней мере, стандартного) представле-
ния полиморфной ассоциации. Ограничение внешнего ключа ссылается только
на одну таблицу; нет простого способа определить внешний ключ, ссылающийся
на несколько таблиц. Для обеспечения такого типа целостности придется создать
процедурное ограничение.
Из-за несоответствия подтипов производные структуры должны сохраняться
в базе данных SQL, не предоставляющей механизмов наследования. В главе 6 мы об-
судим, как ORM-системы, такие как Hibernate, решают проблему хранения иерархии
классов в таблице (в таблицах) базы данных SQL и как может быть реализовано
полиморфное поведение. К счастью, данная проблема хорошо изучена, и большин-
ство решений поддерживает практически одинаковую функциональность.
Следующим аспектом объектно-реляционного несоответствия является проблема
идентичности объектов. Вы, возможно, заметили, что в нашем примере мы
Несоответствие парадигм  37
сделали столбец USERNAME таблицы USERS первичным ключом. Был ли это хороший
выбор? Как работать с идентичными объектами в Java?
1.2.3. Проблема идентичности
Проблема идентичности, на первый взгляд, кажется неочевидной, но вы часто
будете сталкиваться с ней в растущих и развивающихся системах электронной
коммерции, например когда требуется проверить идентичность двух экземпля-
ров. Существуют три подхода к решению этой проблемы: два – на стороне Java
и один – в базе данных SQL. Как и следовало ожидать, нужно приложить усилия,
чтобы они работали вместе.
Java определяет два различных понятия тождественности:
 идентичность экземпляров (грубо говоря, совпадение адресов в памяти;
проверяется как a == b);
 равенство экземпляров, определяемое методом equals() (также называется
равенством по значению).
С другой стороны, идентичность записей в базе данных определяется сравнени-
ем значений первичного ключа. Как будет показано в разделе 10.1.2, ни equals(),
ни оператор == не всегда эквивалентны сравнению значений первичного ключа.
Нередка ситуация, когда несколько неидентичных Java-объектов представляют
одну и ту же запись в базе данных, например в параллельно выполняющихся по-
токах приложения. Кроме того, корректная реализация метода equals() для хра-
нимого класса требует учета некоторых тонких нюансов и понимания, когда их
стоит учитывать.
Воспользуемся нашим примером, чтобы продемонстрировать еще одну пробле-
му, связанную с идентичностью в базе данных. Столбец USERNAME в таблице USERS
играет роль первичного ключа. К сожалению, такая реализация усложняет смену
имени пользователя – требуется обновить не только запись в таблице USERS, но
и все значения внешнего ключа во многих строках таблицы BILLINGDETAILS. Да-
лее в этой книге для решения данной задачи мы предложим использовать сур-
рогатный ключ, когда не удается найти хороший естественный ключ. Также мы
обсудим, что является хорошим первичным ключом. Столбец суррогатного клю-
ча – это столбец первичного ключа, не имеющий значения для пользователя при-
ложения, другими словами, это ключ, скрытый от пользователя приложения. Его
единственная цель – идентифицировать данные внутри приложения.
К примеру, можно было бы поменять определения таблиц следующим образом:
create table USERS (
ID bigint not null primary key,
USERNAME varchar(15) not null unique,
...
);
create table BILLINGDETAILS (
ID bigint not null primary key,
ACCOUNT varchar(15) not null,
38  Основы объектно-реляционного отображения
BANKNAME varchar(255) not null,
USER_ID bigint not null,
foreign key (USER_ID) references USERS
);
Столбцы ID содержат сгенерированные системой значения. Раз эти столбцы
были созданы исключительно ради самой модели данных, то каким образом (и
нужно ли вообще) представлять их в модели Java? Мы обсудим этот вопрос в раз-
деле 4.2 и найдем решение в ORM.
В контексте долговременного хранения данных идентичность тесно связана
с тем, как система осуществляет кэширование и поддерживает транзакции. Раз-
личные решения используют разные стратегии, и это может сбивать с толку. Мы
рассмотрим эти интересные темы и то, как они взаимосвязаны, в разделе 10.1.
На данном этапе прототип приложения для электронной коммерции уже вы-
явил проблему несоответствия парадигм на примере детализации, подтипов
и идентичности. Мы почти готовы двинуться дальше к другим частям приложе-
ния, но сначала обсудим важное понятие ассоциаций: как отображать и использо-
вать отношения между сущностями. Является ли ограничение внешнего ключа
в базе данных единственным, что для этого необходимо?
1.2.4. Проблемы, связанные с ассоциациями
Ассоциации в предметной модели представляют отношения между сущностями.
Все классы – User, Address и BillingDetails – связаны между собой, но, в отличие
от Address, класс BillingDetails стоит особняком. Экземпляры класса BillingDetails
хранятся в отдельной таблице. Отображение ассоциаций и управление ассо-
циациями между сущностями являются ключевыми понятиями любого решения
долговременного хранения объектов.
В объектно-ориентированных языках ассоциации представлены объектными
ссылками; но в реляционном мире столбец внешнего ключа будет представлять ас-
социацию при помощи дублирования значений этого ключа. Ограничение – это
правило, гарантирующее целостность ассоциации. Между этими двумя способами
существенные различия.
Объектные ссылки по своей природе обладают направленностью; ассоциация
идет от одного экземпляра к другому. Они – указатели. Если ассоциация должна
быть двунаправленной, следует определить ее дважды, по одному разу в каждом
из ассоциированных классов. Вы это уже видели в классах предметной модели:
public class User {
Set billingDetails;
}
public class BillingDetails {
User user;
}
Навигация в конкретном направлении не имеет смысла для реляционной моде-
ли данных, потому что можно создавать произвольные ассоциации при помощи
Несоответствие парадигм  39
операций соединения и проекции. Основная сложность в том, чтобы отобразить
совершенно открытую модель данных, которая не зависит от приложения, работающего
с данными, на зависимую от приложения навигационную модель – огра-
ниченное представление ассоциаций для конкретного приложения.
Ассоциации в Java могут иметь вид многие ко многим. Классы, например, могли
быть определены следующим образом:
public class User {
Set billingDetails;
}
public class BillingDetails {
Set users;
}
Но объявление внешнего ключа в таблице BILLINGDETAILS является ассоциацией
многие к одному: каждый банковский счет привязан к конкретному пользователю.
Каждый пользователь может иметь несколько банковских счетов.
Чтобы выразить ассоциацию многие ко многим в базе данных SQL, придется
создать дополнительную таблицу, также называемую таблицей ссылок (link table).
В большинстве случаев эта таблица отсутствует в предметной модели. Если для
данного примера представить отношение между пользователем и платежными
реквизитами как многие ко многим, таблицу ссылок можно определить следующим
образом:
create table USER_BILLINGDETAILS (
USER_ID bigint,
BILLINGDETAILS_ID bigint,
primary key (USER_ID, BILLINGDETAILS_ID),
foreign key (USER_ID) references USERS,
foreign key (BILLINGDETAILS_ID) references BILLINGDETAILS
);
Вам больше не нужен столбец внешнего ключа USER_ID и ограничение в таблице
BILLINGDETAILS; связью между двумя сущностями теперь управляет эта дополни-
тельная таблица. Мы обсудим ассоциации и отображение коллекций более подробно
в главе 7.
Итак, проблемы, рассмотренные нами, считаются структурными: их можно за-
метить, рассматривая статическую картину системы. Возможно, наиболее труд-
ной проблемой хранения объектов является динамическая проблема: порядок до-
ступа к данным во время выполнения.
1.2.5. Проблемы навигации по данным
Существует фундаментальное различие между способами доступа к данным
в Java и реляционной базе данных. Чтобы получить доступ к платежной информа-
ции пользователя в Java, вы вызываете someUser.getBillingDetails().iterator().
next() или что-то подобное. Это наиболее естественный способ доступа к объект40
 Основы объектно-реляционного отображения
но-ориентированным данным, который обычно называется обходом графа объек-
тов. Вы перемещаетесь от одного экземпляра к другому и даже перебираете кол-
лекции, следуя за подготовленными указателями между классами. К сожалению,
это не самый лучший способ получения информации из базы данных SQL.
Для улучшения производительности доступа к данным важно уменьшить коли-
чество запросов к базе данных. Самый очевидный способ достичь этого – умень-
шить количество SQL-запросов. (Безусловно, за этим могут последовать другие,
более сложные методы, такие как повсеместное кэширование.)
Таким образом, эффективный доступ к реляционным данным с помощью SQL
обычно требует соединения интересующих нас таблиц. Количество соединяемых
таблиц при извлечении данных определяет глубину графа объектов, доступных
в памяти. Например, чтобы извлечь пользователя без его платежной информации,
можно написать простой запрос:
select * from USERS u where u.ID = 123
С другой стороны, если требуется извлечь пользователя, а затем последователь-
но получить доступ к каждому связанному экземпляру BillingDetails (например,
чтобы перечислить все счета пользователя), нужно составить другой запрос:
select * from USERS u
left outer join BILLINGDETAILS bd
on bd.USER_ID = u.ID
where u.ID = 123
Как видите, для эффективного использования соединения нужно заранее знать,
какое подмножество графа объектов понадобится посетить! При этом важно про-
являть осторожность: если вы извлечете слишком много данных (возможно, боль-
ше, чем могло бы понадобиться), вы потратите память на уровне приложения. Вы
можете также нагрузить базу данных SQL большим декартовым произведением
результирующих наборов. Представьте, что в одном запросе вы извлекаете не
только пользователей и банковские счета, но и все заказы, оплаченные с каждого
счета, товары в каждом заказе и т. д.
Каждая достойная применения система долговременного хранения объектов
обеспечивает возможность извлечения данных ассоциированных экземпляров,
только когда ассоциация действительно задействуется в Java-коде. Это называет-
ся «отложенной загрузкой»: данные извлекаются, только когда они действительно
необходимы. Такой последовательный стиль доступа к данным крайне неэффек-
тивен в контексте баз данных SQL, поскольку требует выполнения одного выра-
жения для каждого узла или коллекции графа объектов, по которому осуществля-
ется обход. Это та страшная проблема n + 1 запроса.
Различие способов доступа к данным в Java и реляционных базах данных явля-
ется, пожалуй, основным источником большинства проблем производительности
в информационных системах, написанных на Java. Несмотря на огромное коли-
чество книг и статей, советующих использовать StringBuffer для конкатенации
строк, для многих Java-программистов еще остается тайной, что следует избегать
ORM и JPA  41
проблем декартова произведения и n + 1 запроса. (Признайтесь: вы сейчас поду-
мали, что StringBuilder был бы гораздо лучше, чем StringBuffer.)
Hibernate обладает сложной функциональностью для эффективного и про-
зрачного извлечения графов объектов из базы данных для последующего доступа
к ним в приложении. Мы обсудим эту функциональность в главе 12.
У нас набрался целый список проблем объектно-реляционного несоответ-
ствия, и было бы очень затратно (как по времени, так и по усилиям) искать их ре-
шения, как вы, возможно, знаете по опыту. Потребовалась бы целая книга, чтобы
подробно осветить эти вопросы и продемонстрировать практическое решение на
основе ORM. Давайте начнем с обзора ORM, стандарта Java Persistence и проекта
Hibernate.
1.3. ORM и JPA
Вкратце объектно-реляционное отображение – это автоматическое (и прозрач-
ное) сохранение объекта из Java-приложения в таблицах базы данных SQL с ис-
пользованием метаданных, описывающих отображение между классами приложе-
ния и схемой базы данных SQL. По сути, ORM работает за счет преобразования
(двустороннего) данных из одного представления в другое. Прежде чем продол-
жить, вы должны понять, чего Hibernate не сможет сделать для вас.
Считается, что одним из преимуществ ORM является защита разработчика от
неприятного языка SQL. При таком взгляде предполагается, что не следует ожи-
дать от разработчиков объектно-ориентированных систем хорошего понимания
SQL или реляционных баз данных и что SQL будет лишь действовать им на нервы.
Мы же, напротив, считаем, что Java-разработчики должны быть достаточно
хорошо знакомы с реляционными моделями данных и SQL (а также понимать их
значение), чтобы работать с Hibernate. ORM является продвинутой технологией,
которую используют разработчики, напряженно поработавшие над этими пробле-
мами. Для эффективного использования Hibernate вы должны уметь читать и по-
нимать выражения на языке SQL, которые генерирует фреймворк, и их влияние
на производительность.
Давайте рассмотрим некоторые преимущества Hibernate.
 Продуктивность – Hibernate берет большую часть (больше, чем вы ожидаете)
рутинной работы на себя, позволяя сконцентрироваться на проблеме
предметной области. Не важно, какую стратегию разработки приложения
вы предпочитаете – сверху вниз, начиная от предметной модели, или сни-
зу вверх, начиная с существующей схемы базы данных, – Hibernate вместе
с подходящими инструментами значительно сократит время разработки.
 Простота сопровождения – автоматизация объектно-реляционного отобра-
жения с Hibernate способствует уменьшению количества строк кода, делая
систему более понятной и удобной для рефакторинга. Hibernate образует
прослойку между предметной моделью и схемой SQL, предохраняя каждую
модель от влияния незначительных изменений в другой.
42  Основы объектно-реляционного отображения
 Производительность – несмотря на то что механизм хранения, реализован-
ный вручную, может работать быстрее, так же как ассемблерный код будет
выполняться быстрее Java-кода, автоматизированные решения, подобные
Hibernate, позволяют использовать множество оптимизаций, работающих
всегда. Одним из примеров может служить эффективное и легко настраи-
ваемое кэширование на уровне приложения. Это означает, что разработчик
сможет потратить больше энергии на то, чтобы вручную оптимизировать
несколько оставшихся проблемных мест, вместо того чтобы предваритель-
но оптимизировать все сразу.
 Независимость от поставщика – Hibernate может помочь снизить неко-
торые риски, связанные с зависимостью от поставщика. Даже если вы не
планируете менять используемую СУБД, инструменты ORM, поддерживающие
несколько различных СУБД, предоставляют вам некоторый уро-
вень переносимости. Кроме того, независимость от СУБД обеспечивает та-
кой способ разработки, когда инженеры используют легковесную локальную
базу данных, а для тестирования и эксплуатации разворачивают приложе-
ние в другой системе.
Подход Hibernate к хранению данных был хорошо принят Java-разработчиками,
и на его основе был разработан стандарт Java Persistence API.
Основные упрощения, внесенные в последние спецификации EJB и Java EE,
коснулись JPA. Но мы должны сразу оговориться, что ни Java Persistence, ни Hibernate
не ограничены окружением Java EE; они являются инструментами обще-
го назначения для решения проблем долговременного хранения данных, которые
могут использоваться любым приложением на Java (Scala, Groovy).
Спецификация JPA определяет следующее:
 способ определения метаданных отображений – как хранимые классы и их
свойства соотносятся со схемой базы данных. JPA широко использует Java-
аннотации в классах предметной модели, но вы можете определять отобра-
жения при помощи XML;
 API для основных CRUD-операций, производимых над экземплярами хра-
нимых классов; наиболее известен класс javax.persistence.EntityManager,
используемый для сохранения и загрузки данных;
 язык и API для создания запросов, использующих классы и их свойства.
Этот язык называется Java Persistence Query Language (JPQL) и очень по-
хож на SQL. Стандартизированный API позволяет программно создавать
запросы с критериями без работы со строковыми значениями;
 порядок взаимодействия механизма хранения с транзакционными сущно-
стями для сравнения состояний объектов (dirty checking), извлечения ассо-
циаций и выполнения прочих оптимизаций. Кроме того, в последней спецификации
JPA рассмотрены основные стратегии кэширования.
Hibernate реализует JPA и поддерживает все стандартизированные отображе-
ния, запросы и программные интерфейсы.
Резюме  43
1.4. Резюме
 Благодаря возможности долговременного хранения объектов отдельные объ-
екты могут существовать дольше, чем процесс приложения; они могут быть
помещены в хранилище данных, а позже восстановлены. Когда в роли хра-
нилища данных выступает реляционная система управления базами данных,
основанная
на SQL, проявляются проблемы несоответствия объектной и ре-
ляционной парадигм. К примеру, граф объектов нельзя сохранить в табли-
цу базы данных непосредственно; прежде его необходимо разобрать, а затем
сохранить в столбцы переносимых SQL-типов. Хорошим решением данной
проблемы
является объектно-реляционное отображение (ORM).
 Объектно-реляционное отображение не является идеальным решением для
всех задач хранения; его цель – избавить разработчиков от 95% работы, свя-
занной с хранением, например от написания сложных выражений SQL с боль-
шим количеством соединений таблиц и копирования полученных значений
в объекты или графы объектов.
 Полноценное промежуточное программное обеспечение (middleware) для
ORM может предоставить переносимость между базами данных, некоторые
методы оптимизации, такие как кэширование, и некоторые другие практиче-
ские аспекты, которые трудно реализовать вручную с помощью SQL и JDBC,
имея при этом ограниченный запас времени.
 Однажды, возможно, появится решение лучше, чем ORM. Мы (как и многие
другие), возможно, переосмыслим все, что нам известно о системах управления
базами данных и их языках, о стандартах API доступа к хранимым данным, об
интеграции приложений. Но превращение современных систем в подлинные
реляционные системы с бесшовной поддержкой объектно-ориентированной
парадигмы остается чистой фантазией. Мы не можем ждать, и нет никаких
оснований
полагать, что какие-то из проблем будут скоро решены (много-
миллионная индустрия не очень гибкая). ORM в настоящее время является
лучшим решением, которое сберегает время разработчиков, каждый день стал-
кивающихся с проблемой несоответствия объектной и реляционной парадигм.
Глава 2
Создаем проект
В этой главе:
 обзор проектов с Hibernate;
 проект «Hello World» с Hibernate и Java Persistence;
 варианты конфигурации и интеграции.
В этой главе вы начнете работу с Hibernate и Java Persistence, используя пошаго-
вый пример. Мы рассмотрим оба прикладных интерфейса и то, как извлечь вы-
годы от использования только Hibernate или стандартизированного JPA. Сначала
мы предлагаем вашему вниманию обзор Hibernate на примере создания простей-
шего проекта «Hello World». Прежде чем начать программировать, вы должны ре-
шить, какие модули Hibernate будут использоваться в проекте.
2.1. Представляем Hibernate
Hibernate – это амбициозный проект, цель которого – дать полноценное решение
проблемы управления хранимыми данными в Java. На сегодняшний день Hibernate
– это не только служба ORM, но и набор инструментов управления данными,
выходящих далеко за пределы ORM по своей функциональности.
Hibernate включает следующие проекты:
 Hibernate ORM – Hibernate ORM состоит из ядра, базовой службы хране-
ния для баз данных SQL и оригинального API. Hibernate ORM является
основой нескольких проектов и самым старым проектом Hibernate. Можно
использовать один только фреймворк Hibernate ORM без привязки к кон-
кретной платформе или среде выполнения с любым JDK. Он работает на
любом сервере приложений Java EE/J2EE, в Swing-приложениях, в простых
контейнерах сервлетов и т. д. Для его нормальной работы требуется
только настроить источник данных;
 Hibernate EntityManager – реализация стандартного Java Persistence API, до-
полнительный модуль, устанавливаемый поверх Hibernate ORM. Вы в лю-
бой момент можете вернуться к использованию Hibernate, если требуется
обычный программный интерфейс, или даже к JDBC Connection. Функциональность
Hibernate является надмножеством функциональности JPA;
«HELLO WORLD» и JPA  45
 Hibernate Validator – эталонная реализация спецификации Bean Validation
(JSR 303). Независимо от других проектов Hibernate, она обеспечивает
декларативную проверку классов предметной модели (или любых других
классов);
 Hibernate Envers – целями Envers являются ведение журнала событий и хра-
нение нескольких версий данных в базе данных SQL. Позволяет хранить
историю изменения данных и событий подобно тому, как это делается в си-
стемах контроля версий, с которыми вы, возможно, уже знакомы, таких как
Subversion и Git;
 Hibernate Search – поддерживает актуальный индекс предметных данных
в базе данных Apache Lucene. Позволяет создавать запросы к этой базе
данных, используя мощный и естественно интегрированный API. Многие
проекты используют Hibernate Search в дополнение к Hibernate ORM для
поддержки полнотекстового поиска. Если у вас имеется форма для поис-
ка произвольного текста и вы хотели бы порадовать своих пользователей,
используйте Hibernate Search. Данный проект мы не рассматриваем в этой
книге; вы можете найти больше информации в книге «Hibernate Search in
Action» (Bernard, 2008) Эммануэля Бернарда (Emmanuel Bernard);
 Hibernate OGM – самый последний проект Hibernate, реализация объектно-
сеточного отображения (Object/Grid Mapping). Предоставляет под-
держку JPA для NoSQL-решений, используя ядро движка Hibernate, но
при этом отображая сущности в хранилища типа «ключ/значение», до-
кументные и графовые базы данных. Hibernate OGM не рассматривается
в этой книге.
Давайте приступим к первому проекту с Hibernate и JPA.
2.2. «HELLO WORLD» и JPA
В этом разделе вы создадите свое первое Hibernate-приложение, которое сохраня-
ет сообщение «Hello World» в базе данных, а затем извлекает его. Начнем с уста-
новки и настройки Hibernate.
Во всех примерах мы будем использовать инструмент сборки Apache Maven.
Объявим зависимость от Hibernate:
<dependency>
<groupId>org.hibernate</groupId>
<artifactId>hibernate-entitymanager</artifactId>
<version>5.0.0.Final</version>
</dependency>
Модуль hibernate-entitymanager содержит транзитивные зависимости от дру-
гих модулей, которые могут понадобиться, таких как hibernate-core и заглушки
интерфейсов Java Persistence.
В JPA отправной точкой является единица хранения (persistence unit). Едини-
ца хранения объединяет отображение классов предметной области и соединение
46  Создаем проект
с базой данных, а также содержит некоторые настройки. В каждом приложении
есть как минимум одна единица хранения; в некоторых приложениях их несколь-
ко, если они взаимодействуют с несколькими (физическими или логическими)
базами данных. Следовательно, первый шаг – настройка единицы хранения в кон-
фигурации приложения.
2.2.1. Настройка единицы хранения
Обычно конфигурационный файл единицы хранения располагается в пути по-
иска классов (classpath), в файле META-INF/persistence.xml. Создайте следующий
конфигурационный файл для приложения «Hello World»:
Файл: /model/src/main/resources/META-INF/persistence.xml
<persistence
version="2.1"
xmlns="http://xmlns.jcp.org/xml/ns/persistence"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
http://xmlns.jcp.org/xml/ns/persistence_2_1.xsd">
<persistence-unit name="HelloWorldPU">  Настройка единицы хранения
<jta-data-source>myDS</jta-data-source>  Соединение с базой данных
<class>org.jpwh.model.helloworld.Message</class>
<exclude-unlisted-classes>true</exclude-unlisted-classes>
<properties>  Набор свойств
<property
name="javax.persistence.schema-generation.database.action"
value="drop-and-create"/>  Удалить схему и создать заново
<property name="hibernate.format_sql" value="true"/>  Форматировать SQL
<property name="hibernate.use_sql_comments" value="true"/>
</properties>
</persistence-unit>
</persistence>
 Файл persistence.xml содержит настройки как минимум одной единицы хранения; если
их несколько, каждая должна иметь уникальное имя.
 Каждая единица хранения должна иметь соединение с базой данных. Здесь используется
существующий экземпляр java.sql.DataSource. Hibernate отыщет источник данных по
имени в каталоге JNDI во время запуска приложения.
 Единица хранения определяет хранимые (отображаемые) классы. Вы указываете их тут.
 Hibernate может искать отображаемые классы в каталоге классов и автоматически до-
бавлять их в единицу хранения. Эта функция здесь отключена.
 Стандартные параметры или параметры конкретного поставщика можно определять как
свойства единицы хранения. Любые стандартные свойства имеют префикс javax.persistence;
свойства Hibernate имеют префикс hibernate.
 Классы, хранимые
в базе данных
 Запретить поиск
отображаемых классов
«HELLO WORLD» и JPA  47
 Движок JPA должен автоматически удалить и заново создать схему SQL в базе данных
при загрузке. Это идеально для тестирования, когда важно иметь чистую базу данных
при каждом запуске тестов.
 При выводе SQL в журнал позволяет форматировать код запросов и добавлять в него
комментарии, чтобы вы понимали, почему Hibernate выполняет выражения SQL. Боль-
шинству приложений требуется пул соединений с базой данных с определенным раз-
мером и ограничениями, оптимизированными для конкретной среды. Также следует
указать хост СУБД и учетные данные для подключения к базе данных.
Журналирование SQL
Каждое SQL-выражение, выполняемое фреймворком Hibernate, можно записать
в журнал – незаменимый инструмент во время оптимизации. Для журналирова-
ния SQL-запросов установите значения свойств hibernate.format_sql и hibernate.
user_sql_comments в значение true в файле persistence.xml. В этом случае Hibernate
будет форматировать SQL-выражения с добавлением комментариев, описывающих
причины выполнения этих запросов. Затем в настройках журналирования
(которые зависят от выбранной реализации) в категориях org.hibernate.SQL и org.
hibernate.type.descriptor.sql.BasicBinder установите самый подробный уровень вы-
вода информации – отладочной. Благодаря этому вы сможете увидеть в журнале
все SQL-выражения, выполняемые Hibernate, включая значения параметров в па-
раметризованных запросах.
Для работы приложения «Hello World» управление соединениями с базой дан-
ных передается реализации Java Transaction API (JTA) – проекту Bitronix с откры-
тым исходным кодом. Bitronix поддерживает пул соединений, используя управ-
ляемый java.sql.DataSource и стандартный javax.transaction.UserTransaction
API в любом окружении Java SE. Bitronix включает эти объекты в каталог JNDI,
и интерфейсы Hibernate будут автоматически использовать Bitronix посредством
JNDI-поиска. Подробное описание установки Bitronix выходит за рамки этой кни-
ги; вы можете найти конфигурацию для наших примеров в org.jpwh.env.TransactionManagerSetup.
В приложении «Hello World» нам требуется организовать сохранение сообще-
ний в базу данных и извлечение их оттуда. Для этого в Hibernate-приложениях
определяются хранимые классы, которые затем отображаются в таблицы базы
данных. Эти классы определяются на основе анализа предметной области; то есть
они моделируют предметную область. Данный пример содержит один класс и его
отображение.
Давайте посмотрим, как выглядит обычный хранимый класс, как создается
отображение,
и узнаем, что можно делать с экземплярами хранимых классов в Hibernate.
2.2.2. Хранимый класс
Цель данного примера – сохранить сообщение в базе данных, извлечь его обратно
и показать. В приложении имеется один хранимый класс Message:
48  Создаем проект
Файл: /model/src/main/java/org/jpwh/model/helloworld/Message.java
package org.jpwh.model.helloworld;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
@Entity  Обязательная аннотация @Entity
public class Message {
@Id  Обязательная аннотация @Id
@GeneratedValue  Значение ID будет генерироваться автоматически
private Long id;
private String text;  Отображение атрибутов
public String getText() {
return text;
}
public void setText(String text) {
this.text = text;
}
}
 Каждый класс хранимой сущности должен иметь хотя бы одну аннотацию @Entity. Hibernate
автоматически отобразит этот класс в таблицу с названием MESSAGE.
 Каждый класс хранимой сущности должен иметь идентифицирующий атрибут, поме-
ченный аннотацией @Id. Hibernate отобразит этот атрибут в столбец с названием ID.
 Значения идентификатора должны каким-то образом создаваться; эта аннотация на-
страивает автоматическое создание идентификаторов.
 Обычно атрибуты хранимого класса реализуются как приватные или защищенные свой-
ства с общедоступными парами методов чтения/записи. Hibernate отобразит этот атри-
бут в столбец с названием TEXT.
Идентифицирующий атрибут позволяет приложению обращаться к идентифи-
катору хранимой сущности в базе данных – значению первичного ключа. Если два
экземпляра Message имеют одинаковое значение идентификатора, они представля-
ют одну запись в базе данных.
В этом примере используется идентифицирующий атрибут типа Long, но это не
является обязательным требованием. Как вы увидите позже, Hibernate позволяет
использовать идентификаторы практически любого типа.
Вы наверняка заметили, что атрибут text класса Message имеет методы доступа
к свойствам в стиле JavaBeans. Класс также имеет конструктор (по умолчанию)
без параметров. Хранимые классы, которые мы используем в примерах, будут по-
хожи на этот.
Экземпляры класса Message могут управляться (сохраняться) фреймворком
Hibernate, но это не обязательно. Поскольку объект Message не реализует особых
интерфейсов или классов, связанных с хранением, вы можете использовать его
как обычный Java-класс:
«HELLO WORLD» и JPA  49
Message msg = new Message();
msg.setText("Hello!");
System.out.println(msg.getText());
Может показаться, что мы здесь что-то мудрим; на самом деле мы хотим проде-
монстрировать важную особенность Hibernate, отличающую его от других реше-
ний хранения данных. Вы можете использовать хранимый класс в любом контек-
сте исполнения – никакой специальный контейнер для этого не требуется.
Не обязательно даже использовать аннотации для отображения хранимого
класса. Позже мы покажем вам другие способы отображения, такие как orm.xml,
файл отображения для JPA, оригинальные файлы отображения hbm.xml, и расска-
жем, в каких случаях они оказываются предпочтительнее, чем аннотации в ис-
ходном коде.
Класс Message готов. Вы можете сохранять экземпляры в базе данных и писать
запросы для их загрузки обратно в память приложения.
2.2.3. Сохранение и загрузка сообщений
Вам наверняка не терпится увидеть Hibernate в действии, так что давайте сохра-
ним экземпляр Message в базе данных. Прежде всего для взаимодействий с базой
данных вам понадобится EntityManagerFactory. Этот API представляет единицу
хранения; в большинстве приложений поддерживается только один экземпляр
EntityManagerFactory для одной единицы хранения:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldJPA.java
EntityManagerFactory emf =
Persistence.createEntityManagerFactory("HelloWorldPU");
В момент запуска приложение должно создать EntityManagerFactory; фабрика
является потокобезопасной, и весь ваш код, взаимодействующий с базой данных,
должен использовать ее.
Теперь вы сможете запустить транзакцию и сохранить экземпляр Message:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldJPA.java
UserTransaction tx = TM.getUserTransaction();  Получаем доступ к UserTransaction
tx.begin();
EntityManager em = emf.createEntityManager();  Создаем EntityManager
Message message = new Message();  Создаем сообщение
message.setText("Hello World!");
em.persist(message);  Сохраняем сообщение
tx.commit();  Завершаем (commit) транзакцию
// INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World!')
em.close();  Закрываем EntityManager
 Получаем доступ к стандартному API управления транзакциями – UserTransaction –
и запускаем транзакцию в данном потоке выполнения.
50  Создаем проект
 Начинаем новый сеанс работы с базой данных путем создания EntityManager. Этот объ-
ект послужит контекстом для всех операций с хранилищем.
 Создаем новый экземпляр отображаемого класса предметной модели Message и задаем
его свойство text.
 Помещаем объект из памяти приложения (transient instance) в хранилище, делая его
хранимым. Теперь Hibernate знает, что вы хотели бы сохранить эти данные, но он не
обязательно обратится к базе данных в тот же момент.
 Завершаем транзакцию. Hibernate автоматически проверит контекст хранения и выпол-
нит необходимую SQL-инструкцию INSERT.
 Если EntityManager создан вами, вы должны его закрыть.
Чтобы помочь вам разобраться в том, как работает Hibernate, мы будем пока-
зывать автоматически созданные и выполненные SQL-выражения в виде коммен-
тариев в исходном коде. Hibernate вставляет запись в таблицу MESSAGE с автома-
тически сгенерированным значением столбца первичного ключа ID и значением
атрибута TEXT.
Вы можете загрузить эти данные позже, используя запрос к базе данных:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldJPA.java
UserTransaction tx = TM.getUserTransaction();  Граница транзакции
tx.begin();
EntityManager em = emf.createEntityManager();
List<Message> messages =  Выполнение запроса
em.createQuery("select m from Message m").getResultList();
// SELECT * from MESSAGE
assertEquals(messages.size(), 1);
assertEquals(messages.get(0).getText(), "Hello World!");
messages.get(0).setText("Take me to your leader!");  Меняем значение свойства
tx.commit();  Выполнит UPDATE
// UPDATE MESSAGE set TEXT = 'Take me to your leader!' where ID = 1
em.close();
 Каждое взаимодействие с базой данных должно осуществляться внутри явно заданных
границ транзакции, даже если вы просто читаете данные.
 Выполняем запрос для извлечения всех сообщений из базы данных.
 Вы можете поменять значение свойства. Hibernate автоматически обнаружит это изме-
нение, т. к. загруженный экземпляр Message остается связанным с контекстом хранения,
куда он был загружен.
 В момент фиксации транзакции Hibernate проверит контекст хранения на предмет из-
менения состояния и автоматически выполнит SQL-запрос UPDATE для синхронизации
состояния базы данных с объектом в памяти.
Язык запросов, который вы увидели в примере, – это не SQL, а Java Persistence
Query Language (JPQL). В этом простейшем примере нет синтаксической разни-
Оригинальная конфигурация Hibernate  51
цы, тем не менее Message в тексте запроса означает не имя таблицы базы данных,
а имя хранимого класса. Если вы отобразите класс в другую таблицу, запрос будет
продолжать работать.
Также стоить отметить, что Hibernate автоматически определяет изменение
текста сообщения и сохраняет их в базе данных. Это – одна из особенностей JPA,
автоматическое сравнение состояния объектов в действии. Больше нет необходи-
мости явно требовать от диспетчера хранилища обновить базу данных, когда вы
меняете состояние объекта в транзакции.
Вот вы и закончили создание своего первого приложения с Hibernate и JPA. Вы,
возможно, заметили, что мы предпочитаем писать примеры в виде исполняемых
тестов, используя утверждения (assertions) для проверки правильности результа-
та каждой операции. Мы взяли все примеры для этой книги из тестового кода,
чтобы вы (и мы) могли быть уверены, что все работает как надо. Но это, к сожале-
нию, означает, что вам потребуется добавить несколько строк кода, чтобы создать
EntityManagerFactory в тестовом окружении. Мы постарались сделать настройку
тестов как можно более простой. Этот код вы найдете в org.jpwh.env.JPASetup и
org.jpwh.env.JPATest; используйте его как отправную точку при написании соб-
ственных тестов.
Прежде чем начать работу над более жизненными примерами, давайте посмотрим,
как осуществляется настройка Hibernate.
2.3. Оригинальная конфигурация Hibernate
Несмотря на то что основная (и обширная) настройка стандартизирована в JPA,
вы не сможете получить доступа ко всем нюансам конфигурации Hibernate че-
рез persistence.xml. Отметим также, что большинство приложений, даже весьма
сложных, не требует особых настроек и, таким образом, не использует API для
начальной загрузки, показанный в этом разделе. Если вы не уверены, можете
пропустить этот раздел, чтобы вернуться к нему позже, когда потребуется рас-
ширить адаптеры типов (type adapters) Hibernate, добавить нестандартные SQL-
функции и т. д.
Оригинальным эквивалентом EntityManagerFactory из JPA является класс org.
hibernate.SessionFactory. Как правило, он один во всем приложении; также он
объединяет отображения классов с конфигурацией подключения к базе данных.
Оригинальный API для начальной загрузки Hibernate состоит из нескольких
уровней, предоставляющих доступ к определенным аспектам конфигурации.
В наиболее кратком виде построение SessionFactory выглядит следующим об-
разом:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldHibernate.java
SessionFactory sessionFactory = new MetadataSources(
new StandardServiceRegistryBuilder()
.configure("hibernate.cfg.xml").build()
).buildMetadata().buildSessionFactory();
52  Создаем проект
Этот код загрузит все настройки из конфигурационного файла Hibernate. Если
у вас есть существующий проект, возможно, этот файл уже находится в пути по-
иска классов. Подобно persistence.xml, этот конфигурационный файл, содержит
детали подключения к базе данных, а также список хранимых классов и других
свойств конфигурации.
Давайте проанализируем этот фрагмент кода и рассмотрим API более детально.
Сначала создадим экземпляр ServiceRegistry:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldHibernate.java
StandardServiceRegistryBuilder serviceRegistryBuilder =  Конструктор
new StandardServiceRegistryBuilder();
serviceRegistryBuilder  Конфигурация реестра служб
.applySetting("hibernate.connection.datasource", "myDS")
.applySetting("hibernate.format_sql", "true")
.applySetting("hibernate.use_sql_comments", "true")
.applySetting("hibernate.hbm2ddl.auto", "create-drop");
ServiceRegistry serviceRegistry = serviceRegistryBuilder.build();
 Этот конструктор поможет создать неизменяемый реестр служб посредством вызова це-
почки методов.
 Настраиваем реестр служб, применяя настройки.
Если вы хотите вынести конфигурацию реестра служб в отдельный файл, мо-
жете загружать настройки из файла свойств в пути поиска классов при помощи St
andardServiceRegistryBuilder#load-Properties(file).
Построив неизменяемый экземпляр ServiceRegistry, вы можете перейти к следующему
этапу: сообщить Hibernate, какие из хранимых классов являются частью ме-
таданных отображения. Источники метаданных настраиваются следующим образом:
Файл:/examples/src/est/java/org/jpwh/helloworld/HelloWorldHibernate.java
MetadataSources metadataSources = new MetadataSources(serviceRegistry);
metadataSources.addAnnotatedClass(
org.jpwh.model.helloworld.Message.class
);
// Добавить файлы отображения hbm.xml
// metadataSources.addFile(...);
// Прочитать все файлы отображения hbm.xml из сборки JAR
// metadataSources.addJar(...)
MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();
 Этот конструктор помогает создать неизменяемый реестр служб с использованием це-
почки вызовов методов.
 Конфигурирование реестра служб применением настроек.
В прикладном программном интерфейсе MetadataSources имеется множество
методов для добавления источников отображений; за дополнительной инфор-
 Требуется
реестр служб
 Добавляем хранимые классы
в источники метаданных
Оригинальная конфигурация Hibernate  53
мацией обращайтесь к документации JavaDoc. Следующий этап процедуры
начальной загрузки – построение всех метаданных, нужных фреймворку Hibernate,
с помощью экземпляра MetadataBuilder, полученного из источников
метаданных.
После этого можно запросить метаданные для программного взаимодействия
с конфигурацией Hibernate или продолжить и построить SessionFactory:
Файл:/examples/src/test/java/org/jpwh/helloworld/HelloWorldHibernate.java
Metadata metadata = metadataBuilder.build();
assertEquals(metadata.getEntityBindings().size(), 1);
SessionFactory sessionFactory = metadata.buildSessionFactory();
Создание EntityManagerFactory с помощью SessionFactory
На момент написания книги Hibernate не имел удобного API для программного
создания EntityManagerFactory. Для этой цели можно использовать внутренний API:
класс org.hibernate.jpa.internal.EntityManagerFactoryImpl имеет конструктор, при-
нимающий экземпляр SessionFactory.
Давайте убедимся, что данная конфигурация работает, сохранив и загрузив со-
общение с помощью оригинального Hibernate-эквивалента класса EntityManager–
org.hibernate.Session. Создать экземпляр Session можно при помощи SessionFactory,
кроме того, сеанс должен закрываться так же, как EntityManager.
Или можно использовать другую особенность Hibernate и предоставить фрейм-
ворку самому позаботиться о закрытии Session с помощью SessionFactory#getCur
rentSession():
Файл:/examples/src/ test/java/org/jpwh/helloworld/HelloWorldHibernate.java
UserTransaction tx = TM.getUserTransaction();  Получаем доступ к UserTransaction
tx.begin();
Session session =
sessionFactory.getCurrentSession();  Получаем org.hibernate.Session
Message message = new Message();
message.setText("Hello World!");
session.persist(message);  Прикладные интерфейсы JPA и Hibernate схожи
tx.commit();  Фиксируем транзакцию
// INSERT into MESSAGE (ID, TEXT) values (1, 'Hello World!')
 Получаем доступ к стандартному программному интерфейсу управления транзакция-
ми – UserTransaction – и запускаем транзакцию в текущем потоке выполнения.
 Когда бы вы ни вызывали getCurrentSession() в том же потоке, вы всегда будете полу-
чать тот же экземпляр org.hibernate.Session. Он автоматически связывается с текущей
транзакцией и закрывается автоматически при фиксации или откате транзакции.
54  Создаем проект
 Прикладной интерфейс Hibernate очень похож на стандартный Java Persistence API,
и большинство методов называется одинаково.
 Hibernate синхронизирует сеанс с базой данных и автоматически закрывает «текущий»
сеанс в момент фиксации связанной транзакции.
Использование текущего сеанса помогает сократить код:
Файл:/examples/src/test/java/org/jpwh/helloworld/HelloWorldHibernate.java
UserTransaction tx = TM.getUserTransaction();
tx.begin();
List<Message> messages =  Запрос на основе критериев
sessionFactory.getCurrentSession().createCriteria(
Message.class
).list();
// SELECT * from MESSAGE
assertEquals(messages.size(), 1);
assertEquals(messages.get(0).getText(), "Hello World!");
tx.commit();
 Запрос на основе критериев Hibernate – это типобезопасный способ программного со-
ставления запросов, автоматически преобразуемых в SQL.
Большинство примеров в этой книге не использует классов SessionFactory
и Session. Время от времени, когда определенная функциональность будет до-
ступна только в Hibernate, мы будем демонстрировать, как доставать (unwrap())
оригинальные интерфейсы из стандартных API.
2.4. Резюме
 Вы завершили свой первый JPA-проект.
 Вы написали первый хранимый класс и его отображение с помощью аннота-
ций.
 Вы узнали, как настроить и выполнить начальную загрузку единицы хране-
ния, как создать точку доступа EntityManagerFactory. Затем вы использовали
EntityManager для взаимодействия с базой данных, сохраняя и загружая экземпляры
хранимых классов предметной модели.
 Мы обсудили некоторые более продвинутые возможности настройки Hibernate,
а также эквивалентные базовые API, предоставляемые Hibernate: SessionFactory
и Session.
Глава 3
Модели
предметной области
и метаданные
В этой главе:
 учебное приложение CaveatEmptor;
 реализация предметной модели;
 типы метаданных объектно-реляционного отображения.
Пример «Hello World» из предыдущей главы познакомил вас с Hibernate; оче-
видно, он не особо полезен для понимания требований к реальным приложениям
со сложными моделями данных. До конца книги мы будем использовать более
сложное учебное приложение – CaveatEmptor, систему онлайн-аукциона – для де-
монстрации возможностей Hibernate и Java Persistence («caveat emptor» означает
по-латыни «Пусть покупатель будет бдителен»).
Главные нововведения в JPA 2
 Реализации JPA теперь автоматически интегрируются с реализациями Bean
Validation. В момент сохранения данных реализация автоматически проверяет
ограничения хранимых классов.
 Добавлен класс Metamodel. Вы можете получать доступ (но, к сожалению, не из-
менять) к именам, свойствам и метаданным отображения классов в единице
хранения.
Начнем обзор приложения со знакомства с его многоуровневой архитектурой.
После этого вы узнаете, как выявлять бизнес-сущности предметной области. Соз-
дадите концептуальную модель этих сущностей и их атрибутов, называемую мо-
делью предметной области, и реализуете ее на Java в виде хранимых классов. Мы
потратим немного времени, чтобы выяснить, как эти классы должны выглядеть
56  Модели предметной области и метаданные
и какое место они занимают в типичной архитектуре многоуровневого приложе-
ния. Мы также рассмотрим возможности долговременного хранения классов и то,
как эта особенность влияет на проектирование и реализацию. Мы добавим под-
держку Bean Validation для автоматической проверки целостности данных пред-
метной области, относящихся не только к хранимой информации, но и ко всей
бизнес-логике.
Затем мы исследуем типы метаданных отображений, помогающих сообщить
фреймворку Hibernate, как хранимые классы и их свойства соотносятся с таблица-
ми базы данных и столбцами. Это делается так же просто, как добавление аннота-
ций прямо в исходный код Java-классов или создание XML-документов, которые
впоследствии будут развернуты вместе с откомпилированными Java-классами
и к которым Hibernate сможет получить доступ во время выполнения. Прочитав
эту главу, вы узнаете, как в по-настоящему сложных проектах определять те части
предметной области, которые связаны с хранением, и какой тип метаданных пред-
почтительнее в той или иной ситуации. Приступим к созданию приложения.
3.1. Учебное приложение CaveatEmptor
Пример CaveatEmptor – это приложение онлайн-аукциона, демонстрирующее
приемы работы с ORM и возможности Hibernate. Вы можете загрузить исходный
код приложения по адресу: http://www.jpwh.org. В этой книге мы не будем уделять
большого внимания пользовательскому интерфейсу (это может быть веб- или
«толстый» клиент), а сосредоточимся на реализации доступа к данным. В том
случае, когда проектные решения, касающиеся доступа к данным, будут иметь
последствия для пользовательского интерфейса, мы естественно будем обращать
внимание на оба аспекта.
Чтобы понять проблемы проектирования, связанные с ORM, притворимся, что
приложения CaveatEmptor еще не существует и вы создаете его с нуля. Начнем
с рассмотрения архитектуры.
3.1.1. Многоуровневая архитектура
В любом нетривиальном приложении обычно имеет смысл организовать классы
согласно областям ответственности. Долговременное хранение – одна область от-
ветственности; другие включают представление, рабочий процесс и бизнес-логи-
ку. Типичная объектно-ориентированная архитектура состоит из уровней, пред-
ставляющих области ответственности.
Сквозные задачи
Кроме всех прочих, существуют еще так называемые сквозные задачи, которые
могут иметь реализацию, общую для всех приложений, например в коде фрейм-
ворка. К типичным сквозным задачам относятся журналирование, авторизация
и разграничение транзакций.
Учебное приложение CaveatEmptor  57
Многоуровневая архитектура определяет интерфейсы, используемые реали-
зациями различных областей ответственности, и позволяет вносить изменения
в реализацию каждого уровня без серьезного нарушения работы других. Подоб-
ное разделение определяет типы зависимостей между уровнями. Многоуровневая
архитектура должна подчиняться следующим правилам:
 передача информации осуществляется сверху вниз. Каждый уровень зави-
сит только от интерфейса того уровня, который находится непосредственно
под ним;
 каждый уровень ничего не знает о других уровнях, кроме нижележащего.
В различных системах области ответственности группируются по-разному,
определяя различные уровни. Типичная проверенная временем высокоуровневая
архитектура приложения использует три уровня: представления, бизнес-логики
и хранения, как показано на рис. 3.1.
Модель
предметной
области
Уровень представления
Уровень бизнес-логики
Уровень хранения
База
данных
Обработчики,
утилиты
и вспомогательные
классы
Рис. 3.1  Уровень хранения
является базовым в многоуровневой архитектуре
 Уровень представления – логика пользовательского интерфейса находится
на самом верху. Код, отвечающий за представление, управление страницей
и навигацию, находится в уровне представления. Код пользовательского
интерфейса может обращаться напрямую к бизнес-сущностям общей мо-
дели предметной области и отображать их на экране вместе с элементами
управления для выполнения различных действий. В некоторых архитекту-
рах экземпляры бизнес-сущностей могут быть недоступны коду пользова-
тельского интерфейса напрямую: например, когда уровень представления
работает на другом компьютере. В таких случаях уровню представления
может потребоваться собственная специальная модель передачи данных,
представляющая лишь подмножество модели предметной области, подхо-
дящей для передачи.
 Уровень бизнес-логики – конкретные формы этого уровня сильно различа-
ются в зависимости от приложения. Считается, что уровень бизнес-логики
отвечает за реализацию любых бизнес-правил или системных требований,
58  Модели предметной области и метаданные
которые воспринимаются пользователями как относящиеся к предметной
области. Этот уровень обычно содержит некий управляющий компонент,
который знает, когда и какое бизнес-правило применять. В одних системах
этот уровень имеет свое внутреннее представление сущностей предметной
области. В других – он зависит от реализации предметной модели, общей
для всех уровней приложения.
 Уровень хранения – уровень длительного хранения данных состоит из набо-
ра классов и компонентов, ответственных за сохранение и извлечение дан-
ных из одного или нескольких хранилищ. Этому уровню требуется модель
сущностей предметной области, состояния которых предполагается хранить.
Уровень хранения – то место, где больше всего используются JPA и Hibernate.
 База данных – как правило, является внешней и используется нескольки-
ми приложениями. Если используется база данных SQL, у нее есть схема
и, возможно, хранимые процедуры для выполнения бизнес-логики в непо-
средственной близости к данным.
 Вспомогательные и служебные классы – в каждом приложении имеется на-
бор инфраструктурных вспомогательных и служебных классов, которые
используются во всех уровнях приложения (как, например, класс Exception
для обработки ошибок). Эти общие инфраструктурные элементы не обра-
зуют отдельного уровня, т. к. для них не выполняются правила зависимости
между уровнями в многоуровневой архитектуре.
Теперь, после знакомства с высокоуровневой архитектурой, можно сосредото-
читься на решении проблем предметной области.
3.1.2. Анализ предметной области
На следующем этапе вы, совместно с экспертами в предметной области, должны
проанализировать проблемы, которые предстоит решать вашему программному
обеспечению, а также определить основные сущности и способы взаимодействий
между ними. Главный мотив проведения анализа и проектирования предметной
модели состоит в выявлении сути предметной области для целей разработки при-
ложения.
Сущности, как правило, являются понятиями, знакомыми пользователям си-
стемы: платеж, клиент, заказ, товар, предложение цены на аукционе и т. д. Не-
которые сущности могут представлять менее конкретные абстракции, такие как
алгоритм формирования цен; но даже такие сущности понятны пользователям.
Вы можете найти все эти сущности в концептуальном представлении бизнеса, ко-
торое иногда называют бизнес-моделью.
На основе этой бизнес-модели инженеры и архитекторы объектно-ориентиро-
ванного ПО создают объектно-ориентированную модель, но пока лишь на концеп-
туальном уровне (без Java-кода). Такая модель может быть столь же простой, как
мысленный образ, находящийся лишь в голове разработчика, или столь же под-
робной, как UML-диаграмма класса. На рис. 3.2 показана простая модель, пред-
ставленная с помощью UML.
Учебное приложение CaveatEmptor  59
User sells 0..* Item 0..* Category
Рис. 3.2  Диаграмма классов модели
типичного онлайн-аукциона
Эта модель содержит сущности, которые вы обязательно найдете в любой си-
стеме электронной торговли: категория, товар и пользователь. Эта предметная
модель представляет все сущности и их отношения (и, возможно, атрибуты). Мы
называем такой вид объектно-ориентированной модели, включающей только наи-
более важные для пользователя сущности предметной области, моделью предмет-
ной области (или предметной моделью). Она является абстрактным представле-
нием реального мира.
Вместо объектно-ориентированной модели инженеры и архитекторы могут на-
чать проектирование приложения с модели данных (возможно, представленной
диаграммами «сущность–связь»). Мы обычно говорим, что по отношению к меха-
низму хранения между двумя моделями нет большой разницы; они просто явля-
ются разными отправными точками. В конечном итоге выбор языка моделирова-
ния играет второстепенную роль; больше всего мы заинтересованы в структурах
и отношениях бизнес-сущностей. Нас заботят правила, которые необходимо при-
менять для поддержания целостности данных, и процедуры, манипулирующие
этими данными.
В следующем разделе мы завершим анализ предметной области приложения
CaveatEmptor. Полученная модель предметной области станет центральной темой
этой книги.
3.1.3. Предметная модель приложения CaveatEmptor
Сайт CaveatEmptor продает с аукциона различные виды товаров – от электронно-
го оборудования до билетов на самолет. Аукцион проходит согласно английской
аукционной стратегии: пользователи продолжают предлагать цену за товар, пока
не закончится торг, после чего побеждает предложивший наибольшую цену.
В любом магазине товары делятся на категории и объединяются с похожими
товарами в отделах и на полках. Каталог аукциона требует некоторой иерархии
категорий товаров, чтобы покупатель мог просматривать эти категории или про-
извольно искать по категории или атрибутам товара. Списки